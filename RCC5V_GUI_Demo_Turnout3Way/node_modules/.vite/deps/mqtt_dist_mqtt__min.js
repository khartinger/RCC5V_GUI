import {
  __commonJS,
  __require
} from "./chunk-CQXHTUV2.js";

// node_modules/mqtt/dist/mqtt.min.js
var require_mqtt_min = __commonJS({
  "node_modules/mqtt/dist/mqtt.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).mqtt = e();
      }
    }(function() {
      return function e(t, r, n) {
        function i(o2, a) {
          if (!r[o2]) {
            if (!t[o2]) {
              var l = "function" == typeof __require && __require;
              if (!a && l)
                return l(o2, true);
              if (s)
                return s(o2, true);
              var u = new Error("Cannot find module '" + o2 + "'");
              throw u.code = "MODULE_NOT_FOUND", u;
            }
            var c = r[o2] = { exports: {} };
            t[o2][0].call(c.exports, function(e2) {
              return i(t[o2][1][e2] || e2);
            }, c, c.exports, e, t, r, n);
          }
          return r[o2].exports;
        }
        for (var s = "function" == typeof __require && __require, o = 0; o < n.length; o++)
          i(n[o]);
        return i;
      }({ 1: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.TypedEventEmitter = void 0;
        const i = n(e("events")), s = e("./shared");
        class o {
        }
        r.TypedEventEmitter = o, (0, s.applyMixin)(o, i.default);
      }, { "./shared": 17, events: 49 }], 2: [function(e, t, r) {
        (function(t2, n) {
          (function() {
            "use strict";
            var i = this && this.__createBinding || (Object.create ? function(e2, t3, r2, n2) {
              void 0 === n2 && (n2 = r2);
              var i2 = Object.getOwnPropertyDescriptor(t3, r2);
              i2 && !("get" in i2 ? !t3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                return t3[r2];
              } }), Object.defineProperty(e2, n2, i2);
            } : function(e2, t3, r2, n2) {
              void 0 === n2 && (n2 = r2), e2[n2] = t3[r2];
            }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t3) {
              Object.defineProperty(e2, "default", { enumerable: true, value: t3 });
            } : function(e2, t3) {
              e2.default = t3;
            }), o = this && this.__importStar || function(e2) {
              if (e2 && e2.__esModule)
                return e2;
              var t3 = {};
              if (null != e2)
                for (var r2 in e2)
                  "default" !== r2 && Object.prototype.hasOwnProperty.call(e2, r2) && i(t3, e2, r2);
              return s(t3, e2), t3;
            }, a = this && this.__importDefault || function(e2) {
              return e2 && e2.__esModule ? e2 : { default: e2 };
            };
            Object.defineProperty(r, "__esModule", { value: true });
            const l = a(e("./topic-alias-recv")), u = a(e("mqtt-packet")), c = a(e("./default-message-id-provider")), h = e("readable-stream"), f = a(e("reinterval")), d = a(e("rfdc/default")), p = o(e("./validations")), b = a(e("debug")), g = a(e("./store")), m = a(e("./handlers")), y = e("./TypedEmitter"), _ = t2 ? t2.nextTick : (e2) => {
              setTimeout(e2, 0);
            }, w = n.setImmediate || ((...e2) => {
              const t3 = e2.shift();
              _(() => {
                t3(...e2);
              });
            }), v = { keepalive: 60, reschedulePings: true, protocolId: "MQTT", protocolVersion: 4, reconnectPeriod: 1e3, connectTimeout: 3e4, clean: true, resubscribe: true, writeCache: true }, S = ["ECONNREFUSED", "EADDRINUSE", "ECONNRESET", "ENOTFOUND", "ETIMEDOUT"];
            class E extends y.TypedEventEmitter {
              static defaultId() {
                return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
              }
              constructor(e2, t3) {
                super(), this.options = t3 || {};
                for (const e3 in v)
                  void 0 === this.options[e3] ? this.options[e3] = v[e3] : this.options[e3] = t3[e3];
                this.log = this.options.log || (0, b.default)("mqttjs:client"), this.noop = this._noop.bind(this), this.log("MqttClient :: options.protocol", t3.protocol), this.log("MqttClient :: options.protocolVersion", t3.protocolVersion), this.log("MqttClient :: options.username", t3.username), this.log("MqttClient :: options.keepalive", t3.keepalive), this.log("MqttClient :: options.reconnectPeriod", t3.reconnectPeriod), this.log("MqttClient :: options.rejectUnauthorized", t3.rejectUnauthorized), this.log("MqttClient :: options.properties.topicAliasMaximum", t3.properties ? t3.properties.topicAliasMaximum : void 0), this.options.clientId = "string" == typeof t3.clientId ? t3.clientId : E.defaultId(), this.log("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = 5 === t3.protocolVersion && t3.customHandleAcks ? t3.customHandleAcks : (...e3) => {
                  e3[3](null, 0);
                }, this.options.writeCache || (u.default.writeToStream.cacheNumbers = false), this.streamBuilder = e2, this.messageIdProvider = void 0 === this.options.messageIdProvider ? new c.default() : this.options.messageIdProvider, this.outgoingStore = t3.outgoingStore || new g.default(), this.incomingStore = t3.incomingStore || new g.default(), this.queueQoSZero = void 0 === t3.queueQoSZero || t3.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = false, this.disconnecting = false, this.reconnecting = false, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = false, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = true, t3.properties && t3.properties.topicAliasMaximum > 0 && (t3.properties.topicAliasMaximum > 65535 ? this.log("MqttClient :: options.properties.topicAliasMaximum is out of range") : this.topicAliasRecv = new l.default(t3.properties.topicAliasMaximum)), this.on("connect", () => {
                  const { queue: e3 } = this, t4 = () => {
                    const r2 = e3.shift();
                    this.log("deliver :: entry %o", r2);
                    let n2 = null;
                    if (!r2)
                      return void this._resubscribe();
                    n2 = r2.packet, this.log("deliver :: call _sendPacket for %o", n2);
                    let i2 = true;
                    n2.messageId && 0 !== n2.messageId && (this.messageIdProvider.register(n2.messageId) || (i2 = false)), i2 ? this._sendPacket(n2, (e4) => {
                      r2.cb && r2.cb(e4), t4();
                    }) : (this.log("messageId: %d has already used. The message is skipped and removed.", n2.messageId), t4());
                  };
                  this.log("connect :: sending queued packets"), t4();
                }), this.on("close", () => {
                  this.log("close :: connected set to `false`"), this.connected = false, this.log("close :: clearing connackTimer"), clearTimeout(this.connackTimer), this.log("close :: clearing ping timer"), null !== this.pingTimer && (this.pingTimer.clear(), this.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), this.log("close :: calling _setupReconnect"), this._setupReconnect();
                }), this.options.manualConnect || (this.log("MqttClient :: setting up stream"), this.connect());
              }
              handleAuth(e2, t3) {
                t3();
              }
              handleMessage(e2, t3) {
                t3();
              }
              _nextId() {
                return this.messageIdProvider.allocate();
              }
              getLastMessageId() {
                return this.messageIdProvider.getLastAllocated();
              }
              connect() {
                var e2;
                const t3 = new h.Writable(), r2 = u.default.parser(this.options);
                let n2 = null;
                const i2 = [];
                this.log("connect :: calling method to clear reconnect"), this._clearReconnect(), this.log("connect :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), r2.on("packet", (e3) => {
                  this.log("parser :: on packet push to packets array."), i2.push(e3);
                });
                const s2 = () => {
                  this.log("work :: getting next packet in queue");
                  const e3 = i2.shift();
                  if (e3)
                    this.log("work :: packet pulled from queue"), (0, m.default)(this, e3, o2);
                  else {
                    this.log("work :: no packets in queue");
                    const e4 = n2;
                    n2 = null, this.log("work :: done flag is %s", !!e4), e4 && e4();
                  }
                }, o2 = () => {
                  if (i2.length)
                    _(s2);
                  else {
                    const e3 = n2;
                    n2 = null, e3();
                  }
                };
                t3._write = (e3, t4, i3) => {
                  n2 = i3, this.log("writable stream :: parsing buffer"), r2.parse(e3), s2();
                };
                this.log("connect :: pipe stream to writable stream"), this.stream.pipe(t3), this.stream.on("error", (e3) => {
                  this.log("streamErrorHandler :: error", e3.message), S.includes(e3.code) ? (this.log("streamErrorHandler :: emitting error"), this.emit("error", e3)) : this.noop(e3);
                }), this.stream.on("close", () => {
                  this.log("(%s)stream :: on close", this.options.clientId), this._flushVolatile(), this.log("stream: emit close to MqttClient"), this.emit("close");
                }), this.log("connect: sending packet `connect`");
                const a2 = { cmd: "connect", protocolId: this.options.protocolId, protocolVersion: this.options.protocolVersion, clean: this.options.clean, clientId: this.options.clientId, keepalive: this.options.keepalive, username: this.options.username, password: this.options.password, properties: this.options.properties };
                if (this.options.will && (a2.will = Object.assign(Object.assign({}, this.options.will), { payload: null === (e2 = this.options.will) || void 0 === e2 ? void 0 : e2.payload })), this.topicAliasRecv && (a2.properties || (a2.properties = {}), this.topicAliasRecv && (a2.properties.topicAliasMaximum = this.topicAliasRecv.max)), this._writePacket(a2), r2.on("error", this.emit.bind(this, "error")), this.options.properties) {
                  if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData)
                    return this.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
                  if (this.options.properties.authenticationMethod && this.options.authPacket && "object" == typeof this.options.authPacket) {
                    const e3 = Object.assign({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
                    this._writePacket(e3);
                  }
                }
                return this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(() => {
                  this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`"), this._cleanUp(true);
                }, this.options.connectTimeout), this;
              }
              publish(e2, t3, r2, n2) {
                this.log("publish :: message `%s` to topic `%s`", t3, e2);
                const { options: i2 } = this;
                "function" == typeof r2 && (n2 = r2, r2 = null), r2 = r2 || {};
                r2 = Object.assign(Object.assign({}, { qos: 0, retain: false, dup: false }), r2);
                const { qos: s2, retain: o2, dup: a2, properties: l2, cbStorePut: u2 } = r2;
                if (this._checkDisconnecting(n2))
                  return this;
                const c2 = () => {
                  let r3 = 0;
                  if ((1 === s2 || 2 === s2) && (r3 = this._nextId(), null === r3))
                    return this.log("No messageId left"), false;
                  const c3 = { cmd: "publish", topic: e2, payload: t3, qos: s2, retain: o2, messageId: r3, dup: a2 };
                  switch (5 === i2.protocolVersion && (c3.properties = l2), this.log("publish :: qos", s2), s2) {
                    case 1:
                    case 2:
                      this.outgoing[c3.messageId] = { volatile: false, cb: n2 || this.noop }, this.log("MqttClient:publish: packet cmd: %s", c3.cmd), this._sendPacket(c3, void 0, u2);
                      break;
                    default:
                      this.log("MqttClient:publish: packet cmd: %s", c3.cmd), this._sendPacket(c3, n2, u2);
                  }
                  return true;
                };
                return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !c2()) && this._storeProcessingQueue.push({ invoke: c2, cbStorePut: r2.cbStorePut, callback: n2 }), this;
              }
              publishAsync(e2, t3, r2) {
                return new Promise((n2, i2) => {
                  this.publish(e2, t3, r2, (e3) => {
                    e3 ? i2(e3) : n2();
                  });
                });
              }
              subscribe(e2, t3, r2) {
                const n2 = this.options.protocolVersion;
                "function" == typeof t3 && (r2 = t3), r2 = r2 || this.noop;
                let i2 = false, s2 = [];
                "string" == typeof e2 ? s2 = e2 = [e2] : Array.isArray(e2) ? s2 = e2 : "object" == typeof e2 && (i2 = e2.resubscribe, delete e2.resubscribe, s2 = Object.keys(e2));
                const o2 = p.validateTopics(s2);
                if (null !== o2)
                  return w(r2, new Error(`Invalid topic ${o2}`)), this;
                if (this._checkDisconnecting(r2))
                  return this.log("subscribe: discconecting true"), this;
                const a2 = { qos: 0 };
                5 === n2 && (a2.nl = false, a2.rap = false, a2.rh = 0);
                const l2 = (t3 = Object.assign(Object.assign({}, a2), t3)).properties, u2 = [], c2 = (e3, r3) => {
                  if (r3 = r3 || t3, !Object.prototype.hasOwnProperty.call(this._resubscribeTopics, e3) || this._resubscribeTopics[e3].qos < r3.qos || i2) {
                    const t4 = { topic: e3, qos: r3.qos };
                    5 === n2 && (t4.nl = r3.nl, t4.rap = r3.rap, t4.rh = r3.rh, t4.properties = l2), this.log("subscribe: pushing topic `%s` and qos `%s` to subs list", t4.topic, t4.qos), u2.push(t4);
                  }
                };
                if (Array.isArray(e2) ? e2.forEach((e3) => {
                  this.log("subscribe: array topic %s", e3), c2(e3);
                }) : Object.keys(e2).forEach((t4) => {
                  this.log("subscribe: object topic %s, %o", t4, e2[t4]), c2(t4, e2[t4]);
                }), !u2.length)
                  return r2(null, []), this;
                const h2 = () => {
                  const e3 = this._nextId();
                  if (null === e3)
                    return this.log("No messageId left"), false;
                  const t4 = { cmd: "subscribe", subscriptions: u2, messageId: e3 };
                  if (l2 && (t4.properties = l2), this.options.resubscribe) {
                    this.log("subscribe :: resubscribe true");
                    const e4 = [];
                    u2.forEach((t5) => {
                      if (this.options.reconnectPeriod > 0) {
                        const r3 = { qos: t5.qos };
                        5 === n2 && (r3.nl = t5.nl || false, r3.rap = t5.rap || false, r3.rh = t5.rh || 0, r3.properties = t5.properties), this._resubscribeTopics[t5.topic] = r3, e4.push(t5.topic);
                      }
                    }), this.messageIdToTopic[t4.messageId] = e4;
                  }
                  return this.outgoing[t4.messageId] = { volatile: true, cb(e4, t5) {
                    if (!e4) {
                      const { granted: e5 } = t5;
                      for (let t6 = 0; t6 < e5.length; t6 += 1)
                        u2[t6].qos = e5[t6];
                    }
                    r2(e4, u2);
                  } }, this.log("subscribe :: call _sendPacket"), this._sendPacket(t4), true;
                };
                return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !h2()) && this._storeProcessingQueue.push({ invoke: h2, callback: r2 }), this;
              }
              subscribeAsync(e2, t3) {
                return new Promise((r2, n2) => {
                  this.subscribe(e2, t3, (e3, t4) => {
                    e3 ? n2(e3) : r2(t4);
                  });
                });
              }
              unsubscribe(e2, t3, r2) {
                "string" == typeof e2 && (e2 = [e2]), "function" == typeof t3 && (r2 = t3), r2 = r2 || this.noop;
                const n2 = p.validateTopics(e2);
                if (null !== n2)
                  return w(r2, new Error(`Invalid topic ${n2}`)), this;
                if (this._checkDisconnecting(r2))
                  return this;
                const i2 = () => {
                  const n3 = this._nextId();
                  if (null === n3)
                    return this.log("No messageId left"), false;
                  const i3 = { cmd: "unsubscribe", messageId: n3, unsubscriptions: [] };
                  return "string" == typeof e2 ? i3.unsubscriptions = [e2] : Array.isArray(e2) && (i3.unsubscriptions = e2), this.options.resubscribe && i3.unsubscriptions.forEach((e3) => {
                    delete this._resubscribeTopics[e3];
                  }), "object" == typeof t3 && t3.properties && (i3.properties = t3.properties), this.outgoing[i3.messageId] = { volatile: true, cb: r2 }, this.log("unsubscribe: call _sendPacket"), this._sendPacket(i3), true;
                };
                return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !i2()) && this._storeProcessingQueue.push({ invoke: i2, callback: r2 }), this;
              }
              unsubscribeAsync(e2, t3) {
                return new Promise((r2, n2) => {
                  this.unsubscribe(e2, t3, (e3) => {
                    e3 ? n2(e3) : r2();
                  });
                });
              }
              end(e2, t3, r2) {
                this.log("end :: (%s)", this.options.clientId), null != e2 && "boolean" == typeof e2 || (r2 = r2 || t3, t3 = e2, e2 = false), "object" != typeof t3 && (r2 = r2 || t3, t3 = null), this.log("end :: cb? %s", !!r2), r2 && "function" == typeof r2 || (r2 = this.noop);
                const n2 = () => {
                  this.log("end :: closeStores: closing incoming and outgoing stores"), this.disconnected = true, this.incomingStore.close((e3) => {
                    this.outgoingStore.close((t4) => {
                      if (this.log("end :: closeStores: emitting end"), this.emit("end"), r2) {
                        const n3 = e3 || t4;
                        this.log("end :: closeStores: invoking callback with args"), r2(n3);
                      }
                    });
                  }), this._deferredReconnect && this._deferredReconnect();
                }, i2 = () => {
                  this.log("end :: (%s) :: finish :: calling _cleanUp with force %s", this.options.clientId, e2), this._cleanUp(e2, () => {
                    this.log("end :: finish :: calling process.nextTick on closeStores"), _(n2);
                  }, t3);
                };
                return this.disconnecting ? (r2(), this) : (this._clearReconnect(), this.disconnecting = true, !e2 && Object.keys(this.outgoing).length > 0 ? (this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty", this.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, i2, 10))) : (this.log("end :: (%s) :: immediately calling finish", this.options.clientId), i2()), this);
              }
              endAsync(e2, t3) {
                return new Promise((r2, n2) => {
                  this.end(e2, t3, (e3) => {
                    e3 ? n2(e3) : r2();
                  });
                });
              }
              removeOutgoingMessage(e2) {
                if (this.outgoing[e2]) {
                  const { cb: t3 } = this.outgoing[e2];
                  this._removeOutgoingAndStoreMessage(e2, () => {
                    t3(new Error("Message removed"));
                  });
                }
                return this;
              }
              reconnect(e2) {
                this.log("client reconnect");
                const t3 = () => {
                  e2 ? (this.options.incomingStore = e2.incomingStore, this.options.outgoingStore = e2.outgoingStore) : (this.options.incomingStore = null, this.options.outgoingStore = null), this.incomingStore = this.options.incomingStore || new g.default(), this.outgoingStore = this.options.outgoingStore || new g.default(), this.disconnecting = false, this.disconnected = false, this._deferredReconnect = null, this._reconnect();
                };
                return this.disconnecting && !this.disconnected ? this._deferredReconnect = t3 : t3(), this;
              }
              _flushVolatile() {
                this.outgoing && (this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(this.outgoing).forEach((e2) => {
                  this.outgoing[e2].volatile && "function" == typeof this.outgoing[e2].cb && (this.outgoing[e2].cb(new Error("Connection closed")), delete this.outgoing[e2]);
                }));
              }
              _flush() {
                this.outgoing && (this.log("_flush: queue exists? %b", !!this.outgoing), Object.keys(this.outgoing).forEach((e2) => {
                  "function" == typeof this.outgoing[e2].cb && (this.outgoing[e2].cb(new Error("Connection closed")), delete this.outgoing[e2]);
                }));
              }
              _removeTopicAliasAndRecoverTopicName(e2) {
                let t3;
                e2.properties && (t3 = e2.properties.topicAlias);
                let r2 = e2.topic.toString();
                if (this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o", t3, r2), 0 === r2.length) {
                  if (void 0 === t3)
                    return new Error("Unregistered Topic Alias");
                  if (r2 = this.topicAliasSend.getTopicByAlias(t3), void 0 === r2)
                    return new Error("Unregistered Topic Alias");
                  e2.topic = r2;
                }
                t3 && delete e2.properties.topicAlias;
              }
              _checkDisconnecting(e2) {
                return this.disconnecting && (e2 && e2 !== this.noop ? e2(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
              }
              _reconnect() {
                this.log("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
                  this.connect();
                }), this.log("client already connected. disconnecting first.")) : (this.log("_reconnect: calling connect"), this.connect());
              }
              _setupReconnect() {
                !this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0 ? (this.reconnecting || (this.log("_setupReconnect :: emit `offline` state"), this.emit("offline"), this.log("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = true), this.log("_setupReconnect :: setting reconnectTimer for %d ms", this.options.reconnectPeriod), this.reconnectTimer = setInterval(() => {
                  this.log("reconnectTimer :: reconnect triggered!"), this._reconnect();
                }, this.options.reconnectPeriod)) : this.log("_setupReconnect :: doing nothing...");
              }
              _clearReconnect() {
                this.log("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
              }
              _cleanUp(e2, t3, r2 = {}) {
                if (t3 && (this.log("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", t3)), this.log("_cleanUp :: forced? %s", e2), e2)
                  0 === this.options.reconnectPeriod && this.options.clean && this._flush(), this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();
                else {
                  const e3 = Object.assign({ cmd: "disconnect" }, r2);
                  this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(e3, () => {
                    this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), w(() => {
                      this.stream.end(() => {
                        this.log("_cleanUp :: (%s) :: stream destroyed", this.options.clientId);
                      });
                    });
                  });
                }
                this.disconnecting || (this.log("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), null !== this.pingTimer && (this.log("_cleanUp :: clearing pingTimer"), this.pingTimer.clear(), this.pingTimer = null), t3 && !this.connected && (this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", t3), t3());
              }
              _storeAndSend(e2, t3, r2) {
                this.log("storeAndSend :: store packet with cmd %s to outgoingStore", e2.cmd);
                let n2, i2 = e2;
                if ("publish" === i2.cmd && (i2 = (0, d.default)(e2), n2 = this._removeTopicAliasAndRecoverTopicName(i2), n2))
                  return t3 && t3(n2);
                this.outgoingStore.put(i2, (n3) => {
                  if (n3)
                    return t3 && t3(n3);
                  r2(), this._writePacket(e2, t3);
                });
              }
              _applyTopicAlias(e2) {
                if (5 === this.options.protocolVersion && "publish" === e2.cmd) {
                  let t3;
                  e2.properties && (t3 = e2.properties.topicAlias);
                  const r2 = e2.topic.toString();
                  if (this.topicAliasSend)
                    if (t3) {
                      if (0 !== r2.length && (this.log("applyTopicAlias :: register topic: %s - alias: %d", r2, t3), !this.topicAliasSend.put(r2, t3)))
                        return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", r2, t3), new Error("Sending Topic Alias out of range");
                    } else
                      0 !== r2.length && (this.options.autoAssignTopicAlias ? (t3 = this.topicAliasSend.getAliasByTopic(r2), t3 ? (e2.topic = "", e2.properties = Object.assign(Object.assign({}, e2.properties), { topicAlias: t3 }), this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", r2, t3)) : (t3 = this.topicAliasSend.getLruAlias(), this.topicAliasSend.put(r2, t3), e2.properties = Object.assign(Object.assign({}, e2.properties), { topicAlias: t3 }), this.log("applyTopicAlias :: auto assign topic: %s - alias: %d", r2, t3))) : this.options.autoUseTopicAlias && (t3 = this.topicAliasSend.getAliasByTopic(r2), t3 && (e2.topic = "", e2.properties = Object.assign(Object.assign({}, e2.properties), { topicAlias: t3 }), this.log("applyTopicAlias :: auto use topic: %s - alias: %d", r2, t3))));
                  else if (t3)
                    return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", r2, t3), new Error("Sending Topic Alias out of range");
                }
              }
              _noop(e2) {
                this.log("noop ::", e2);
              }
              _writePacket(e2, t3) {
                this.log("_writePacket :: packet: %O", e2), this.log("_writePacket :: emitting `packetsend`"), this.emit("packetsend", e2), this._shiftPingInterval(), this.log("_writePacket :: writing to stream");
                const r2 = u.default.writeToStream(e2, this.stream, this.options);
                this.log("_writePacket :: writeToStream result %s", r2), !r2 && t3 && t3 !== this.noop ? (this.log("_writePacket :: handle events on `drain` once through callback."), this.stream.once("drain", t3)) : t3 && (this.log("_writePacket :: invoking cb"), t3());
              }
              _sendPacket(e2, t3, r2, n2) {
                this.log("_sendPacket :: (%s) ::  start", this.options.clientId), r2 = r2 || this.noop, t3 = t3 || this.noop;
                const i2 = this._applyTopicAlias(e2);
                if (i2)
                  t3(i2);
                else {
                  if (!this.connected)
                    return "auth" === e2.cmd ? void this._writePacket(e2, t3) : (this.log("_sendPacket :: client not connected. Storing packet offline."), void this._storePacket(e2, t3, r2));
                  if (n2)
                    this._writePacket(e2, t3);
                  else {
                    switch (e2.cmd) {
                      case "publish":
                        break;
                      case "pubrel":
                        return void this._storeAndSend(e2, t3, r2);
                      default:
                        return void this._writePacket(e2, t3);
                    }
                    switch (e2.qos) {
                      case 2:
                      case 1:
                        this._storeAndSend(e2, t3, r2);
                        break;
                      default:
                        this._writePacket(e2, t3);
                    }
                    this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
                  }
                }
              }
              _storePacket(e2, t3, r2) {
                this.log("_storePacket :: packet: %o", e2), this.log("_storePacket :: cb? %s", !!t3), r2 = r2 || this.noop;
                let n2 = e2;
                if ("publish" === n2.cmd) {
                  n2 = (0, d.default)(e2);
                  const r3 = this._removeTopicAliasAndRecoverTopicName(n2);
                  if (r3)
                    return t3 && t3(r3);
                }
                const i2 = n2.qos || 0;
                0 === i2 && this.queueQoSZero || "publish" !== n2.cmd ? this.queue.push({ packet: n2, cb: t3 }) : i2 > 0 ? (t3 = this.outgoing[n2.messageId] ? this.outgoing[n2.messageId].cb : null, this.outgoingStore.put(n2, (e3) => {
                  if (e3)
                    return t3 && t3(e3);
                  r2();
                })) : t3 && t3(new Error("No connection to broker"));
              }
              _setupPingTimer() {
                this.log("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive), !this.pingTimer && this.options.keepalive && (this.pingResp = true, this.pingTimer = (0, f.default)(() => {
                  this._checkPing();
                }, 1e3 * this.options.keepalive));
              }
              _shiftPingInterval() {
                this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive);
              }
              _checkPing() {
                this.log("_checkPing :: checking ping..."), this.pingResp ? (this.log("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = false, this._sendPacket({ cmd: "pingreq" })) : (this.log("_checkPing :: calling _cleanUp with force true"), this._cleanUp(true));
              }
              _resubscribe() {
                this.log("_resubscribe");
                const e2 = Object.keys(this._resubscribeTopics);
                if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && e2.length > 0)
                  if (this.options.resubscribe)
                    if (5 === this.options.protocolVersion) {
                      this.log("_resubscribe: protocolVersion 5");
                      for (let t3 = 0; t3 < e2.length; t3++) {
                        const r2 = {};
                        r2[e2[t3]] = this._resubscribeTopics[e2[t3]], r2.resubscribe = true, this.subscribe(r2, { properties: r2[e2[t3]].properties });
                      }
                    } else
                      this._resubscribeTopics.resubscribe = true, this.subscribe(this._resubscribeTopics);
                  else
                    this._resubscribeTopics = {};
                this._firstConnection = false;
              }
              _onConnect(e2) {
                if (this.disconnected)
                  return void this.emit("connect", e2);
                this.connackPacket = e2, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = true;
                const t3 = () => {
                  let r2 = this.outgoingStore.createStream();
                  const n2 = () => {
                    r2.destroy(), r2 = null, this._flushStoreProcessingQueue(), i2();
                  }, i2 = () => {
                    this._storeProcessing = false, this._packetIdsDuringStoreProcessing = {};
                  };
                  this.once("close", n2), r2.on("error", (e3) => {
                    i2(), this._flushStoreProcessingQueue(), this.removeListener("close", n2), this.emit("error", e3);
                  });
                  const s2 = () => {
                    if (!r2)
                      return;
                    const e3 = r2.read(1);
                    let t4;
                    e3 ? (this._storeProcessing = true, this._packetIdsDuringStoreProcessing[e3.messageId] ? s2() : this.disconnecting || this.reconnectTimer ? r2.destroy && r2.destroy() : (t4 = this.outgoing[e3.messageId] ? this.outgoing[e3.messageId].cb : null, this.outgoing[e3.messageId] = { volatile: false, cb(e4, r3) {
                      t4 && t4(e4, r3), s2();
                    } }, this._packetIdsDuringStoreProcessing[e3.messageId] = true, this.messageIdProvider.register(e3.messageId) ? this._sendPacket(e3, void 0, void 0, true) : this.log("messageId: %d has already used.", e3.messageId))) : r2.once("readable", s2);
                  };
                  r2.on("end", () => {
                    let r3 = true;
                    for (const e3 in this._packetIdsDuringStoreProcessing)
                      if (!this._packetIdsDuringStoreProcessing[e3]) {
                        r3 = false;
                        break;
                      }
                    r3 ? (i2(), this.removeListener("close", n2), this._invokeAllStoreProcessingQueue(), this.emit("connect", e2)) : t3();
                  }), s2();
                };
                t3();
              }
              _invokeStoreProcessingQueue() {
                if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
                  const e2 = this._storeProcessingQueue[0];
                  if (e2 && e2.invoke())
                    return this._storeProcessingQueue.shift(), true;
                }
                return false;
              }
              _invokeAllStoreProcessingQueue() {
                for (; this._invokeStoreProcessingQueue(); )
                  ;
              }
              _flushStoreProcessingQueue() {
                for (const e2 of this._storeProcessingQueue)
                  e2.cbStorePut && e2.cbStorePut(new Error("Connection closed")), e2.callback && e2.callback(new Error("Connection closed"));
                this._storeProcessingQueue.splice(0);
              }
              _removeOutgoingAndStoreMessage(e2, t3) {
                delete this.outgoing[e2], this.outgoingStore.del({ messageId: e2 }, (r2, n2) => {
                  t3(r2, n2), this.messageIdProvider.deallocate(e2), this._invokeStoreProcessingQueue();
                });
              }
            }
            r.default = E;
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "./TypedEmitter": 1, "./default-message-id-provider": 9, "./handlers": 13, "./store": 18, "./topic-alias-recv": 19, "./validations": 22, _process: 102, debug: 30, "mqtt-packet": 75, "readable-stream": 125, reinterval: 131, "rfdc/default": 132 }], 3: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = e("buffer"), s = e("readable-stream"), o = n(e("duplexify"));
        let a, l, u, c = false;
        r.default = (e2, t2) => {
          if (t2.hostname = t2.hostname || t2.host, !t2.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          const r2 = "MQIsdp" === t2.protocolId && 3 === t2.protocolVersion ? "mqttv3.1" : "mqtt";
          !function(e3) {
            e3.hostname || (e3.hostname = "localhost"), e3.path || (e3.path = "/"), e3.wsOptions || (e3.wsOptions = {});
          }(t2);
          const n2 = function(e3, t3) {
            const r3 = "alis" === e3.protocol ? "wss" : "ws";
            let n3 = `${r3}://${e3.hostname}${e3.path}`;
            return e3.port && 80 !== e3.port && 443 !== e3.port && (n3 = `${r3}://${e3.hostname}:${e3.port}${e3.path}`), "function" == typeof e3.transformWsUrl && (n3 = e3.transformWsUrl(n3, e3, t3)), n3;
          }(t2, e2);
          return a = t2.my, a.connectSocket({ url: n2, protocols: r2 }), l = function() {
            const e3 = new s.Transform();
            return e3._write = (e4, t3, r3) => {
              a.sendSocketMessage({ data: e4.buffer, success() {
                r3();
              }, fail() {
                r3(new Error());
              } });
            }, e3._flush = (e4) => {
              a.closeSocket({ success() {
                e4();
              } });
            }, e3;
          }(), u = o.default.obj(), c || (c = true, a.onSocketOpen(() => {
            u.setReadable(l), u.setWritable(l), u.emit("connect");
          }), a.onSocketMessage((e3) => {
            if ("string" == typeof e3.data) {
              const t3 = i.Buffer.from(e3.data, "base64");
              l.push(t3);
            } else {
              const t3 = new FileReader();
              t3.addEventListener("load", () => {
                let e4 = t3.result;
                e4 = e4 instanceof ArrayBuffer ? i.Buffer.from(e4) : i.Buffer.from(e4, "utf8"), l.push(e4);
              }), t3.readAsArrayBuffer(e3.data);
            }
          }), a.onSocketClose(() => {
            u.end(), u.destroy();
          }), a.onSocketError((e3) => {
            u.destroy(e3);
          })), u;
        };
      }, { buffer: 29, duplexify: 32, "readable-stream": 125 }], 4: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.connectAsync = void 0;
        const i = n(e("debug")), s = n(e("url")), o = n(e("../client")), a = n(e("../is-browser")), l = (0, i.default)("mqttjs"), u = {};
        function c(e2, t2) {
          if (l("connecting to an MQTT broker..."), "object" != typeof e2 || t2 || (t2 = e2, e2 = ""), t2 = t2 || {}, e2 && "string" == typeof e2) {
            const r3 = s.default.parse(e2, true);
            if (null != r3.port && (r3.port = Number(r3.port)), null === (t2 = Object.assign(Object.assign({}, r3), t2)).protocol)
              throw new Error("Missing protocol");
            t2.protocol = t2.protocol.replace(/:$/, "");
          }
          if (function(e3) {
            let t3;
            e3.auth && (t3 = e3.auth.match(/^(.+):(.+)$/), t3 ? (e3.username = t3[1], e3.password = t3[2]) : e3.username = e3.auth);
          }(t2), t2.query && "string" == typeof t2.query.clientId && (t2.clientId = t2.query.clientId), t2.cert && t2.key) {
            if (!t2.protocol)
              throw new Error("Missing secure protocol key");
            if (-1 === ["mqtts", "wss", "wxs", "alis"].indexOf(t2.protocol))
              switch (t2.protocol) {
                case "mqtt":
                  t2.protocol = "mqtts";
                  break;
                case "ws":
                  t2.protocol = "wss";
                  break;
                case "wx":
                  t2.protocol = "wxs";
                  break;
                case "ali":
                  t2.protocol = "alis";
                  break;
                default:
                  throw new Error(`Unknown protocol for secure connection: "${t2.protocol}"!`);
              }
          }
          if (!u[t2.protocol]) {
            const e3 = -1 !== ["mqtts", "wss"].indexOf(t2.protocol);
            t2.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter((t3, r3) => (!e3 || r3 % 2 != 0) && "function" == typeof u[t3])[0];
          }
          if (false === t2.clean && !t2.clientId)
            throw new Error("Missing clientId for unclean clients");
          t2.protocol && (t2.defaultProtocol = t2.protocol);
          const r2 = new o.default(function(e3) {
            return t2.servers && (e3._reconnectCount && e3._reconnectCount !== t2.servers.length || (e3._reconnectCount = 0), t2.host = t2.servers[e3._reconnectCount].host, t2.port = t2.servers[e3._reconnectCount].port, t2.protocol = t2.servers[e3._reconnectCount].protocol ? t2.servers[e3._reconnectCount].protocol : t2.defaultProtocol, t2.hostname = t2.host, e3._reconnectCount++), l("calling streambuilder for", t2.protocol), u[t2.protocol](e3, t2);
          }, t2);
          return r2.on("error", () => {
          }), r2;
        }
        a.default ? (u.wx = e("./wx").default, u.wxs = e("./wx").default, u.ali = e("./ali").default, u.alis = e("./ali").default) : (u.mqtt = e("./tcp").default, u.tcp = e("./tcp").default, u.ssl = e("./tls").default, u.tls = u.ssl, u.mqtts = e("./tls").default), u.ws = e("./ws").default, u.wss = e("./ws").default, r.connectAsync = function(e2, t2, r2 = true) {
          return new Promise((n2, i2) => {
            const s2 = c(e2, t2), o2 = { connect: (e3) => {
              a2(), n2(s2);
            }, end: () => {
              a2(), n2(s2);
            }, error: (e3) => {
              a2(), s2.end(), i2(e3);
            } };
            function a2() {
              Object.keys(o2).forEach((e3) => {
                s2.off(e3, o2[e3]);
              });
            }
            false === r2 && (o2.close = () => {
              o2.error(new Error("Couldn't connect to server"));
            }), Object.keys(o2).forEach((e3) => {
              s2.on(e3, o2[e3]);
            });
          });
        }, r.default = c;
      }, { "../client": 2, "../is-browser": 16, "./ali": 3, "./tcp": 5, "./tls": 6, "./ws": 7, "./wx": 8, debug: 30, url: 137 }], 5: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = n(e("net")), s = (0, n(e("debug")).default)("mqttjs:tcp");
        r.default = (e2, t2) => {
          t2.port = t2.port || 1883, t2.hostname = t2.hostname || t2.host || "localhost";
          const { port: r2 } = t2, n2 = t2.hostname;
          return s("port %d and host %s", r2, n2), i.default.createConnection(r2, n2);
        };
      }, { debug: 30, net: 26 }], 6: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = n(e("tls")), s = n(e("net")), o = (0, n(e("debug")).default)("mqttjs:tls");
        r.default = (e2, t2) => {
          t2.port = t2.port || 8883, t2.host = t2.hostname || t2.host || "localhost", 0 === s.default.isIP(t2.host) && (t2.servername = t2.host), t2.rejectUnauthorized = false !== t2.rejectUnauthorized, delete t2.path, o("port %d host %s rejectUnauthorized %b", t2.port, t2.host, t2.rejectUnauthorized);
          const r2 = i.default.connect(t2);
          function n2(n3) {
            t2.rejectUnauthorized && e2.emit("error", n3), r2.end();
          }
          return r2.on("secureConnect", () => {
            t2.rejectUnauthorized && !r2.authorized ? r2.emit("error", new Error("TLS not authorized")) : r2.removeListener("error", n2);
          }), r2.on("error", n2), r2;
        };
      }, { debug: 30, net: 26, tls: 26 }], 7: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = e("buffer"), s = n(e("ws")), o = n(e("debug")), a = n(e("duplexify")), l = e("readable-stream"), u = n(e("../is-browser")), c = (0, o.default)("mqttjs:ws"), h = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"];
        function f(e2, t2) {
          let r2 = `${e2.protocol}://${e2.hostname}:${e2.port}${e2.path}`;
          return "function" == typeof e2.transformWsUrl && (r2 = e2.transformWsUrl(r2, e2, t2)), r2;
        }
        function d(e2) {
          const t2 = e2;
          return e2.hostname || (t2.hostname = "localhost"), e2.port || ("wss" === e2.protocol ? t2.port = 443 : t2.port = 80), e2.path || (t2.path = "/"), e2.wsOptions || (t2.wsOptions = {}), u.default || "wss" !== e2.protocol || h.forEach((r2) => {
            Object.prototype.hasOwnProperty.call(e2, r2) && !Object.prototype.hasOwnProperty.call(e2.wsOptions, r2) && (t2.wsOptions[r2] = e2[r2]);
          }), t2;
        }
        r.default = u.default ? (e2, t2) => {
          let r2;
          c("browserStreamBuilder");
          const n2 = function(e3) {
            const t3 = d(e3);
            if (t3.hostname || (t3.hostname = t3.host), !t3.hostname) {
              if ("undefined" == typeof document)
                throw new Error("Could not determine host. Specify host manually.");
              const e4 = new URL(document.URL);
              t3.hostname = e4.hostname, t3.port || (t3.port = Number(e4.port));
            }
            return void 0 === t3.objectMode && (t3.objectMode = !(true === t3.binary || void 0 === t3.binary)), t3;
          }(t2), s2 = n2.browserBufferSize || 524288, o2 = t2.browserBufferTimeout || 1e3, u2 = !t2.objectMode, h2 = function(e3, t3) {
            const r3 = "MQIsdp" === t3.protocolId && 3 === t3.protocolVersion ? "mqttv3.1" : "mqtt", n3 = f(t3, e3), i2 = new WebSocket(n3, [r3]);
            return i2.binaryType = "arraybuffer", i2;
          }(e2, t2), p = function(e3, t3, r3) {
            const n3 = new l.Transform({ objectMode: e3.objectMode });
            return n3._write = t3, n3._flush = r3, n3;
          }(t2, function e3(t3, r3, n3) {
            h2.bufferedAmount > s2 && setTimeout(e3, o2, t3, r3, n3);
            u2 && "string" == typeof t3 && (t3 = i.Buffer.from(t3, "utf8"));
            try {
              h2.send(t3);
            } catch (e4) {
              return n3(e4);
            }
            n3();
          }, function(e3) {
            h2.close(), e3();
          });
          t2.objectMode || (p._writev = w), p.on("close", () => {
            h2.close();
          });
          const b = void 0 !== h2.addEventListener;
          function g() {
            r2.setReadable(p), r2.setWritable(p), r2.emit("connect");
          }
          function m() {
            r2.end(), r2.destroy();
          }
          function y(e3) {
            r2.destroy(e3);
          }
          function _(e3) {
            let { data: t3 } = e3;
            t3 = t3 instanceof ArrayBuffer ? i.Buffer.from(t3) : i.Buffer.from(t3, "utf8"), p.push(t3);
          }
          function w(e3, t3) {
            const r3 = new Array(e3.length);
            for (let t4 = 0; t4 < e3.length; t4++)
              "string" == typeof e3[t4].chunk ? r3[t4] = i.Buffer.from(e3[t4], "utf8") : r3[t4] = e3[t4].chunk;
            this._write(i.Buffer.concat(r3), "binary", t3);
          }
          return h2.readyState === h2.OPEN ? r2 = p : (r2 = (0, a.default)(void 0, void 0, t2), t2.objectMode || (r2._writev = w), b ? h2.addEventListener("open", g) : h2.onopen = g), r2.socket = h2, b ? (h2.addEventListener("close", m), h2.addEventListener("error", y), h2.addEventListener("message", _)) : (h2.onclose = m, h2.onerror = y, h2.onmessage = _), r2;
        } : (e2, t2) => {
          c("streamBuilder");
          const r2 = d(t2), n2 = f(r2, e2), i2 = function(e3, t3, r3) {
            c("createWebSocket"), c(`protocol: ${r3.protocolId} ${r3.protocolVersion}`);
            const n3 = "MQIsdp" === r3.protocolId && 3 === r3.protocolVersion ? "mqttv3.1" : "mqtt";
            return c(`creating new Websocket for url: ${t3} and protocol: ${n3}`), new s.default(t3, [n3], r3.wsOptions);
          }(0, n2, r2), o2 = s.default.createWebSocketStream(i2, r2.wsOptions);
          return o2.url = n2, i2.on("close", () => {
            o2.destroy();
          }), o2;
        };
      }, { "../is-browser": 16, buffer: 29, debug: 30, duplexify: 32, "readable-stream": 125, ws: 141 }], 8: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = e("buffer"), s = e("readable-stream"), o = n(e("duplexify"));
        let a, l, u;
        r.default = (e2, t2) => {
          if (t2.hostname = t2.hostname || t2.host, !t2.hostname)
            throw new Error("Could not determine host. Specify host manually.");
          const r2 = "MQIsdp" === t2.protocolId && 3 === t2.protocolVersion ? "mqttv3.1" : "mqtt";
          !function(e3) {
            e3.hostname || (e3.hostname = "localhost"), e3.path || (e3.path = "/"), e3.wsOptions || (e3.wsOptions = {});
          }(t2);
          const n2 = function(e3, t3) {
            const r3 = "wxs" === e3.protocol ? "wss" : "ws";
            let n3 = `${r3}://${e3.hostname}${e3.path}`;
            return e3.port && 80 !== e3.port && 443 !== e3.port && (n3 = `${r3}://${e3.hostname}:${e3.port}${e3.path}`), "function" == typeof e3.transformWsUrl && (n3 = e3.transformWsUrl(n3, e3, t3)), n3;
          }(t2, e2);
          a = wx.connectSocket({ url: n2, protocols: [r2] }), l = function() {
            const e3 = new s.Transform();
            return e3._write = (e4, t3, r3) => {
              a.send({ data: e4.buffer, success() {
                r3();
              }, fail(e5) {
                r3(new Error(e5));
              } });
            }, e3._flush = (e4) => {
              a.close({ success() {
                e4();
              } });
            }, e3;
          }(), u = o.default.obj(), u._destroy = (e3, t3) => {
            a.close({ success() {
              t3 && t3(e3);
            } });
          };
          const c = u.destroy;
          return u.destroy = () => {
            u.destroy = c, setTimeout(() => {
              a.close({ fail() {
                u._destroy(new Error());
              } });
            }, 0);
          }, a.onOpen(() => {
            u.setReadable(l), u.setWritable(l), u.emit("connect");
          }), a.onMessage((e3) => {
            let { data: t3 } = e3;
            t3 = t3 instanceof ArrayBuffer ? i.Buffer.from(t3) : i.Buffer.from(t3, "utf8"), l.push(t3);
          }), a.onClose(() => {
            u.emit("close"), u.end(), u.destroy();
          }), a.onError((e3) => {
            u.destroy(new Error(e3.errMsg));
          }), u;
        };
      }, { buffer: 29, duplexify: 32, "readable-stream": 125 }], 9: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        r.default = class {
          constructor() {
            this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
          }
          allocate() {
            const e2 = this.nextId++;
            return 65536 === this.nextId && (this.nextId = 1), e2;
          }
          getLastAllocated() {
            return 1 === this.nextId ? 65535 : this.nextId - 1;
          }
          register(e2) {
            return true;
          }
          deallocate(e2) {
          }
          clear() {
          }
        };
      }, {}], 10: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.ReasonCodes = void 0, r.ReasonCodes = { 0: "", 1: "Unacceptable protocol version", 2: "Identifier rejected", 3: "Server unavailable", 4: "Bad username or password", 5: "Not authorized", 16: "No matching subscribers", 17: "No subscription existed", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 132: "Unsupported Protocol Version", 133: "Client Identifier not valid", 134: "Bad User Name or Password", 135: "Not authorized", 136: "Server unavailable", 137: "Server busy", 138: "Banned", 139: "Server shutting down", 140: "Bad authentication method", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 145: "Packet identifier in use", 146: "Packet Identifier not found", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
        r.default = (e2, t2) => {
          const { messageId: n } = t2, i = t2.cmd;
          let s = null;
          const o = e2.outgoing[n] ? e2.outgoing[n].cb : null;
          let a;
          if (o) {
            switch (e2.log("_handleAck :: packet type", i), i) {
              case "pubcomp":
              case "puback": {
                const i2 = t2.reasonCode;
                i2 && i2 > 0 && 16 !== i2 ? (a = new Error(`Publish error: ${r.ReasonCodes[i2]}`), a.code = i2, e2._removeOutgoingAndStoreMessage(n, () => {
                  o(a, t2);
                })) : e2._removeOutgoingAndStoreMessage(n, o);
                break;
              }
              case "pubrec": {
                s = { cmd: "pubrel", qos: 2, messageId: n };
                const i2 = t2.reasonCode;
                i2 && i2 > 0 && 16 !== i2 ? (a = new Error(`Publish error: ${r.ReasonCodes[i2]}`), a.code = i2, e2._removeOutgoingAndStoreMessage(n, () => {
                  o(a, t2);
                })) : e2._sendPacket(s);
                break;
              }
              case "suback": {
                delete e2.outgoing[n], e2.messageIdProvider.deallocate(n);
                const r2 = t2.granted;
                for (let t3 = 0; t3 < r2.length; t3++)
                  if (0 != (128 & r2[t3])) {
                    const t4 = e2.messageIdToTopic[n];
                    t4 && t4.forEach((t5) => {
                      delete e2._resubscribeTopics[t5];
                    });
                  }
                delete e2.messageIdToTopic[n], e2._invokeStoreProcessingQueue(), o(null, t2);
                break;
              }
              case "unsuback":
                delete e2.outgoing[n], e2.messageIdProvider.deallocate(n), e2._invokeStoreProcessingQueue(), o(null);
                break;
              default:
                e2.emit("error", new Error("unrecognized packet type"));
            }
            e2.disconnecting && 0 === Object.keys(e2.outgoing).length && e2.emit("outgoingEmpty");
          } else
            e2.log("_handleAck :: Server sent an ack in error. Ignoring.");
        };
      }, {}], 11: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const n = e("../shared"), i = e("./ack");
        r.default = (e2, t2) => {
          const { options: r2 } = e2, s = r2.protocolVersion, o = 5 === s ? t2.reasonCode : t2.returnCode;
          if (5 === s)
            e2.handleAuth(t2, (t3, r3) => {
              if (t3)
                e2.emit("error", t3);
              else if (24 === o)
                e2.reconnecting = false, e2._sendPacket(r3);
              else {
                const t4 = new n.ErrorWithReasonCode(`Connection refused: ${i.ReasonCodes[o]}`, o);
                e2.emit("error", t4);
              }
            });
          else {
            const t3 = new n.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${s}`, o);
            e2.emit("error", t3);
          }
        };
      }, { "../shared": 17, "./ack": 10 }], 12: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = e("./ack"), s = n(e("../topic-alias-send")), o = e("../shared");
        r.default = (e2, t2) => {
          e2.log("_handleConnack");
          const { options: r2 } = e2, n2 = 5 === r2.protocolVersion ? t2.reasonCode : t2.returnCode;
          if (clearTimeout(e2.connackTimer), delete e2.topicAliasSend, t2.properties) {
            if (t2.properties.topicAliasMaximum) {
              if (t2.properties.topicAliasMaximum > 65535)
                return void e2.emit("error", new Error("topicAliasMaximum from broker is out of range"));
              t2.properties.topicAliasMaximum > 0 && (e2.topicAliasSend = new s.default(t2.properties.topicAliasMaximum));
            }
            t2.properties.serverKeepAlive && r2.keepalive && (r2.keepalive = t2.properties.serverKeepAlive, e2._shiftPingInterval()), t2.properties.maximumPacketSize && (r2.properties || (r2.properties = {}), r2.properties.maximumPacketSize = t2.properties.maximumPacketSize);
          }
          if (0 === n2)
            e2.reconnecting = false, e2._onConnect(t2);
          else if (n2 > 0) {
            const t3 = new o.ErrorWithReasonCode(`Connection refused: ${i.ReasonCodes[n2]}`, n2);
            e2.emit("error", t3);
          }
        };
      }, { "../shared": 17, "../topic-alias-send": 20, "./ack": 10 }], 13: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = n(e("./publish")), s = n(e("./auth")), o = n(e("./connack")), a = n(e("./ack")), l = n(e("./pubrel"));
        r.default = (e2, t2, r2) => {
          const { options: n2 } = e2;
          if (5 === n2.protocolVersion && n2.properties && n2.properties.maximumPacketSize && n2.properties.maximumPacketSize < t2.length)
            return e2.emit("error", new Error(`exceeding packets size ${t2.cmd}`)), e2.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } }), e2;
          switch (e2.log("_handlePacket :: emitting packetreceive"), e2.emit("packetreceive", t2), t2.cmd) {
            case "publish":
              (0, i.default)(e2, t2, r2);
              break;
            case "puback":
            case "pubrec":
            case "pubcomp":
            case "suback":
            case "unsuback":
              (0, a.default)(e2, t2), r2();
              break;
            case "pubrel":
              (0, l.default)(e2, t2, r2);
              break;
            case "connack":
              (0, o.default)(e2, t2), r2();
              break;
            case "auth":
              (0, s.default)(e2, t2), r2();
              break;
            case "pingresp":
              e2.pingResp = true, r2();
              break;
            case "disconnect":
              e2.emit("disconnect", t2), r2();
              break;
            default:
              e2.log("_handlePacket :: unknown command"), r2();
          }
        };
      }, { "./ack": 10, "./auth": 11, "./connack": 12, "./publish": 14, "./pubrel": 15 }], 14: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const n = [0, 16, 128, 131, 135, 144, 145, 151, 153];
        r.default = (e2, t2, r2) => {
          e2.log("handlePublish: packet %o", t2), r2 = void 0 !== r2 ? r2 : e2.noop;
          let i = t2.topic.toString();
          const s = t2.payload, { qos: o } = t2, { messageId: a } = t2, { options: l } = e2;
          if (5 === e2.options.protocolVersion) {
            let r3;
            if (t2.properties && (r3 = t2.properties.topicAlias), void 0 !== r3)
              if (0 === i.length) {
                if (!(r3 > 0 && r3 <= 65535))
                  return e2.log("handlePublish :: topic alias out of range. alias: %d", r3), void e2.emit("error", new Error("Received Topic Alias is out of range"));
                {
                  const t3 = e2.topicAliasRecv.getTopicByAlias(r3);
                  if (!t3)
                    return e2.log("handlePublish :: unregistered topic alias. alias: %d", r3), void e2.emit("error", new Error("Received unregistered Topic Alias"));
                  i = t3, e2.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", i, r3);
                }
              } else {
                if (!e2.topicAliasRecv.put(i, r3))
                  return e2.log("handlePublish :: topic alias out of range. alias: %d", r3), void e2.emit("error", new Error("Received Topic Alias is out of range"));
                e2.log("handlePublish :: registered topic: %s - alias: %d", i, r3);
              }
          }
          switch (e2.log("handlePublish: qos %d", o), o) {
            case 2:
              l.customHandleAcks(i, s, t2, (i2, s2) => ("number" == typeof i2 && (s2 = i2, i2 = null), i2 ? e2.emit("error", i2) : -1 === n.indexOf(s2) ? e2.emit("error", new Error("Wrong reason code for pubrec")) : void (s2 ? e2._sendPacket({ cmd: "pubrec", messageId: a, reasonCode: s2 }, r2) : e2.incomingStore.put(t2, () => {
                e2._sendPacket({ cmd: "pubrec", messageId: a }, r2);
              }))));
              break;
            case 1:
              l.customHandleAcks(i, s, t2, (o2, l2) => ("number" == typeof o2 && (l2 = o2, o2 = null), o2 ? e2.emit("error", o2) : -1 === n.indexOf(l2) ? e2.emit("error", new Error("Wrong reason code for puback")) : (l2 || e2.emit("message", i, s, t2), void e2.handleMessage(t2, (t3) => {
                if (t3)
                  return r2 && r2(t3);
                e2._sendPacket({ cmd: "puback", messageId: a, reasonCode: l2 }, r2);
              }))));
              break;
            case 0:
              e2.emit("message", i, s, t2), e2.handleMessage(t2, r2);
              break;
            default:
              e2.log("handlePublish: unknown QoS. Doing nothing.");
          }
        };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        r.default = (e2, t2, r2) => {
          e2.log("handling pubrel packet");
          const n = void 0 !== r2 ? r2 : e2.noop, { messageId: i } = t2, s = { cmd: "pubcomp", messageId: i };
          e2.incomingStore.get(t2, (t3, r3) => {
            t3 ? e2._sendPacket(s, n) : (e2.emit("message", r3.topic, r3.payload, r3), e2.handleMessage(r3, (t4) => {
              if (t4)
                return n(t4);
              e2.incomingStore.del(r3, e2.noop), e2._sendPacket(s, n);
            }));
          });
        };
      }, {}], 16: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const n = "undefined" != typeof window && void 0 !== window.document;
        r.default = n;
      }, {}], 17: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true }), r.applyMixin = r.ErrorWithReasonCode = void 0;
        class n extends Error {
          constructor(e2, t2) {
            super(e2), this.code = t2, Object.setPrototypeOf(this, n.prototype), Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
          }
        }
        r.ErrorWithReasonCode = n, r.applyMixin = function(e2, t2, r2 = false) {
          var n2;
          const i = [t2];
          for (; ; ) {
            const e3 = i[0], t3 = Object.getPrototypeOf(e3);
            if (!(null == t3 ? void 0 : t3.prototype))
              break;
            i.unshift(t3);
          }
          for (const t3 of i)
            for (const i2 of Object.getOwnPropertyNames(t3.prototype))
              (r2 || "constructor" !== i2) && Object.defineProperty(e2.prototype, i2, null !== (n2 = Object.getOwnPropertyDescriptor(t3.prototype, i2)) && void 0 !== n2 ? n2 : /* @__PURE__ */ Object.create(null));
        };
      }, {}], 18: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const n = e("readable-stream"), i = { objectMode: true }, s = { clean: true };
        r.default = class {
          constructor(e2) {
            this.options = e2 || {}, this.options = Object.assign(Object.assign({}, s), e2), this._inflights = /* @__PURE__ */ new Map();
          }
          put(e2, t2) {
            return this._inflights.set(e2.messageId, e2), t2 && t2(), this;
          }
          createStream() {
            const e2 = new n.Readable(i), t2 = [];
            let r2 = false, s2 = 0;
            return this._inflights.forEach((e3, r3) => {
              t2.push(e3);
            }), e2._read = () => {
              !r2 && s2 < t2.length ? e2.push(t2[s2++]) : e2.push(null);
            }, e2.destroy = (t3) => {
              if (!r2)
                return r2 = true, setTimeout(() => {
                  e2.emit("close");
                }, 0), e2;
            }, e2;
          }
          del(e2, t2) {
            const r2 = this._inflights.get(e2.messageId);
            return r2 ? (this._inflights.delete(e2.messageId), t2(null, r2)) : t2 && t2(new Error("missing packet")), this;
          }
          get(e2, t2) {
            const r2 = this._inflights.get(e2.messageId);
            return r2 ? t2(null, r2) : t2 && t2(new Error("missing packet")), this;
          }
          close(e2) {
            this.options.clean && (this._inflights = null), e2 && e2();
          }
        };
      }, { "readable-stream": 125 }], 19: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        r.default = class {
          constructor(e2) {
            this.aliasToTopic = {}, this.max = e2;
          }
          put(e2, t2) {
            return !(0 === t2 || t2 > this.max) && (this.aliasToTopic[t2] = e2, this.length = Object.keys(this.aliasToTopic).length, true);
          }
          getTopicByAlias(e2) {
            return this.aliasToTopic[e2];
          }
          clear() {
            this.aliasToTopic = {};
          }
        };
      }, {}], 20: [function(e, t, r) {
        "use strict";
        var n = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true });
        const i = n(e("lru-cache")), s = e("number-allocator");
        r.default = class {
          constructor(e2) {
            e2 > 0 && (this.aliasToTopic = new i.default({ max: e2 }), this.topicToAlias = {}, this.numberAllocator = new s.NumberAllocator(1, e2), this.max = e2, this.length = 0);
          }
          put(e2, t2) {
            if (0 === t2 || t2 > this.max)
              return false;
            const r2 = this.aliasToTopic.get(t2);
            return r2 && delete this.topicToAlias[r2], this.aliasToTopic.set(t2, e2), this.topicToAlias[e2] = t2, this.numberAllocator.use(t2), this.length = this.aliasToTopic.size, true;
          }
          getTopicByAlias(e2) {
            return this.aliasToTopic.get(e2);
          }
          getAliasByTopic(e2) {
            const t2 = this.topicToAlias[e2];
            return void 0 !== t2 && this.aliasToTopic.get(t2), t2;
          }
          clear() {
            this.aliasToTopic.clear(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
          }
          getLruAlias() {
            const e2 = this.numberAllocator.firstVacant();
            return e2 || [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
          }
        };
      }, { "lru-cache": 72, "number-allocator": 98 }], 21: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", { value: true });
        const n = e("number-allocator");
        r.default = class {
          constructor() {
            this.numberAllocator = new n.NumberAllocator(1, 65535);
          }
          allocate() {
            return this.lastId = this.numberAllocator.alloc(), this.lastId;
          }
          getLastAllocated() {
            return this.lastId;
          }
          register(e2) {
            return this.numberAllocator.use(e2);
          }
          deallocate(e2) {
            this.numberAllocator.free(e2);
          }
          clear() {
            this.numberAllocator.clear();
          }
        };
      }, { "number-allocator": 98 }], 22: [function(e, t, r) {
        "use strict";
        function n(e2) {
          const t2 = e2.split("/");
          for (let e3 = 0; e3 < t2.length; e3++)
            if ("+" !== t2[e3]) {
              if ("#" === t2[e3])
                return e3 === t2.length - 1;
              if (-1 !== t2[e3].indexOf("+") || -1 !== t2[e3].indexOf("#"))
                return false;
            }
          return true;
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.validateTopics = r.validateTopic = void 0, r.validateTopic = n, r.validateTopics = function(e2) {
          if (0 === e2.length)
            return "empty_topic_list";
          for (let t2 = 0; t2 < e2.length; t2++)
            if (!n(e2[t2]))
              return e2[t2];
          return null;
        };
      }, {}], 23: [function(e, t, r) {
        "use strict";
        var n = this && this.__createBinding || (Object.create ? function(e2, t2, r2, n2) {
          void 0 === n2 && (n2 = r2);
          var i2 = Object.getOwnPropertyDescriptor(t2, r2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[r2];
          } }), Object.defineProperty(e2, n2, i2);
        } : function(e2, t2, r2, n2) {
          void 0 === n2 && (n2 = r2), e2[n2] = t2[r2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), s = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var r2 in e2)
              "default" !== r2 && Object.prototype.hasOwnProperty.call(e2, r2) && n(t2, e2, r2);
          return i(t2, e2), t2;
        }, o = this && this.__exportStar || function(e2, t2) {
          for (var r2 in e2)
            "default" === r2 || Object.prototype.hasOwnProperty.call(t2, r2) || n(t2, e2, r2);
        }, a = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.ReasonCodes = r.UniqueMessageIdProvider = r.DefaultMessageIdProvider = r.Store = r.MqttClient = r.connectAsync = r.connect = r.Client = void 0;
        const l = a(e("./lib/client"));
        r.MqttClient = l.default;
        const u = a(e("./lib/default-message-id-provider"));
        r.DefaultMessageIdProvider = u.default;
        const c = a(e("./lib/unique-message-id-provider"));
        r.UniqueMessageIdProvider = c.default;
        const h = a(e("./lib/store"));
        r.Store = h.default;
        const f = s(e("./lib/connect"));
        r.connect = f.default, Object.defineProperty(r, "connectAsync", { enumerable: true, get: function() {
          return f.connectAsync;
        } }), r.Client = l.default, o(e("./lib/client"), r), o(e("./lib/shared"), r);
        var d = e("./lib/handlers/ack");
        Object.defineProperty(r, "ReasonCodes", { enumerable: true, get: function() {
          return d.ReasonCodes;
        } });
      }, { "./lib/client": 2, "./lib/connect": 4, "./lib/default-message-id-provider": 9, "./lib/handlers/ack": 10, "./lib/shared": 17, "./lib/store": 18, "./lib/unique-message-id-provider": 21 }], 24: [function(e, t, r) {
        "use strict";
        const { AbortController: n, AbortSignal: i } = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0;
        t.exports = n, t.exports.AbortSignal = i, t.exports.default = n;
      }, {}], 25: [function(e, t, r) {
        "use strict";
        r.byteLength = function(e2) {
          var t2 = l(e2), r2 = t2[0], n2 = t2[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, r.toByteArray = function(e2) {
          var t2, r2, n2 = l(e2), o2 = n2[0], a2 = n2[1], u2 = new s(function(e3, t3, r3) {
            return 3 * (t3 + r3) / 4 - r3;
          }(0, o2, a2)), c = 0, h = a2 > 0 ? o2 - 4 : o2;
          for (r2 = 0; r2 < h; r2 += 4)
            t2 = i[e2.charCodeAt(r2)] << 18 | i[e2.charCodeAt(r2 + 1)] << 12 | i[e2.charCodeAt(r2 + 2)] << 6 | i[e2.charCodeAt(r2 + 3)], u2[c++] = t2 >> 16 & 255, u2[c++] = t2 >> 8 & 255, u2[c++] = 255 & t2;
          2 === a2 && (t2 = i[e2.charCodeAt(r2)] << 2 | i[e2.charCodeAt(r2 + 1)] >> 4, u2[c++] = 255 & t2);
          1 === a2 && (t2 = i[e2.charCodeAt(r2)] << 10 | i[e2.charCodeAt(r2 + 1)] << 4 | i[e2.charCodeAt(r2 + 2)] >> 2, u2[c++] = t2 >> 8 & 255, u2[c++] = 255 & t2);
          return u2;
        }, r.fromByteArray = function(e2) {
          for (var t2, r2 = e2.length, i2 = r2 % 3, s2 = [], o2 = 16383, a2 = 0, l2 = r2 - i2; a2 < l2; a2 += o2)
            s2.push(u(e2, a2, a2 + o2 > l2 ? l2 : a2 + o2));
          1 === i2 ? (t2 = e2[r2 - 1], s2.push(n[t2 >> 2] + n[t2 << 4 & 63] + "==")) : 2 === i2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], s2.push(n[t2 >> 10] + n[t2 >> 4 & 63] + n[t2 << 2 & 63] + "="));
          return s2.join("");
        };
        for (var n = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a)
          n[a] = o[a], i[o.charCodeAt(a)] = a;
        function l(e2) {
          var t2 = e2.length;
          if (t2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = e2.indexOf("=");
          return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
        }
        function u(e2, t2, r2) {
          for (var i2, s2, o2 = [], a2 = t2; a2 < r2; a2 += 3)
            i2 = (e2[a2] << 16 & 16711680) + (e2[a2 + 1] << 8 & 65280) + (255 & e2[a2 + 2]), o2.push(n[(s2 = i2) >> 18 & 63] + n[s2 >> 12 & 63] + n[s2 >> 6 & 63] + n[63 & s2]);
          return o2.join("");
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
      }, {}], 26: [function(e, t, r) {
      }, {}], 27: [function(e, t, r) {
        var n = e("buffer"), i = n.Buffer;
        function s(e2, t2) {
          for (var r2 in e2)
            t2[r2] = e2[r2];
        }
        function o(e2, t2, r2) {
          return i(e2, t2, r2);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (s(n, r), r.Buffer = o), s(i, o), o.from = function(e2, t2, r2) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t2, r2);
        }, o.alloc = function(e2, t2, r2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var n2 = i(e2);
          return void 0 !== t2 ? "string" == typeof r2 ? n2.fill(t2, r2) : n2.fill(t2) : n2.fill(0), n2;
        }, o.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, o.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e2);
        };
      }, { buffer: 29 }], 28: [function(e, t, r) {
        "use strict";
        var n = e("safe-buffer").Buffer, i = n.isEncoding || function(e2) {
          switch ((e2 = "" + e2) && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function s(e2) {
          var t2;
          switch (this.encoding = function(e3) {
            var t3 = function(e4) {
              if (!e4)
                return "utf8";
              for (var t4; ; )
                switch (e4) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return e4;
                  default:
                    if (t4)
                      return;
                    e4 = ("" + e4).toLowerCase(), t4 = true;
                }
            }(e3);
            if ("string" != typeof t3 && (n.isEncoding === i || !i(e3)))
              throw new Error("Unknown encoding: " + e3);
            return t3 || e3;
          }(e2), this.encoding) {
            case "utf16le":
              this.text = l, this.end = u, t2 = 4;
              break;
            case "utf8":
              this.fillLast = a, t2 = 4;
              break;
            case "base64":
              this.text = c, this.end = h, t2 = 3;
              break;
            default:
              return this.write = f, void (this.end = d);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t2);
        }
        function o(e2) {
          return e2 <= 127 ? 0 : e2 >> 5 == 6 ? 2 : e2 >> 4 == 14 ? 3 : e2 >> 3 == 30 ? 4 : e2 >> 6 == 2 ? -1 : -2;
        }
        function a(e2) {
          var t2 = this.lastTotal - this.lastNeed, r2 = function(e3, t3, r3) {
            if (128 != (192 & t3[0]))
              return e3.lastNeed = 0, "";
            if (e3.lastNeed > 1 && t3.length > 1) {
              if (128 != (192 & t3[1]))
                return e3.lastNeed = 1, "";
              if (e3.lastNeed > 2 && t3.length > 2 && 128 != (192 & t3[2]))
                return e3.lastNeed = 2, "";
            }
          }(this, e2);
          return void 0 !== r2 ? r2 : this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e2.copy(this.lastChar, t2, 0, e2.length), void (this.lastNeed -= e2.length));
        }
        function l(e2, t2) {
          if ((e2.length - t2) % 2 == 0) {
            var r2 = e2.toString("utf16le", t2);
            if (r2) {
              var n2 = r2.charCodeAt(r2.length - 1);
              if (n2 >= 55296 && n2 <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], r2.slice(0, -1);
            }
            return r2;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t2, e2.length - 1);
        }
        function u(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var r2 = this.lastTotal - this.lastNeed;
            return t2 + this.lastChar.toString("utf16le", 0, r2);
          }
          return t2;
        }
        function c(e2, t2) {
          var r2 = (e2.length - t2) % 3;
          return 0 === r2 ? e2.toString("base64", t2) : (this.lastNeed = 3 - r2, this.lastTotal = 3, 1 === r2 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t2, e2.length - r2));
        }
        function h(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t2;
        }
        function f(e2) {
          return e2.toString(this.encoding);
        }
        function d(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        r.StringDecoder = s, s.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t2, r2;
          if (this.lastNeed) {
            if (void 0 === (t2 = this.fillLast(e2)))
              return "";
            r2 = this.lastNeed, this.lastNeed = 0;
          } else
            r2 = 0;
          return r2 < e2.length ? t2 ? t2 + this.text(e2, r2) : this.text(e2, r2) : t2 || "";
        }, s.prototype.end = function(e2) {
          var t2 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t2 + "" : t2;
        }, s.prototype.text = function(e2, t2) {
          var r2 = function(e3, t3, r3) {
            var n3 = t3.length - 1;
            if (n3 < r3)
              return 0;
            var i2 = o(t3[n3]);
            if (i2 >= 0)
              return i2 > 0 && (e3.lastNeed = i2 - 1), i2;
            if (--n3 < r3 || -2 === i2)
              return 0;
            if (i2 = o(t3[n3]), i2 >= 0)
              return i2 > 0 && (e3.lastNeed = i2 - 2), i2;
            if (--n3 < r3 || -2 === i2)
              return 0;
            if (i2 = o(t3[n3]), i2 >= 0)
              return i2 > 0 && (2 === i2 ? i2 = 0 : e3.lastNeed = i2 - 3), i2;
            return 0;
          }(this, e2, t2);
          if (!this.lastNeed)
            return e2.toString("utf8", t2);
          this.lastTotal = r2;
          var n2 = e2.length - (r2 - this.lastNeed);
          return e2.copy(this.lastChar, 0, n2), e2.toString("utf8", t2, n2);
        }, s.prototype.fillLast = function(e2) {
          if (this.lastNeed <= e2.length)
            return e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length;
        };
      }, { "safe-buffer": 27 }], 29: [function(e, t, r) {
        (function(t2) {
          (function() {
            "use strict";
            var t3 = e("base64-js"), n = e("ieee754");
            r.Buffer = o, r.SlowBuffer = function(e2) {
              +e2 != e2 && (e2 = 0);
              return o.alloc(+e2);
            }, r.INSPECT_MAX_BYTES = 50;
            var i = 2147483647;
            function s(e2) {
              if (e2 > i)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t4 = new Uint8Array(e2);
              return t4.__proto__ = o.prototype, t4;
            }
            function o(e2, t4, r2) {
              if ("number" == typeof e2) {
                if ("string" == typeof t4)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return u(e2);
              }
              return a(e2, t4, r2);
            }
            function a(e2, t4, r2) {
              if ("string" == typeof e2)
                return function(e3, t5) {
                  "string" == typeof t5 && "" !== t5 || (t5 = "utf8");
                  if (!o.isEncoding(t5))
                    throw new TypeError("Unknown encoding: " + t5);
                  var r3 = 0 | f(e3, t5), n3 = s(r3), i3 = n3.write(e3, t5);
                  i3 !== r3 && (n3 = n3.slice(0, i3));
                  return n3;
                }(e2, t4);
              if (ArrayBuffer.isView(e2))
                return c(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (F(e2, ArrayBuffer) || e2 && F(e2.buffer, ArrayBuffer))
                return function(e3, t5, r3) {
                  if (t5 < 0 || e3.byteLength < t5)
                    throw new RangeError('"offset" is outside of buffer bounds');
                  if (e3.byteLength < t5 + (r3 || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                  var n3;
                  n3 = void 0 === t5 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t5) : new Uint8Array(e3, t5, r3);
                  return n3.__proto__ = o.prototype, n3;
                }(e2, t4, r2);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var n2 = e2.valueOf && e2.valueOf();
              if (null != n2 && n2 !== e2)
                return o.from(n2, t4, r2);
              var i2 = function(e3) {
                if (o.isBuffer(e3)) {
                  var t5 = 0 | h(e3.length), r3 = s(t5);
                  return 0 === r3.length || e3.copy(r3, 0, 0, t5), r3;
                }
                if (void 0 !== e3.length)
                  return "number" != typeof e3.length || W(e3.length) ? s(0) : c(e3);
                if ("Buffer" === e3.type && Array.isArray(e3.data))
                  return c(e3.data);
              }(e2);
              if (i2)
                return i2;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return o.from(e2[Symbol.toPrimitive]("string"), t4, r2);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function l(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              if (e2 < 0)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u(e2) {
              return l(e2), s(e2 < 0 ? 0 : 0 | h(e2));
            }
            function c(e2) {
              for (var t4 = e2.length < 0 ? 0 : 0 | h(e2.length), r2 = s(t4), n2 = 0; n2 < t4; n2 += 1)
                r2[n2] = 255 & e2[n2];
              return r2;
            }
            function h(e2) {
              if (e2 >= i)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
              return 0 | e2;
            }
            function f(e2, t4) {
              if (o.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || F(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var r2 = e2.length, n2 = arguments.length > 2 && true === arguments[2];
              if (!n2 && 0 === r2)
                return 0;
              for (var i2 = false; ; )
                switch (t4) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return r2;
                  case "utf8":
                  case "utf-8":
                    return N(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * r2;
                  case "hex":
                    return r2 >>> 1;
                  case "base64":
                    return U(e2).length;
                  default:
                    if (i2)
                      return n2 ? -1 : N(e2).length;
                    t4 = ("" + t4).toLowerCase(), i2 = true;
                }
            }
            function d(e2, t4, r2) {
              var n2 = false;
              if ((void 0 === t4 || t4 < 0) && (t4 = 0), t4 > this.length)
                return "";
              if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
                return "";
              if ((r2 >>>= 0) <= (t4 >>>= 0))
                return "";
              for (e2 || (e2 = "utf8"); ; )
                switch (e2) {
                  case "hex":
                    return R(this, t4, r2);
                  case "utf8":
                  case "utf-8":
                    return A(this, t4, r2);
                  case "ascii":
                    return T(this, t4, r2);
                  case "latin1":
                  case "binary":
                    return I(this, t4, r2);
                  case "base64":
                    return E(this, t4, r2);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return O(this, t4, r2);
                  default:
                    if (n2)
                      throw new TypeError("Unknown encoding: " + e2);
                    e2 = (e2 + "").toLowerCase(), n2 = true;
                }
            }
            function p(e2, t4, r2) {
              var n2 = e2[t4];
              e2[t4] = e2[r2], e2[r2] = n2;
            }
            function b(e2, t4, r2, n2, i2) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), W(r2 = +r2) && (r2 = i2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
                if (i2)
                  return -1;
                r2 = e2.length - 1;
              } else if (r2 < 0) {
                if (!i2)
                  return -1;
                r2 = 0;
              }
              if ("string" == typeof t4 && (t4 = o.from(t4, n2)), o.isBuffer(t4))
                return 0 === t4.length ? -1 : g(e2, t4, r2, n2, i2);
              if ("number" == typeof t4)
                return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e2, t4, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t4, r2) : g(e2, [t4], r2, n2, i2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function g(e2, t4, r2, n2, i2) {
              var s2, o2 = 1, a2 = e2.length, l2 = t4.length;
              if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
                if (e2.length < 2 || t4.length < 2)
                  return -1;
                o2 = 2, a2 /= 2, l2 /= 2, r2 /= 2;
              }
              function u2(e3, t5) {
                return 1 === o2 ? e3[t5] : e3.readUInt16BE(t5 * o2);
              }
              if (i2) {
                var c2 = -1;
                for (s2 = r2; s2 < a2; s2++)
                  if (u2(e2, s2) === u2(t4, -1 === c2 ? 0 : s2 - c2)) {
                    if (-1 === c2 && (c2 = s2), s2 - c2 + 1 === l2)
                      return c2 * o2;
                  } else
                    -1 !== c2 && (s2 -= s2 - c2), c2 = -1;
              } else
                for (r2 + l2 > a2 && (r2 = a2 - l2), s2 = r2; s2 >= 0; s2--) {
                  for (var h2 = true, f2 = 0; f2 < l2; f2++)
                    if (u2(e2, s2 + f2) !== u2(t4, f2)) {
                      h2 = false;
                      break;
                    }
                  if (h2)
                    return s2;
                }
              return -1;
            }
            function m(e2, t4, r2, n2) {
              r2 = Number(r2) || 0;
              var i2 = e2.length - r2;
              n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
              var s2 = t4.length;
              n2 > s2 / 2 && (n2 = s2 / 2);
              for (var o2 = 0; o2 < n2; ++o2) {
                var a2 = parseInt(t4.substr(2 * o2, 2), 16);
                if (W(a2))
                  return o2;
                e2[r2 + o2] = a2;
              }
              return o2;
            }
            function y(e2, t4, r2, n2) {
              return D(N(t4, e2.length - r2), e2, r2, n2);
            }
            function _(e2, t4, r2, n2) {
              return D(function(e3) {
                for (var t5 = [], r3 = 0; r3 < e3.length; ++r3)
                  t5.push(255 & e3.charCodeAt(r3));
                return t5;
              }(t4), e2, r2, n2);
            }
            function w(e2, t4, r2, n2) {
              return _(e2, t4, r2, n2);
            }
            function v(e2, t4, r2, n2) {
              return D(U(t4), e2, r2, n2);
            }
            function S(e2, t4, r2, n2) {
              return D(function(e3, t5) {
                for (var r3, n3, i2, s2 = [], o2 = 0; o2 < e3.length && !((t5 -= 2) < 0); ++o2)
                  n3 = (r3 = e3.charCodeAt(o2)) >> 8, i2 = r3 % 256, s2.push(i2), s2.push(n3);
                return s2;
              }(t4, e2.length - r2), e2, r2, n2);
            }
            function E(e2, r2, n2) {
              return 0 === r2 && n2 === e2.length ? t3.fromByteArray(e2) : t3.fromByteArray(e2.slice(r2, n2));
            }
            function A(e2, t4, r2) {
              r2 = Math.min(e2.length, r2);
              for (var n2 = [], i2 = t4; i2 < r2; ) {
                var s2, o2, a2, l2, u2 = e2[i2], c2 = null, h2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
                if (i2 + h2 <= r2)
                  switch (h2) {
                    case 1:
                      u2 < 128 && (c2 = u2);
                      break;
                    case 2:
                      128 == (192 & (s2 = e2[i2 + 1])) && (l2 = (31 & u2) << 6 | 63 & s2) > 127 && (c2 = l2);
                      break;
                    case 3:
                      s2 = e2[i2 + 1], o2 = e2[i2 + 2], 128 == (192 & s2) && 128 == (192 & o2) && (l2 = (15 & u2) << 12 | (63 & s2) << 6 | 63 & o2) > 2047 && (l2 < 55296 || l2 > 57343) && (c2 = l2);
                      break;
                    case 4:
                      s2 = e2[i2 + 1], o2 = e2[i2 + 2], a2 = e2[i2 + 3], 128 == (192 & s2) && 128 == (192 & o2) && 128 == (192 & a2) && (l2 = (15 & u2) << 18 | (63 & s2) << 12 | (63 & o2) << 6 | 63 & a2) > 65535 && l2 < 1114112 && (c2 = l2);
                  }
                null === c2 ? (c2 = 65533, h2 = 1) : c2 > 65535 && (c2 -= 65536, n2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), n2.push(c2), i2 += h2;
              }
              return function(e3) {
                var t5 = e3.length;
                if (t5 <= k)
                  return String.fromCharCode.apply(String, e3);
                var r3 = "", n3 = 0;
                for (; n3 < t5; )
                  r3 += String.fromCharCode.apply(String, e3.slice(n3, n3 += k));
                return r3;
              }(n2);
            }
            r.kMaxLength = i, o.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (e3) {
                return false;
              }
            }(), o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o.prototype, "parent", { enumerable: true, get: function() {
              if (o.isBuffer(this))
                return this.buffer;
            } }), Object.defineProperty(o.prototype, "offset", { enumerable: true, get: function() {
              if (o.isBuffer(this))
                return this.byteOffset;
            } }), "undefined" != typeof Symbol && null != Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), o.poolSize = 8192, o.from = function(e2, t4, r2) {
              return a(e2, t4, r2);
            }, o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, o.alloc = function(e2, t4, r2) {
              return function(e3, t5, r3) {
                return l(e3), e3 <= 0 ? s(e3) : void 0 !== t5 ? "string" == typeof r3 ? s(e3).fill(t5, r3) : s(e3).fill(t5) : s(e3);
              }(e2, t4, r2);
            }, o.allocUnsafe = function(e2) {
              return u(e2);
            }, o.allocUnsafeSlow = function(e2) {
              return u(e2);
            }, o.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== o.prototype;
            }, o.compare = function(e2, t4) {
              if (F(e2, Uint8Array) && (e2 = o.from(e2, e2.offset, e2.byteLength)), F(t4, Uint8Array) && (t4 = o.from(t4, t4.offset, t4.byteLength)), !o.isBuffer(e2) || !o.isBuffer(t4))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t4)
                return 0;
              for (var r2 = e2.length, n2 = t4.length, i2 = 0, s2 = Math.min(r2, n2); i2 < s2; ++i2)
                if (e2[i2] !== t4[i2]) {
                  r2 = e2[i2], n2 = t4[i2];
                  break;
                }
              return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
            }, o.isEncoding = function(e2) {
              switch (String(e2).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, o.concat = function(e2, t4) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return o.alloc(0);
              var r2;
              if (void 0 === t4)
                for (t4 = 0, r2 = 0; r2 < e2.length; ++r2)
                  t4 += e2[r2].length;
              var n2 = o.allocUnsafe(t4), i2 = 0;
              for (r2 = 0; r2 < e2.length; ++r2) {
                var s2 = e2[r2];
                if (F(s2, Uint8Array) && (s2 = o.from(s2)), !o.isBuffer(s2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                s2.copy(n2, i2), i2 += s2.length;
              }
              return n2;
            }, o.byteLength = f, o.prototype._isBuffer = true, o.prototype.swap16 = function() {
              var e2 = this.length;
              if (e2 % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t4 = 0; t4 < e2; t4 += 2)
                p(this, t4, t4 + 1);
              return this;
            }, o.prototype.swap32 = function() {
              var e2 = this.length;
              if (e2 % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t4 = 0; t4 < e2; t4 += 4)
                p(this, t4, t4 + 3), p(this, t4 + 1, t4 + 2);
              return this;
            }, o.prototype.swap64 = function() {
              var e2 = this.length;
              if (e2 % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t4 = 0; t4 < e2; t4 += 8)
                p(this, t4, t4 + 7), p(this, t4 + 1, t4 + 6), p(this, t4 + 2, t4 + 5), p(this, t4 + 3, t4 + 4);
              return this;
            }, o.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? A(this, 0, e2) : d.apply(this, arguments);
            }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(e2) {
              if (!o.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === o.compare(this, e2);
            }, o.prototype.inspect = function() {
              var e2 = "", t4 = r.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, o.prototype.compare = function(e2, t4, r2, n2, i2) {
              if (F(e2, Uint8Array) && (e2 = o.from(e2, e2.offset, e2.byteLength)), !o.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t4 && (t4 = 0), void 0 === r2 && (r2 = e2 ? e2.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), t4 < 0 || r2 > e2.length || n2 < 0 || i2 > this.length)
                throw new RangeError("out of range index");
              if (n2 >= i2 && t4 >= r2)
                return 0;
              if (n2 >= i2)
                return -1;
              if (t4 >= r2)
                return 1;
              if (this === e2)
                return 0;
              for (var s2 = (i2 >>>= 0) - (n2 >>>= 0), a2 = (r2 >>>= 0) - (t4 >>>= 0), l2 = Math.min(s2, a2), u2 = this.slice(n2, i2), c2 = e2.slice(t4, r2), h2 = 0; h2 < l2; ++h2)
                if (u2[h2] !== c2[h2]) {
                  s2 = u2[h2], a2 = c2[h2];
                  break;
                }
              return s2 < a2 ? -1 : a2 < s2 ? 1 : 0;
            }, o.prototype.includes = function(e2, t4, r2) {
              return -1 !== this.indexOf(e2, t4, r2);
            }, o.prototype.indexOf = function(e2, t4, r2) {
              return b(this, e2, t4, r2, true);
            }, o.prototype.lastIndexOf = function(e2, t4, r2) {
              return b(this, e2, t4, r2, false);
            }, o.prototype.write = function(e2, t4, r2, n2) {
              if (void 0 === t4)
                n2 = "utf8", r2 = this.length, t4 = 0;
              else if (void 0 === r2 && "string" == typeof t4)
                n2 = t4, r2 = this.length, t4 = 0;
              else {
                if (!isFinite(t4))
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t4 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
              }
              var i2 = this.length - t4;
              if ((void 0 === r2 || r2 > i2) && (r2 = i2), e2.length > 0 && (r2 < 0 || t4 < 0) || t4 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              n2 || (n2 = "utf8");
              for (var s2 = false; ; )
                switch (n2) {
                  case "hex":
                    return m(this, e2, t4, r2);
                  case "utf8":
                  case "utf-8":
                    return y(this, e2, t4, r2);
                  case "ascii":
                    return _(this, e2, t4, r2);
                  case "latin1":
                  case "binary":
                    return w(this, e2, t4, r2);
                  case "base64":
                    return v(this, e2, t4, r2);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return S(this, e2, t4, r2);
                  default:
                    if (s2)
                      throw new TypeError("Unknown encoding: " + n2);
                    n2 = ("" + n2).toLowerCase(), s2 = true;
                }
            }, o.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            var k = 4096;
            function T(e2, t4, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t4; i2 < r2; ++i2)
                n2 += String.fromCharCode(127 & e2[i2]);
              return n2;
            }
            function I(e2, t4, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t4; i2 < r2; ++i2)
                n2 += String.fromCharCode(e2[i2]);
              return n2;
            }
            function R(e2, t4, r2) {
              var n2 = e2.length;
              (!t4 || t4 < 0) && (t4 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
              for (var i2 = "", s2 = t4; s2 < r2; ++s2)
                i2 += j(e2[s2]);
              return i2;
            }
            function O(e2, t4, r2) {
              for (var n2 = e2.slice(t4, r2), i2 = "", s2 = 0; s2 < n2.length; s2 += 2)
                i2 += String.fromCharCode(n2[s2] + 256 * n2[s2 + 1]);
              return i2;
            }
            function C(e2, t4, r2) {
              if (e2 % 1 != 0 || e2 < 0)
                throw new RangeError("offset is not uint");
              if (e2 + t4 > r2)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function P(e2, t4, r2, n2, i2, s2) {
              if (!o.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t4 > i2 || t4 < s2)
                throw new RangeError('"value" argument is out of bounds');
              if (r2 + n2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function x(e2, t4, r2, n2, i2, s2) {
              if (r2 + n2 > e2.length)
                throw new RangeError("Index out of range");
              if (r2 < 0)
                throw new RangeError("Index out of range");
            }
            function M(e2, t4, r2, i2, s2) {
              return t4 = +t4, r2 >>>= 0, s2 || x(e2, 0, r2, 4), n.write(e2, t4, r2, i2, 23, 4), r2 + 4;
            }
            function B(e2, t4, r2, i2, s2) {
              return t4 = +t4, r2 >>>= 0, s2 || x(e2, 0, r2, 8), n.write(e2, t4, r2, i2, 52, 8), r2 + 8;
            }
            o.prototype.slice = function(e2, t4) {
              var r2 = this.length;
              (e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t4 = void 0 === t4 ? r2 : ~~t4) < 0 ? (t4 += r2) < 0 && (t4 = 0) : t4 > r2 && (t4 = r2), t4 < e2 && (t4 = e2);
              var n2 = this.subarray(e2, t4);
              return n2.__proto__ = o.prototype, n2;
            }, o.prototype.readUIntLE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || C(e2, t4, this.length);
              for (var n2 = this[e2], i2 = 1, s2 = 0; ++s2 < t4 && (i2 *= 256); )
                n2 += this[e2 + s2] * i2;
              return n2;
            }, o.prototype.readUIntBE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || C(e2, t4, this.length);
              for (var n2 = this[e2 + --t4], i2 = 1; t4 > 0 && (i2 *= 256); )
                n2 += this[e2 + --t4] * i2;
              return n2;
            }, o.prototype.readUInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 1, this.length), this[e2];
            }, o.prototype.readUInt16LE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, o.prototype.readUInt16BE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, o.prototype.readUInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, o.prototype.readUInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, o.prototype.readIntLE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || C(e2, t4, this.length);
              for (var n2 = this[e2], i2 = 1, s2 = 0; ++s2 < t4 && (i2 *= 256); )
                n2 += this[e2 + s2] * i2;
              return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * t4)), n2;
            }, o.prototype.readIntBE = function(e2, t4, r2) {
              e2 >>>= 0, t4 >>>= 0, r2 || C(e2, t4, this.length);
              for (var n2 = t4, i2 = 1, s2 = this[e2 + --n2]; n2 > 0 && (i2 *= 256); )
                s2 += this[e2 + --n2] * i2;
              return s2 >= (i2 *= 128) && (s2 -= Math.pow(2, 8 * t4)), s2;
            }, o.prototype.readInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, o.prototype.readInt16LE = function(e2, t4) {
              e2 >>>= 0, t4 || C(e2, 2, this.length);
              var r2 = this[e2] | this[e2 + 1] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, o.prototype.readInt16BE = function(e2, t4) {
              e2 >>>= 0, t4 || C(e2, 2, this.length);
              var r2 = this[e2 + 1] | this[e2] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, o.prototype.readInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, o.prototype.readInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, o.prototype.readFloatLE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), n.read(this, e2, true, 23, 4);
            }, o.prototype.readFloatBE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 4, this.length), n.read(this, e2, false, 23, 4);
            }, o.prototype.readDoubleLE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 8, this.length), n.read(this, e2, true, 52, 8);
            }, o.prototype.readDoubleBE = function(e2, t4) {
              return e2 >>>= 0, t4 || C(e2, 8, this.length), n.read(this, e2, false, 52, 8);
            }, o.prototype.writeUIntLE = function(e2, t4, r2, n2) {
              (e2 = +e2, t4 >>>= 0, r2 >>>= 0, n2) || P(this, e2, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = 1, s2 = 0;
              for (this[t4] = 255 & e2; ++s2 < r2 && (i2 *= 256); )
                this[t4 + s2] = e2 / i2 & 255;
              return t4 + r2;
            }, o.prototype.writeUIntBE = function(e2, t4, r2, n2) {
              (e2 = +e2, t4 >>>= 0, r2 >>>= 0, n2) || P(this, e2, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = r2 - 1, s2 = 1;
              for (this[t4 + i2] = 255 & e2; --i2 >= 0 && (s2 *= 256); )
                this[t4 + i2] = e2 / s2 & 255;
              return t4 + r2;
            }, o.prototype.writeUInt8 = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 1, 255, 0), this[t4] = 255 & e2, t4 + 1;
            }, o.prototype.writeUInt16LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 65535, 0), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, o.prototype.writeUInt16BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 65535, 0), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, o.prototype.writeUInt32LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 4294967295, 0), this[t4 + 3] = e2 >>> 24, this[t4 + 2] = e2 >>> 16, this[t4 + 1] = e2 >>> 8, this[t4] = 255 & e2, t4 + 4;
            }, o.prototype.writeUInt32BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 4294967295, 0), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, o.prototype.writeIntLE = function(e2, t4, r2, n2) {
              if (e2 = +e2, t4 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                P(this, e2, t4, r2, i2 - 1, -i2);
              }
              var s2 = 0, o2 = 1, a2 = 0;
              for (this[t4] = 255 & e2; ++s2 < r2 && (o2 *= 256); )
                e2 < 0 && 0 === a2 && 0 !== this[t4 + s2 - 1] && (a2 = 1), this[t4 + s2] = (e2 / o2 >> 0) - a2 & 255;
              return t4 + r2;
            }, o.prototype.writeIntBE = function(e2, t4, r2, n2) {
              if (e2 = +e2, t4 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                P(this, e2, t4, r2, i2 - 1, -i2);
              }
              var s2 = r2 - 1, o2 = 1, a2 = 0;
              for (this[t4 + s2] = 255 & e2; --s2 >= 0 && (o2 *= 256); )
                e2 < 0 && 0 === a2 && 0 !== this[t4 + s2 + 1] && (a2 = 1), this[t4 + s2] = (e2 / o2 >> 0) - a2 & 255;
              return t4 + r2;
            }, o.prototype.writeInt8 = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 1, 127, -128), e2 < 0 && (e2 = 255 + e2 + 1), this[t4] = 255 & e2, t4 + 1;
            }, o.prototype.writeInt16LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 32767, -32768), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, o.prototype.writeInt16BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 2, 32767, -32768), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, o.prototype.writeInt32LE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, this[t4 + 2] = e2 >>> 16, this[t4 + 3] = e2 >>> 24, t4 + 4;
            }, o.prototype.writeInt32BE = function(e2, t4, r2) {
              return e2 = +e2, t4 >>>= 0, r2 || P(this, e2, t4, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, o.prototype.writeFloatLE = function(e2, t4, r2) {
              return M(this, e2, t4, true, r2);
            }, o.prototype.writeFloatBE = function(e2, t4, r2) {
              return M(this, e2, t4, false, r2);
            }, o.prototype.writeDoubleLE = function(e2, t4, r2) {
              return B(this, e2, t4, true, r2);
            }, o.prototype.writeDoubleBE = function(e2, t4, r2) {
              return B(this, e2, t4, false, r2);
            }, o.prototype.copy = function(e2, t4, r2, n2) {
              if (!o.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), t4 >= e2.length && (t4 = e2.length), t4 || (t4 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (t4 < 0)
                throw new RangeError("targetStart out of bounds");
              if (r2 < 0 || r2 >= this.length)
                throw new RangeError("Index out of range");
              if (n2 < 0)
                throw new RangeError("sourceEnd out of bounds");
              n2 > this.length && (n2 = this.length), e2.length - t4 < n2 - r2 && (n2 = e2.length - t4 + r2);
              var i2 = n2 - r2;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t4, r2, n2);
              else if (this === e2 && r2 < t4 && t4 < n2)
                for (var s2 = i2 - 1; s2 >= 0; --s2)
                  e2[s2 + t4] = this[s2 + r2];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(r2, n2), t4);
              return i2;
            }, o.prototype.fill = function(e2, t4, r2, n2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t4 ? (n2 = t4, t4 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), void 0 !== n2 && "string" != typeof n2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof n2 && !o.isEncoding(n2))
                  throw new TypeError("Unknown encoding: " + n2);
                if (1 === e2.length) {
                  var i2 = e2.charCodeAt(0);
                  ("utf8" === n2 && i2 < 128 || "latin1" === n2) && (e2 = i2);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (t4 < 0 || this.length < t4 || this.length < r2)
                throw new RangeError("Out of range index");
              if (r2 <= t4)
                return this;
              var s2;
              if (t4 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e2 || (e2 = 0), "number" == typeof e2)
                for (s2 = t4; s2 < r2; ++s2)
                  this[s2] = e2;
              else {
                var a2 = o.isBuffer(e2) ? e2 : o.from(e2, n2), l2 = a2.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (s2 = 0; s2 < r2 - t4; ++s2)
                  this[s2 + t4] = a2[s2 % l2];
              }
              return this;
            };
            var L = /[^+/0-9A-Za-z-_]/g;
            function j(e2) {
              return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function N(e2, t4) {
              var r2;
              t4 = t4 || 1 / 0;
              for (var n2 = e2.length, i2 = null, s2 = [], o2 = 0; o2 < n2; ++o2) {
                if ((r2 = e2.charCodeAt(o2)) > 55295 && r2 < 57344) {
                  if (!i2) {
                    if (r2 > 56319) {
                      (t4 -= 3) > -1 && s2.push(239, 191, 189);
                      continue;
                    }
                    if (o2 + 1 === n2) {
                      (t4 -= 3) > -1 && s2.push(239, 191, 189);
                      continue;
                    }
                    i2 = r2;
                    continue;
                  }
                  if (r2 < 56320) {
                    (t4 -= 3) > -1 && s2.push(239, 191, 189), i2 = r2;
                    continue;
                  }
                  r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
                } else
                  i2 && (t4 -= 3) > -1 && s2.push(239, 191, 189);
                if (i2 = null, r2 < 128) {
                  if ((t4 -= 1) < 0)
                    break;
                  s2.push(r2);
                } else if (r2 < 2048) {
                  if ((t4 -= 2) < 0)
                    break;
                  s2.push(r2 >> 6 | 192, 63 & r2 | 128);
                } else if (r2 < 65536) {
                  if ((t4 -= 3) < 0)
                    break;
                  s2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                } else {
                  if (!(r2 < 1114112))
                    throw new Error("Invalid code point");
                  if ((t4 -= 4) < 0)
                    break;
                  s2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                }
              }
              return s2;
            }
            function U(e2) {
              return t3.toByteArray(function(e3) {
                if ((e3 = (e3 = e3.split("=")[0]).trim().replace(L, "")).length < 2)
                  return "";
                for (; e3.length % 4 != 0; )
                  e3 += "=";
                return e3;
              }(e2));
            }
            function D(e2, t4, r2, n2) {
              for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t4.length || i2 >= e2.length); ++i2)
                t4[i2 + r2] = e2[i2];
              return i2;
            }
            function F(e2, t4) {
              return e2 instanceof t4 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t4.name;
            }
            function W(e2) {
              return e2 != e2;
            }
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 25, buffer: 29, ieee754: 50 }], 30: [function(e, t, r) {
        (function(n) {
          (function() {
            r.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
                return;
              const r2 = "color: " + this.color;
              e2.splice(1, 0, r2, "color: inherit");
              let n2 = 0, i2 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" !== e3 && (n2++, "%c" === e3 && (i2 = n2));
              }), e2.splice(i2, 0, r2);
            }, r.save = function(e2) {
              try {
                e2 ? r.storage.setItem("debug", e2) : r.storage.removeItem("debug");
              } catch (e3) {
              }
            }, r.load = function() {
              let e2;
              try {
                e2 = r.storage.getItem("debug");
              } catch (e3) {
              }
              !e2 && void 0 !== n && "env" in n && (e2 = n.env.DEBUG);
              return e2;
            }, r.useColors = function() {
              if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs))
                return true;
              if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
                return false;
              return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }, r.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), r.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], r.log = console.debug || console.log || (() => {
            }), t.exports = e("./common")(r);
            const { formatters: i } = t.exports;
            i.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 31, _process: 102 }], 31: [function(e, t, r) {
        t.exports = function(t2) {
          function r2(e2) {
            let t3, i2, s, o = null;
            function a(...e3) {
              if (!a.enabled)
                return;
              const n2 = a, i3 = Number(/* @__PURE__ */ new Date()), s2 = i3 - (t3 || i3);
              n2.diff = s2, n2.prev = t3, n2.curr = i3, t3 = i3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let o2 = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t4, i4) => {
                if ("%%" === t4)
                  return "%";
                o2++;
                const s3 = r2.formatters[i4];
                if ("function" == typeof s3) {
                  const r3 = e3[o2];
                  t4 = s3.call(n2, r3), e3.splice(o2, 1), o2--;
                }
                return t4;
              }), r2.formatArgs.call(n2, e3);
              (n2.log || r2.log).apply(n2, e3);
            }
            return a.namespace = e2, a.useColors = r2.useColors(), a.color = r2.selectColor(e2), a.extend = n, a.destroy = r2.destroy, Object.defineProperty(a, "enabled", { enumerable: true, configurable: false, get: () => null !== o ? o : (i2 !== r2.namespaces && (i2 = r2.namespaces, s = r2.enabled(e2)), s), set: (e3) => {
              o = e3;
            } }), "function" == typeof r2.init && r2.init(a), a;
          }
          function n(e2, t3) {
            const n2 = r2(this.namespace + (void 0 === t3 ? ":" : t3) + e2);
            return n2.log = this.log, n2;
          }
          function i(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            if (e2 instanceof Error)
              return e2.stack || e2.message;
            return e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(i), ...r2.skips.map(i).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            let t3;
            r2.save(e2), r2.namespaces = e2, r2.names = [], r2.skips = [];
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), i2 = n2.length;
            for (t3 = 0; t3 < i2; t3++)
              n2[t3] && ("-" === (e2 = n2[t3].replace(/\*/g, ".*?"))[0] ? r2.skips.push(new RegExp("^" + e2.slice(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t3, n2;
            for (t3 = 0, n2 = r2.skips.length; t3 < n2; t3++)
              if (r2.skips[t3].test(e2))
                return false;
            for (t3 = 0, n2 = r2.names.length; t3 < n2; t3++)
              if (r2.names[t3].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t2).forEach((e2) => {
            r2[e2] = t2[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t3 = 0;
            for (let r3 = 0; r3 < e2.length; r3++)
              t3 = (t3 << 5) - t3 + e2.charCodeAt(r3), t3 |= 0;
            return r2.colors[Math.abs(t3) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 97 }], 32: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            var i = e("readable-stream"), s = e("end-of-stream"), o = e("inherits"), a = e("stream-shift"), l = n.from && n.from !== Uint8Array.from ? n.from([0]) : new n([0]), u = function(e2, t2) {
              e2._corked ? e2.once("uncork", t2) : t2();
            }, c = function(e2, t2) {
              return function(r3) {
                r3 ? function(e3, t3) {
                  e3._autoDestroy && e3.destroy(t3);
                }(e2, "premature close" === r3.message ? null : r3) : t2 && !e2._ended && e2.end();
              };
            }, h = function() {
            }, f = function(e2, t2, r3) {
              if (!(this instanceof f))
                return new f(e2, t2, r3);
              i.Duplex.call(this, r3), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r3 || false !== r3.autoDestroy, this._forwardDestroy = !r3 || false !== r3.destroy, this._forwardEnd = !r3 || false !== r3.end, this._corked = 1, this._ondrain = null, this._drained = false, this._forwarding = false, this._unwrite = null, this._unread = null, this._ended = false, this.destroyed = false, e2 && this.setWritable(e2), t2 && this.setReadable(t2);
            };
            o(f, i.Duplex), f.obj = function(e2, t2, r3) {
              return r3 || (r3 = {}), r3.objectMode = true, r3.highWaterMark = 16, new f(e2, t2, r3);
            }, f.prototype.cork = function() {
              1 == ++this._corked && this.emit("cork");
            }, f.prototype.uncork = function() {
              this._corked && 0 == --this._corked && this.emit("uncork");
            }, f.prototype.setWritable = function(e2) {
              if (this._unwrite && this._unwrite(), this.destroyed)
                e2 && e2.destroy && e2.destroy();
              else if (null !== e2 && false !== e2) {
                var t2 = this, n2 = s(e2, { writable: true, readable: false }, c(this, this._forwardEnd)), i2 = function() {
                  var e3 = t2._ondrain;
                  t2._ondrain = null, e3 && e3();
                };
                this._unwrite && r2.nextTick(i2), this._writable = e2, this._writable.on("drain", i2), this._unwrite = function() {
                  t2._writable.removeListener("drain", i2), n2();
                }, this.uncork();
              } else
                this.end();
            }, f.prototype.setReadable = function(e2) {
              if (this._unread && this._unread(), this.destroyed)
                e2 && e2.destroy && e2.destroy();
              else {
                if (null === e2 || false === e2)
                  return this.push(null), void this.resume();
                var t2, r3 = this, n2 = s(e2, { writable: false, readable: true }, c(this)), o2 = function() {
                  r3._forward();
                }, a2 = function() {
                  r3.push(null);
                };
                this._drained = true, this._readable = e2, this._readable2 = e2._readableState ? e2 : (t2 = e2, new i.Readable({ objectMode: true, highWaterMark: 16 }).wrap(t2)), this._readable2.on("readable", o2), this._readable2.on("end", a2), this._unread = function() {
                  r3._readable2.removeListener("readable", o2), r3._readable2.removeListener("end", a2), n2();
                }, this._forward();
              }
            }, f.prototype._read = function() {
              this._drained = true, this._forward();
            }, f.prototype._forward = function() {
              if (!this._forwarding && this._readable2 && this._drained) {
                var e2;
                for (this._forwarding = true; this._drained && null !== (e2 = a(this._readable2)); )
                  this.destroyed || (this._drained = this.push(e2));
                this._forwarding = false;
              }
            }, f.prototype.destroy = function(e2, t2) {
              if (t2 || (t2 = h), this.destroyed)
                return t2(null);
              this.destroyed = true;
              var n2 = this;
              r2.nextTick(function() {
                n2._destroy(e2), t2(null);
              });
            }, f.prototype._destroy = function(e2) {
              if (e2) {
                var t2 = this._ondrain;
                this._ondrain = null, t2 ? t2(e2) : this.emit("error", e2);
              }
              this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
            }, f.prototype._write = function(e2, t2, r3) {
              if (!this.destroyed)
                return this._corked ? u(this, this._write.bind(this, e2, t2, r3)) : e2 === l ? this._finish(r3) : this._writable ? void (false === this._writable.write(e2) ? this._ondrain = r3 : this.destroyed || r3()) : r3();
            }, f.prototype._finish = function(e2) {
              var t2 = this;
              this.emit("preend"), u(this, function() {
                var r3, n2;
                r3 = t2._forwardEnd && t2._writable, n2 = function() {
                  false === t2._writableState.prefinished && (t2._writableState.prefinished = true), t2.emit("prefinish"), u(t2, e2);
                }, r3 ? r3._writableState && r3._writableState.finished ? n2() : r3._writableState ? r3.end(n2) : (r3.end(), n2()) : n2();
              });
            }, f.prototype.end = function(e2, t2, r3) {
              return "function" == typeof e2 ? this.end(null, null, e2) : "function" == typeof t2 ? this.end(e2, null, t2) : (this._ended = true, e2 && this.write(e2), this._writableState.ending || this._writableState.destroyed || this.write(l), i.Writable.prototype.end.call(this, r3));
            }, t.exports = f;
          }).call(this);
        }).call(this, e("_process"), e("buffer").Buffer);
      }, { _process: 102, buffer: 29, "end-of-stream": 48, inherits: 51, "readable-stream": 47, "stream-shift": 135 }], 33: [function(e, t, r) {
        "use strict";
        var n = {};
        function i(e2, t2, r2) {
          r2 || (r2 = Error);
          var i2 = function(e3) {
            var r3, n2;
            function i3(r4, n3, i4) {
              return e3.call(this, function(e4, r5, n4) {
                return "string" == typeof t2 ? t2 : t2(e4, r5, n4);
              }(r4, n3, i4)) || this;
            }
            return n2 = e3, (r3 = i3).prototype = Object.create(n2.prototype), r3.prototype.constructor = r3, r3.__proto__ = n2, i3;
          }(r2);
          i2.prototype.name = r2.name, i2.prototype.code = e2, n[e2] = i2;
        }
        function s(e2, t2) {
          if (Array.isArray(e2)) {
            var r2 = e2.length;
            return e2 = e2.map(function(e3) {
              return String(e3);
            }), r2 > 2 ? "one of ".concat(t2, " ").concat(e2.slice(0, r2 - 1).join(", "), ", or ") + e2[r2 - 1] : 2 === r2 ? "one of ".concat(t2, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t2, " ").concat(e2[0]);
          }
          return "of ".concat(t2, " ").concat(String(e2));
        }
        i("ERR_INVALID_OPT_VALUE", function(e2, t2) {
          return 'The value "' + t2 + '" is invalid for option "' + e2 + '"';
        }, TypeError), i("ERR_INVALID_ARG_TYPE", function(e2, t2, r2) {
          var n2, i2, o, a;
          if ("string" == typeof t2 && (i2 = "not ", t2.substr(!o || o < 0 ? 0 : +o, i2.length) === i2) ? (n2 = "must not be", t2 = t2.replace(/^not /, "")) : n2 = "must be", function(e3, t3, r3) {
            return (void 0 === r3 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t3.length, r3) === t3;
          }(e2, " argument"))
            a = "The ".concat(e2, " ").concat(n2, " ").concat(s(t2, "type"));
          else {
            var l = function(e3, t3, r3) {
              return "number" != typeof r3 && (r3 = 0), !(r3 + t3.length > e3.length) && -1 !== e3.indexOf(t3, r3);
            }(e2, ".") ? "property" : "argument";
            a = 'The "'.concat(e2, '" ').concat(l, " ").concat(n2, " ").concat(s(t2, "type"));
          }
          return a += ". Received type ".concat(typeof r2);
        }, TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n;
      }, {}], 34: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            var n = Object.keys || function(e2) {
              var t2 = [];
              for (var r3 in e2)
                t2.push(r3);
              return t2;
            };
            t.exports = u;
            var i = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(u, i);
            for (var o = n(s.prototype), a = 0; a < o.length; a++) {
              var l = o[a];
              u.prototype[l] || (u.prototype[l] = s.prototype[l]);
            }
            function u(e2) {
              if (!(this instanceof u))
                return new u(e2);
              i.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", c)));
            }
            function c() {
              this._writableState.ended || r2.nextTick(h, this);
            }
            function h(e2) {
              e2.end();
            }
            Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
            }, set: function(e2) {
              void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 36, "./_stream_writable": 38, _process: 102, inherits: 51 }], 35: [function(e, t, r) {
        "use strict";
        t.exports = i;
        var n = e("./_stream_transform");
        function i(e2) {
          if (!(this instanceof i))
            return new i(e2);
          n.call(this, e2);
        }
        e("inherits")(i, n), i.prototype._transform = function(e2, t2, r2) {
          r2(null, e2);
        };
      }, { "./_stream_transform": 37, inherits: 51 }], 36: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            "use strict";
            var i;
            t.exports = k, k.ReadableState = A;
            e("events").EventEmitter;
            var s = function(e2, t2) {
              return e2.listeners(t2).length;
            }, o = e("./internal/streams/stream"), a = e("buffer").Buffer, l = n.Uint8Array || function() {
            };
            var u, c = e("util");
            u = c && c.debuglog ? c.debuglog("stream") : function() {
            };
            var h, f, d, p = e("./internal/streams/buffer_list"), b = e("./internal/streams/destroy"), g = e("./internal/streams/state").getHighWaterMark, m = e("../errors").codes, y = m.ERR_INVALID_ARG_TYPE, _ = m.ERR_STREAM_PUSH_AFTER_EOF, w = m.ERR_METHOD_NOT_IMPLEMENTED, v = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(k, o);
            var S = b.errorOrDestroy, E = ["error", "close", "destroy", "pause", "resume"];
            function A(t2, r3, n2) {
              i = i || e("./_stream_duplex"), t2 = t2 || {}, "boolean" != typeof n2 && (n2 = r3 instanceof i), this.objectMode = !!t2.objectMode, n2 && (this.objectMode = this.objectMode || !!t2.readableObjectMode), this.highWaterMark = g(this, t2, "readableHighWaterMark", n2), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t2.emitClose, this.autoDestroy = !!t2.autoDestroy, this.destroyed = false, this.defaultEncoding = t2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t2.encoding && (h || (h = e("string_decoder/").StringDecoder), this.decoder = new h(t2.encoding), this.encoding = t2.encoding);
            }
            function k(t2) {
              if (i = i || e("./_stream_duplex"), !(this instanceof k))
                return new k(t2);
              var r3 = this instanceof i;
              this._readableState = new A(t2, this, r3), this.readable = true, t2 && ("function" == typeof t2.read && (this._read = t2.read), "function" == typeof t2.destroy && (this._destroy = t2.destroy)), o.call(this);
            }
            function T(e2, t2, r3, n2, i2) {
              u("readableAddChunk", t2);
              var s2, o2 = e2._readableState;
              if (null === t2)
                o2.reading = false, function(e3, t3) {
                  if (u("onEofChunk"), t3.ended)
                    return;
                  if (t3.decoder) {
                    var r4 = t3.decoder.end();
                    r4 && r4.length && (t3.buffer.push(r4), t3.length += t3.objectMode ? 1 : r4.length);
                  }
                  t3.ended = true, t3.sync ? C(e3) : (t3.needReadable = false, t3.emittedReadable || (t3.emittedReadable = true, P(e3)));
                }(e2, o2);
              else if (i2 || (s2 = function(e3, t3) {
                var r4;
                n3 = t3, a.isBuffer(n3) || n3 instanceof l || "string" == typeof t3 || void 0 === t3 || e3.objectMode || (r4 = new y("chunk", ["string", "Buffer", "Uint8Array"], t3));
                var n3;
                return r4;
              }(o2, t2)), s2)
                S(e2, s2);
              else if (o2.objectMode || t2 && t2.length > 0)
                if ("string" == typeof t2 || o2.objectMode || Object.getPrototypeOf(t2) === a.prototype || (t2 = function(e3) {
                  return a.from(e3);
                }(t2)), n2)
                  o2.endEmitted ? S(e2, new v()) : I(e2, o2, t2, true);
                else if (o2.ended)
                  S(e2, new _());
                else {
                  if (o2.destroyed)
                    return false;
                  o2.reading = false, o2.decoder && !r3 ? (t2 = o2.decoder.write(t2), o2.objectMode || 0 !== t2.length ? I(e2, o2, t2, false) : x(e2, o2)) : I(e2, o2, t2, false);
                }
              else
                n2 || (o2.reading = false, x(e2, o2));
              return !o2.ended && (o2.length < o2.highWaterMark || 0 === o2.length);
            }
            function I(e2, t2, r3, n2) {
              t2.flowing && 0 === t2.length && !t2.sync ? (t2.awaitDrain = 0, e2.emit("data", r3)) : (t2.length += t2.objectMode ? 1 : r3.length, n2 ? t2.buffer.unshift(r3) : t2.buffer.push(r3), t2.needReadable && C(e2)), x(e2, t2);
            }
            Object.defineProperty(k.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), k.prototype.destroy = b.destroy, k.prototype._undestroy = b.undestroy, k.prototype._destroy = function(e2, t2) {
              t2(e2);
            }, k.prototype.push = function(e2, t2) {
              var r3, n2 = this._readableState;
              return n2.objectMode ? r3 = true : "string" == typeof e2 && ((t2 = t2 || n2.defaultEncoding) !== n2.encoding && (e2 = a.from(e2, t2), t2 = ""), r3 = true), T(this, e2, t2, false, r3);
            }, k.prototype.unshift = function(e2) {
              return T(this, e2, null, true, false);
            }, k.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, k.prototype.setEncoding = function(t2) {
              h || (h = e("string_decoder/").StringDecoder);
              var r3 = new h(t2);
              this._readableState.decoder = r3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var n2 = this._readableState.buffer.head, i2 = ""; null !== n2; )
                i2 += r3.write(n2.data), n2 = n2.next;
              return this._readableState.buffer.clear(), "" !== i2 && this._readableState.buffer.push(i2), this._readableState.length = i2.length, this;
            };
            var R = 1073741824;
            function O(e2, t2) {
              return e2 <= 0 || 0 === t2.length && t2.ended ? 0 : t2.objectMode ? 1 : e2 != e2 ? t2.flowing && t2.length ? t2.buffer.head.data.length : t2.length : (e2 > t2.highWaterMark && (t2.highWaterMark = function(e3) {
                return e3 >= R ? e3 = R : (e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, e3++), e3;
              }(e2)), e2 <= t2.length ? e2 : t2.ended ? t2.length : (t2.needReadable = true, 0));
            }
            function C(e2) {
              var t2 = e2._readableState;
              u("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (u("emitReadable", t2.flowing), t2.emittedReadable = true, r2.nextTick(P, e2));
            }
            function P(e2) {
              var t2 = e2._readableState;
              u("emitReadable_", t2.destroyed, t2.length, t2.ended), t2.destroyed || !t2.length && !t2.ended || (e2.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, N(e2);
            }
            function x(e2, t2) {
              t2.readingMore || (t2.readingMore = true, r2.nextTick(M, e2, t2));
            }
            function M(e2, t2) {
              for (; !t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && 0 === t2.length); ) {
                var r3 = t2.length;
                if (u("maybeReadMore read 0"), e2.read(0), r3 === t2.length)
                  break;
              }
              t2.readingMore = false;
            }
            function B(e2) {
              var t2 = e2._readableState;
              t2.readableListening = e2.listenerCount("readable") > 0, t2.resumeScheduled && !t2.paused ? t2.flowing = true : e2.listenerCount("data") > 0 && e2.resume();
            }
            function L(e2) {
              u("readable nexttick read 0"), e2.read(0);
            }
            function j(e2, t2) {
              u("resume", t2.reading), t2.reading || e2.read(0), t2.resumeScheduled = false, e2.emit("resume"), N(e2), t2.flowing && !t2.reading && e2.read(0);
            }
            function N(e2) {
              var t2 = e2._readableState;
              for (u("flow", t2.flowing); t2.flowing && null !== e2.read(); )
                ;
            }
            function U(e2, t2) {
              return 0 === t2.length ? null : (t2.objectMode ? r3 = t2.buffer.shift() : !e2 || e2 >= t2.length ? (r3 = t2.decoder ? t2.buffer.join("") : 1 === t2.buffer.length ? t2.buffer.first() : t2.buffer.concat(t2.length), t2.buffer.clear()) : r3 = t2.buffer.consume(e2, t2.decoder), r3);
              var r3;
            }
            function D(e2) {
              var t2 = e2._readableState;
              u("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, r2.nextTick(F, t2, e2));
            }
            function F(e2, t2) {
              if (u("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t2.readable = false, t2.emit("end"), e2.autoDestroy)) {
                var r3 = t2._writableState;
                (!r3 || r3.autoDestroy && r3.finished) && t2.destroy();
              }
            }
            function W(e2, t2) {
              for (var r3 = 0, n2 = e2.length; r3 < n2; r3++)
                if (e2[r3] === t2)
                  return r3;
              return -1;
            }
            k.prototype.read = function(e2) {
              u("read", e2), e2 = parseInt(e2, 10);
              var t2 = this._readableState, r3 = e2;
              if (0 !== e2 && (t2.emittedReadable = false), 0 === e2 && t2.needReadable && ((0 !== t2.highWaterMark ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
                return u("read: emitReadable", t2.length, t2.ended), 0 === t2.length && t2.ended ? D(this) : C(this), null;
              if (0 === (e2 = O(e2, t2)) && t2.ended)
                return 0 === t2.length && D(this), null;
              var n2, i2 = t2.needReadable;
              return u("need readable", i2), (0 === t2.length || t2.length - e2 < t2.highWaterMark) && u("length less than watermark", i2 = true), t2.ended || t2.reading ? u("reading or ended", i2 = false) : i2 && (u("do read"), t2.reading = true, t2.sync = true, 0 === t2.length && (t2.needReadable = true), this._read(t2.highWaterMark), t2.sync = false, t2.reading || (e2 = O(r3, t2))), null === (n2 = e2 > 0 ? U(e2, t2) : null) ? (t2.needReadable = t2.length <= t2.highWaterMark, e2 = 0) : (t2.length -= e2, t2.awaitDrain = 0), 0 === t2.length && (t2.ended || (t2.needReadable = true), r3 !== e2 && t2.ended && D(this)), null !== n2 && this.emit("data", n2), n2;
            }, k.prototype._read = function(e2) {
              S(this, new w("_read()"));
            }, k.prototype.pipe = function(e2, t2) {
              var n2 = this, i2 = this._readableState;
              switch (i2.pipesCount) {
                case 0:
                  i2.pipes = e2;
                  break;
                case 1:
                  i2.pipes = [i2.pipes, e2];
                  break;
                default:
                  i2.pipes.push(e2);
              }
              i2.pipesCount += 1, u("pipe count=%d opts=%j", i2.pipesCount, t2);
              var o2 = (!t2 || false !== t2.end) && e2 !== r2.stdout && e2 !== r2.stderr ? l2 : g2;
              function a2(t3, r3) {
                u("onunpipe"), t3 === n2 && r3 && false === r3.hasUnpiped && (r3.hasUnpiped = true, u("cleanup"), e2.removeListener("close", p2), e2.removeListener("finish", b2), e2.removeListener("drain", c2), e2.removeListener("error", d2), e2.removeListener("unpipe", a2), n2.removeListener("end", l2), n2.removeListener("end", g2), n2.removeListener("data", f2), h2 = true, !i2.awaitDrain || e2._writableState && !e2._writableState.needDrain || c2());
              }
              function l2() {
                u("onend"), e2.end();
              }
              i2.endEmitted ? r2.nextTick(o2) : n2.once("end", o2), e2.on("unpipe", a2);
              var c2 = function(e3) {
                return function() {
                  var t3 = e3._readableState;
                  u("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && s(e3, "data") && (t3.flowing = true, N(e3));
                };
              }(n2);
              e2.on("drain", c2);
              var h2 = false;
              function f2(t3) {
                u("ondata");
                var r3 = e2.write(t3);
                u("dest.write", r3), false === r3 && ((1 === i2.pipesCount && i2.pipes === e2 || i2.pipesCount > 1 && -1 !== W(i2.pipes, e2)) && !h2 && (u("false write response, pause", i2.awaitDrain), i2.awaitDrain++), n2.pause());
              }
              function d2(t3) {
                u("onerror", t3), g2(), e2.removeListener("error", d2), 0 === s(e2, "error") && S(e2, t3);
              }
              function p2() {
                e2.removeListener("finish", b2), g2();
              }
              function b2() {
                u("onfinish"), e2.removeListener("close", p2), g2();
              }
              function g2() {
                u("unpipe"), n2.unpipe(e2);
              }
              return n2.on("data", f2), function(e3, t3, r3) {
                if ("function" == typeof e3.prependListener)
                  return e3.prependListener(t3, r3);
                e3._events && e3._events[t3] ? Array.isArray(e3._events[t3]) ? e3._events[t3].unshift(r3) : e3._events[t3] = [r3, e3._events[t3]] : e3.on(t3, r3);
              }(e2, "error", d2), e2.once("close", p2), e2.once("finish", b2), e2.emit("pipe", n2), i2.flowing || (u("pipe resume"), n2.resume()), e2;
            }, k.prototype.unpipe = function(e2) {
              var t2 = this._readableState, r3 = { hasUnpiped: false };
              if (0 === t2.pipesCount)
                return this;
              if (1 === t2.pipesCount)
                return e2 && e2 !== t2.pipes || (e2 || (e2 = t2.pipes), t2.pipes = null, t2.pipesCount = 0, t2.flowing = false, e2 && e2.emit("unpipe", this, r3)), this;
              if (!e2) {
                var n2 = t2.pipes, i2 = t2.pipesCount;
                t2.pipes = null, t2.pipesCount = 0, t2.flowing = false;
                for (var s2 = 0; s2 < i2; s2++)
                  n2[s2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var o2 = W(t2.pipes, e2);
              return -1 === o2 || (t2.pipes.splice(o2, 1), t2.pipesCount -= 1, 1 === t2.pipesCount && (t2.pipes = t2.pipes[0]), e2.emit("unpipe", this, r3)), this;
            }, k.prototype.on = function(e2, t2) {
              var n2 = o.prototype.on.call(this, e2, t2), i2 = this._readableState;
              return "data" === e2 ? (i2.readableListening = this.listenerCount("readable") > 0, false !== i2.flowing && this.resume()) : "readable" === e2 && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, u("on readable", i2.length, i2.reading), i2.length ? C(this) : i2.reading || r2.nextTick(L, this))), n2;
            }, k.prototype.addListener = k.prototype.on, k.prototype.removeListener = function(e2, t2) {
              var n2 = o.prototype.removeListener.call(this, e2, t2);
              return "readable" === e2 && r2.nextTick(B, this), n2;
            }, k.prototype.removeAllListeners = function(e2) {
              var t2 = o.prototype.removeAllListeners.apply(this, arguments);
              return "readable" !== e2 && void 0 !== e2 || r2.nextTick(B, this), t2;
            }, k.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (u("resume"), e2.flowing = !e2.readableListening, function(e3, t2) {
                t2.resumeScheduled || (t2.resumeScheduled = true, r2.nextTick(j, e3, t2));
              }(this, e2)), e2.paused = false, this;
            }, k.prototype.pause = function() {
              return u("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (u("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, k.prototype.wrap = function(e2) {
              var t2 = this, r3 = this._readableState, n2 = false;
              for (var i2 in e2.on("end", function() {
                if (u("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t2.push(e3);
                }
                t2.push(null);
              }), e2.on("data", function(i3) {
                (u("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), r3.objectMode && null == i3) || (r3.objectMode || i3 && i3.length) && (t2.push(i3) || (n2 = true, e2.pause()));
              }), e2)
                void 0 === this[i2] && "function" == typeof e2[i2] && (this[i2] = function(t3) {
                  return function() {
                    return e2[t3].apply(e2, arguments);
                  };
                }(i2));
              for (var s2 = 0; s2 < E.length; s2++)
                e2.on(E[s2], this.emit.bind(this, E[s2]));
              return this._read = function(t3) {
                u("wrapped _read", t3), n2 && (n2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (k.prototype[Symbol.asyncIterator] = function() {
              return void 0 === f && (f = e("./internal/streams/async_iterator")), f(this);
            }), Object.defineProperty(k.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(k.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(k.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), k._fromList = U, Object.defineProperty(k.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (k.from = function(t2, r3) {
              return void 0 === d && (d = e("./internal/streams/from")), d(k, t2, r3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 33, "./_stream_duplex": 34, "./internal/streams/async_iterator": 39, "./internal/streams/buffer_list": 40, "./internal/streams/destroy": 41, "./internal/streams/from": 43, "./internal/streams/state": 45, "./internal/streams/stream": 46, _process: 102, buffer: 29, events: 49, inherits: 51, "string_decoder/": 136, util: 26 }], 37: [function(e, t, r) {
        "use strict";
        t.exports = c;
        var n = e("../errors").codes, i = n.ERR_METHOD_NOT_IMPLEMENTED, s = n.ERR_MULTIPLE_CALLBACK, o = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = n.ERR_TRANSFORM_WITH_LENGTH_0, l = e("./_stream_duplex");
        function u(e2, t2) {
          var r2 = this._transformState;
          r2.transforming = false;
          var n2 = r2.writecb;
          if (null === n2)
            return this.emit("error", new s());
          r2.writechunk = null, r2.writecb = null, null != t2 && this.push(t2), n2(e2);
          var i2 = this._readableState;
          i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
        }
        function c(e2) {
          if (!(this instanceof c))
            return new c(e2);
          l.call(this, e2), this._transformState = { afterTransform: u.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", h);
        }
        function h() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? f(this, null, null) : this._flush(function(t2, r2) {
            f(e2, t2, r2);
          });
        }
        function f(e2, t2, r2) {
          if (t2)
            return e2.emit("error", t2);
          if (null != r2 && e2.push(r2), e2._writableState.length)
            throw new a();
          if (e2._transformState.transforming)
            throw new o();
          return e2.push(null);
        }
        e("inherits")(c, l), c.prototype.push = function(e2, t2) {
          return this._transformState.needTransform = false, l.prototype.push.call(this, e2, t2);
        }, c.prototype._transform = function(e2, t2, r2) {
          r2(new i("_transform()"));
        }, c.prototype._write = function(e2, t2, r2) {
          var n2 = this._transformState;
          if (n2.writecb = r2, n2.writechunk = e2, n2.writeencoding = t2, !n2.transforming) {
            var i2 = this._readableState;
            (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
        }, c.prototype._read = function(e2) {
          var t2 = this._transformState;
          null === t2.writechunk || t2.transforming ? t2.needTransform = true : (t2.transforming = true, this._transform(t2.writechunk, t2.writeencoding, t2.afterTransform));
        }, c.prototype._destroy = function(e2, t2) {
          l.prototype._destroy.call(this, e2, function(e3) {
            t2(e3);
          });
        };
      }, { "../errors": 33, "./_stream_duplex": 34, inherits: 51 }], 38: [function(e, t, r) {
        (function(r2, n) {
          (function() {
            "use strict";
            function i(e2) {
              var t2 = this;
              this.next = null, this.entry = null, this.finish = function() {
                !function(e3, t3, r3) {
                  var n2 = e3.entry;
                  e3.entry = null;
                  for (; n2; ) {
                    var i2 = n2.callback;
                    t3.pendingcb--, i2(r3), n2 = n2.next;
                  }
                  t3.corkedRequestsFree.next = e3;
                }(t2, e2);
              };
            }
            var s;
            t.exports = k, k.WritableState = A;
            var o = { deprecate: e("util-deprecate") }, a = e("./internal/streams/stream"), l = e("buffer").Buffer, u = n.Uint8Array || function() {
            };
            var c, h = e("./internal/streams/destroy"), f = e("./internal/streams/state").getHighWaterMark, d = e("../errors").codes, p = d.ERR_INVALID_ARG_TYPE, b = d.ERR_METHOD_NOT_IMPLEMENTED, g = d.ERR_MULTIPLE_CALLBACK, m = d.ERR_STREAM_CANNOT_PIPE, y = d.ERR_STREAM_DESTROYED, _ = d.ERR_STREAM_NULL_VALUES, w = d.ERR_STREAM_WRITE_AFTER_END, v = d.ERR_UNKNOWN_ENCODING, S = h.errorOrDestroy;
            function E() {
            }
            function A(t2, n2, o2) {
              s = s || e("./_stream_duplex"), t2 = t2 || {}, "boolean" != typeof o2 && (o2 = n2 instanceof s), this.objectMode = !!t2.objectMode, o2 && (this.objectMode = this.objectMode || !!t2.writableObjectMode), this.highWaterMark = f(this, t2, "writableHighWaterMark", o2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var a2 = false === t2.decodeStrings;
              this.decodeStrings = !a2, this.defaultEncoding = t2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                !function(e3, t3) {
                  var n3 = e3._writableState, i2 = n3.sync, s2 = n3.writecb;
                  if ("function" != typeof s2)
                    throw new g();
                  if (function(e4) {
                    e4.writing = false, e4.writecb = null, e4.length -= e4.writelen, e4.writelen = 0;
                  }(n3), t3)
                    !function(e4, t4, n4, i3, s3) {
                      --t4.pendingcb, n4 ? (r2.nextTick(s3, i3), r2.nextTick(P, e4, t4), e4._writableState.errorEmitted = true, S(e4, i3)) : (s3(i3), e4._writableState.errorEmitted = true, S(e4, i3), P(e4, t4));
                    }(e3, n3, i2, t3, s2);
                  else {
                    var o3 = O(n3) || e3.destroyed;
                    o3 || n3.corked || n3.bufferProcessing || !n3.bufferedRequest || R(e3, n3), i2 ? r2.nextTick(I, e3, n3, o3, s2) : I(e3, n3, o3, s2);
                  }
                }(n2, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t2.emitClose, this.autoDestroy = !!t2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this);
            }
            function k(t2) {
              var r3 = this instanceof (s = s || e("./_stream_duplex"));
              if (!r3 && !c.call(k, this))
                return new k(t2);
              this._writableState = new A(t2, this, r3), this.writable = true, t2 && ("function" == typeof t2.write && (this._write = t2.write), "function" == typeof t2.writev && (this._writev = t2.writev), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.final && (this._final = t2.final)), a.call(this);
            }
            function T(e2, t2, r3, n2, i2, s2, o2) {
              t2.writelen = n2, t2.writecb = o2, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new y("write")) : r3 ? e2._writev(i2, t2.onwrite) : e2._write(i2, s2, t2.onwrite), t2.sync = false;
            }
            function I(e2, t2, r3, n2) {
              r3 || function(e3, t3) {
                0 === t3.length && t3.needDrain && (t3.needDrain = false, e3.emit("drain"));
              }(e2, t2), t2.pendingcb--, n2(), P(e2, t2);
            }
            function R(e2, t2) {
              t2.bufferProcessing = true;
              var r3 = t2.bufferedRequest;
              if (e2._writev && r3 && r3.next) {
                var n2 = t2.bufferedRequestCount, s2 = new Array(n2), o2 = t2.corkedRequestsFree;
                o2.entry = r3;
                for (var a2 = 0, l2 = true; r3; )
                  s2[a2] = r3, r3.isBuf || (l2 = false), r3 = r3.next, a2 += 1;
                s2.allBuffers = l2, T(e2, t2, true, t2.length, s2, "", o2.finish), t2.pendingcb++, t2.lastBufferedRequest = null, o2.next ? (t2.corkedRequestsFree = o2.next, o2.next = null) : t2.corkedRequestsFree = new i(t2), t2.bufferedRequestCount = 0;
              } else {
                for (; r3; ) {
                  var u2 = r3.chunk, c2 = r3.encoding, h2 = r3.callback;
                  if (T(e2, t2, false, t2.objectMode ? 1 : u2.length, u2, c2, h2), r3 = r3.next, t2.bufferedRequestCount--, t2.writing)
                    break;
                }
                null === r3 && (t2.lastBufferedRequest = null);
              }
              t2.bufferedRequest = r3, t2.bufferProcessing = false;
            }
            function O(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function C(e2, t2) {
              e2._final(function(r3) {
                t2.pendingcb--, r3 && S(e2, r3), t2.prefinished = true, e2.emit("prefinish"), P(e2, t2);
              });
            }
            function P(e2, t2) {
              var n2 = O(t2);
              if (n2 && (function(e3, t3) {
                t3.prefinished || t3.finalCalled || ("function" != typeof e3._final || t3.destroyed ? (t3.prefinished = true, e3.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, r2.nextTick(C, e3, t3)));
              }(e2, t2), 0 === t2.pendingcb && (t2.finished = true, e2.emit("finish"), t2.autoDestroy))) {
                var i2 = e2._readableState;
                (!i2 || i2.autoDestroy && i2.endEmitted) && e2.destroy();
              }
              return n2;
            }
            e("inherits")(k, a), A.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t2 = []; e2; )
                t2.push(e2), e2 = e2.next;
              return t2;
            }, function() {
              try {
                Object.defineProperty(A.prototype, "buffer", { get: o.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(k, Symbol.hasInstance, { value: function(e2) {
              return !!c.call(this, e2) || this === k && (e2 && e2._writableState instanceof A);
            } })) : c = function(e2) {
              return e2 instanceof this;
            }, k.prototype.pipe = function() {
              S(this, new m());
            }, k.prototype.write = function(e2, t2, n2) {
              var i2, s2 = this._writableState, o2 = false, a2 = !s2.objectMode && (i2 = e2, l.isBuffer(i2) || i2 instanceof u);
              return a2 && !l.isBuffer(e2) && (e2 = function(e3) {
                return l.from(e3);
              }(e2)), "function" == typeof t2 && (n2 = t2, t2 = null), a2 ? t2 = "buffer" : t2 || (t2 = s2.defaultEncoding), "function" != typeof n2 && (n2 = E), s2.ending ? function(e3, t3) {
                var n3 = new w();
                S(e3, n3), r2.nextTick(t3, n3);
              }(this, n2) : (a2 || function(e3, t3, n3, i3) {
                var s3;
                return null === n3 ? s3 = new _() : "string" == typeof n3 || t3.objectMode || (s3 = new p("chunk", ["string", "Buffer"], n3)), !s3 || (S(e3, s3), r2.nextTick(i3, s3), false);
              }(this, s2, e2, n2)) && (s2.pendingcb++, o2 = function(e3, t3, r3, n3, i3, s3) {
                if (!r3) {
                  var o3 = function(e4, t4, r4) {
                    e4.objectMode || false === e4.decodeStrings || "string" != typeof t4 || (t4 = l.from(t4, r4));
                    return t4;
                  }(t3, n3, i3);
                  n3 !== o3 && (r3 = true, i3 = "buffer", n3 = o3);
                }
                var a3 = t3.objectMode ? 1 : n3.length;
                t3.length += a3;
                var u2 = t3.length < t3.highWaterMark;
                u2 || (t3.needDrain = true);
                if (t3.writing || t3.corked) {
                  var c2 = t3.lastBufferedRequest;
                  t3.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r3, callback: s3, next: null }, c2 ? c2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
                } else
                  T(e3, t3, false, a3, n3, i3, s3);
                return u2;
              }(this, s2, a2, e2, t2, n2)), o2;
            }, k.prototype.cork = function() {
              this._writableState.corked++;
            }, k.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, e2.writing || e2.corked || e2.bufferProcessing || !e2.bufferedRequest || R(this, e2));
            }, k.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1))
                throw new v(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(k.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(k.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), k.prototype._write = function(e2, t2, r3) {
              r3(new b("_write()"));
            }, k.prototype._writev = null, k.prototype.end = function(e2, t2, n2) {
              var i2 = this._writableState;
              return "function" == typeof e2 ? (n2 = e2, e2 = null, t2 = null) : "function" == typeof t2 && (n2 = t2, t2 = null), null != e2 && this.write(e2, t2), i2.corked && (i2.corked = 1, this.uncork()), i2.ending || function(e3, t3, n3) {
                t3.ending = true, P(e3, t3), n3 && (t3.finished ? r2.nextTick(n3) : e3.once("finish", n3));
                t3.ended = true, e3.writable = false;
              }(this, i2, n2), this;
            }, Object.defineProperty(k.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(k.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), k.prototype.destroy = h.destroy, k.prototype._undestroy = h.undestroy, k.prototype._destroy = function(e2, t2) {
              t2(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 33, "./_stream_duplex": 34, "./internal/streams/destroy": 41, "./internal/streams/state": 45, "./internal/streams/stream": 46, _process: 102, buffer: 29, inherits: 51, "util-deprecate": 139 }], 39: [function(e, t, r) {
        (function(r2) {
          (function() {
            "use strict";
            var n;
            function i(e2, t2, r3) {
              return t2 in e2 ? Object.defineProperty(e2, t2, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t2] = r3, e2;
            }
            var s = e("./end-of-stream"), o = Symbol("lastResolve"), a = Symbol("lastReject"), l = Symbol("error"), u = Symbol("ended"), c = Symbol("lastPromise"), h = Symbol("handlePromise"), f = Symbol("stream");
            function d(e2, t2) {
              return { value: e2, done: t2 };
            }
            function p(e2) {
              var t2 = e2[o];
              if (null !== t2) {
                var r3 = e2[f].read();
                null !== r3 && (e2[c] = null, e2[o] = null, e2[a] = null, t2(d(r3, false)));
              }
            }
            function b(e2) {
              r2.nextTick(p, e2);
            }
            var g = Object.getPrototypeOf(function() {
            }), m = Object.setPrototypeOf((i(n = { get stream() {
              return this[f];
            }, next: function() {
              var e2 = this, t2 = this[l];
              if (null !== t2)
                return Promise.reject(t2);
              if (this[u])
                return Promise.resolve(d(void 0, true));
              if (this[f].destroyed)
                return new Promise(function(t3, n3) {
                  r2.nextTick(function() {
                    e2[l] ? n3(e2[l]) : t3(d(void 0, true));
                  });
                });
              var n2, i2 = this[c];
              if (i2)
                n2 = new Promise(function(e3, t3) {
                  return function(r3, n3) {
                    e3.then(function() {
                      t3[u] ? r3(d(void 0, true)) : t3[h](r3, n3);
                    }, n3);
                  };
                }(i2, this));
              else {
                var s2 = this[f].read();
                if (null !== s2)
                  return Promise.resolve(d(s2, false));
                n2 = new Promise(this[h]);
              }
              return this[c] = n2, n2;
            } }, Symbol.asyncIterator, function() {
              return this;
            }), i(n, "return", function() {
              var e2 = this;
              return new Promise(function(t2, r3) {
                e2[f].destroy(null, function(e3) {
                  e3 ? r3(e3) : t2(d(void 0, true));
                });
              });
            }), n), g);
            t.exports = function(e2) {
              var t2, r3 = Object.create(m, (i(t2 = {}, f, { value: e2, writable: true }), i(t2, o, { value: null, writable: true }), i(t2, a, { value: null, writable: true }), i(t2, l, { value: null, writable: true }), i(t2, u, { value: e2._readableState.endEmitted, writable: true }), i(t2, h, { value: function(e3, t3) {
                var n2 = r3[f].read();
                n2 ? (r3[c] = null, r3[o] = null, r3[a] = null, e3(d(n2, false))) : (r3[o] = e3, r3[a] = t3);
              }, writable: true }), t2));
              return r3[c] = null, s(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t3 = r3[a];
                  return null !== t3 && (r3[c] = null, r3[o] = null, r3[a] = null, t3(e3)), void (r3[l] = e3);
                }
                var n2 = r3[o];
                null !== n2 && (r3[c] = null, r3[o] = null, r3[a] = null, n2(d(void 0, true))), r3[u] = true;
              }), e2.on("readable", b.bind(null, r3)), r3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 42, _process: 102 }], 40: [function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function i(e2, t2, r2) {
          return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
        }
        function s(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var o = e("buffer").Buffer, a = e("util").inspect, l = a && a.custom || "inspect";
        t.exports = function() {
          function e2() {
            !function(e3, t3) {
              if (!(e3 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          var t2, r2, u;
          return t2 = e2, r2 = [{ key: "push", value: function(e3) {
            var t3 = { data: e3, next: null };
            this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t3 = this.head, r3 = "" + t3.data; t3 = t3.next; )
              r3 += e3 + t3.data;
            return r3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return o.alloc(0);
            for (var t3, r3, n2, i2 = o.allocUnsafe(e3 >>> 0), s2 = this.head, a2 = 0; s2; )
              t3 = s2.data, r3 = i2, n2 = a2, o.prototype.copy.call(t3, r3, n2), a2 += s2.data.length, s2 = s2.next;
            return i2;
          } }, { key: "consume", value: function(e3, t3) {
            var r3;
            return e3 < this.head.data.length ? (r3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : r3 = e3 === this.head.data.length ? this.shift() : t3 ? this._getString(e3) : this._getBuffer(e3), r3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t3 = this.head, r3 = 1, n2 = t3.data;
            for (e3 -= n2.length; t3 = t3.next; ) {
              var i2 = t3.data, s2 = e3 > i2.length ? i2.length : e3;
              if (s2 === i2.length ? n2 += i2 : n2 += i2.slice(0, e3), 0 == (e3 -= s2)) {
                s2 === i2.length ? (++r3, t3.next ? this.head = t3.next : this.head = this.tail = null) : (this.head = t3, t3.data = i2.slice(s2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, n2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t3 = o.allocUnsafe(e3), r3 = this.head, n2 = 1;
            for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
              var i2 = r3.data, s2 = e3 > i2.length ? i2.length : e3;
              if (i2.copy(t3, t3.length - e3, 0, s2), 0 == (e3 -= s2)) {
                s2 === i2.length ? (++n2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = i2.slice(s2));
                break;
              }
              ++n2;
            }
            return this.length -= n2, t3;
          } }, { key: l, value: function(e3, t3) {
            return a(this, function(e4) {
              for (var t4 = 1; t4 < arguments.length; t4++) {
                var r3 = null != arguments[t4] ? arguments[t4] : {};
                t4 % 2 ? n(Object(r3), true).forEach(function(t5) {
                  i(e4, t5, r3[t5]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(t5) {
                  Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r3, t5));
                });
              }
              return e4;
            }({}, t3, { depth: 0, customInspect: false }));
          } }], r2 && s(t2.prototype, r2), u && s(t2, u), e2;
        }();
      }, { buffer: 29, util: 26 }], 41: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            function r2(e3, t2) {
              i(e3, t2), n(e3);
            }
            function n(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function i(e3, t2) {
              e3.emit("error", t2);
            }
            t.exports = { destroy: function(t2, s) {
              var o = this, a = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
              return a || l ? (s ? s(t2) : t2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e2.nextTick(i, this, t2)) : e2.nextTick(i, this, t2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t2 || null, function(t3) {
                !s && t3 ? o._writableState ? o._writableState.errorEmitted ? e2.nextTick(n, o) : (o._writableState.errorEmitted = true, e2.nextTick(r2, o, t3)) : e2.nextTick(r2, o, t3) : s ? (e2.nextTick(n, o), s(t3)) : e2.nextTick(n, o);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t2) {
              var r3 = e3._readableState, n2 = e3._writableState;
              r3 && r3.autoDestroy || n2 && n2.autoDestroy ? e3.destroy(t2) : e3.emit("error", t2);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 102 }], 42: [function(e, t, r) {
        "use strict";
        var n = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function i() {
        }
        t.exports = function e2(t2, r2, s) {
          if ("function" == typeof r2)
            return e2(t2, null, r2);
          r2 || (r2 = {}), s = function(e3) {
            var t3 = false;
            return function() {
              if (!t3) {
                t3 = true;
                for (var r3 = arguments.length, n2 = new Array(r3), i2 = 0; i2 < r3; i2++)
                  n2[i2] = arguments[i2];
                e3.apply(this, n2);
              }
            };
          }(s || i);
          var o = r2.readable || false !== r2.readable && t2.readable, a = r2.writable || false !== r2.writable && t2.writable, l = function() {
            t2.writable || c();
          }, u = t2._writableState && t2._writableState.finished, c = function() {
            a = false, u = true, o || s.call(t2);
          }, h = t2._readableState && t2._readableState.endEmitted, f = function() {
            o = false, h = true, a || s.call(t2);
          }, d = function(e3) {
            s.call(t2, e3);
          }, p = function() {
            var e3;
            return o && !h ? (t2._readableState && t2._readableState.ended || (e3 = new n()), s.call(t2, e3)) : a && !u ? (t2._writableState && t2._writableState.ended || (e3 = new n()), s.call(t2, e3)) : void 0;
          }, b = function() {
            t2.req.on("finish", c);
          };
          return !function(e3) {
            return e3.setHeader && "function" == typeof e3.abort;
          }(t2) ? a && !t2._writableState && (t2.on("end", l), t2.on("close", l)) : (t2.on("complete", c), t2.on("abort", p), t2.req ? b() : t2.on("request", b)), t2.on("end", f), t2.on("finish", c), false !== r2.error && t2.on("error", d), t2.on("close", p), function() {
            t2.removeListener("complete", c), t2.removeListener("abort", p), t2.removeListener("request", b), t2.req && t2.req.removeListener("finish", c), t2.removeListener("end", l), t2.removeListener("close", l), t2.removeListener("finish", c), t2.removeListener("end", f), t2.removeListener("error", d), t2.removeListener("close", p);
          };
        };
      }, { "../../../errors": 33 }], 43: [function(e, t, r) {
        t.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        var n;
        var i = e("../../../errors").codes, s = i.ERR_MISSING_ARGS, o = i.ERR_STREAM_DESTROYED;
        function a(e2) {
          if (e2)
            throw e2;
        }
        function l(e2) {
          e2();
        }
        function u(e2, t2) {
          return e2.pipe(t2);
        }
        t.exports = function() {
          for (var t2 = arguments.length, r2 = new Array(t2), i2 = 0; i2 < t2; i2++)
            r2[i2] = arguments[i2];
          var c, h = function(e2) {
            return e2.length ? "function" != typeof e2[e2.length - 1] ? a : e2.pop() : a;
          }(r2);
          if (Array.isArray(r2[0]) && (r2 = r2[0]), r2.length < 2)
            throw new s("streams");
          var f = r2.map(function(t3, i3) {
            var s2 = i3 < r2.length - 1;
            return function(t4, r3, i4, s3) {
              s3 = function(e2) {
                var t5 = false;
                return function() {
                  t5 || (t5 = true, e2.apply(void 0, arguments));
                };
              }(s3);
              var a2 = false;
              t4.on("close", function() {
                a2 = true;
              }), void 0 === n && (n = e("./end-of-stream")), n(t4, { readable: r3, writable: i4 }, function(e2) {
                if (e2)
                  return s3(e2);
                a2 = true, s3();
              });
              var l2 = false;
              return function(e2) {
                if (!a2 && !l2)
                  return l2 = true, function(e3) {
                    return e3.setHeader && "function" == typeof e3.abort;
                  }(t4) ? t4.abort() : "function" == typeof t4.destroy ? t4.destroy() : void s3(e2 || new o("pipe"));
              };
            }(t3, s2, i3 > 0, function(e2) {
              c || (c = e2), e2 && f.forEach(l), s2 || (f.forEach(l), h(c));
            });
          });
          return r2.reduce(u);
        };
      }, { "../../../errors": 33, "./end-of-stream": 42 }], 45: [function(e, t, r) {
        "use strict";
        var n = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        t.exports = { getHighWaterMark: function(e2, t2, r2, i) {
          var s = function(e3, t3, r3) {
            return null != e3.highWaterMark ? e3.highWaterMark : t3 ? e3[r3] : null;
          }(t2, i, r2);
          if (null != s) {
            if (!isFinite(s) || Math.floor(s) !== s || s < 0)
              throw new n(i ? r2 : "highWaterMark", s);
            return Math.floor(s);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 33 }], 46: [function(e, t, r) {
        t.exports = e("events").EventEmitter;
      }, { events: 49 }], 47: [function(e, t, r) {
        (r = t.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js"), r.finished = e("./lib/internal/streams/end-of-stream.js"), r.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 34, "./lib/_stream_passthrough.js": 35, "./lib/_stream_readable.js": 36, "./lib/_stream_transform.js": 37, "./lib/_stream_writable.js": 38, "./lib/internal/streams/end-of-stream.js": 42, "./lib/internal/streams/pipeline.js": 44 }], 48: [function(e, t, r) {
        (function(r2) {
          (function() {
            var n = e("once"), i = function() {
            }, s = function(e2, t2, o) {
              if ("function" == typeof t2)
                return s(e2, null, t2);
              t2 || (t2 = {}), o = n(o || i);
              var a = e2._writableState, l = e2._readableState, u = t2.readable || false !== t2.readable && e2.readable, c = t2.writable || false !== t2.writable && e2.writable, h = false, f = function() {
                e2.writable || d();
              }, d = function() {
                c = false, u || o.call(e2);
              }, p = function() {
                u = false, c || o.call(e2);
              }, b = function(t3) {
                o.call(e2, t3 ? new Error("exited with error code: " + t3) : null);
              }, g = function(t3) {
                o.call(e2, t3);
              }, m = function() {
                r2.nextTick(y);
              }, y = function() {
                if (!h)
                  return (!u || l && l.ended && !l.destroyed) && (!c || a && a.ended && !a.destroyed) ? void 0 : o.call(e2, new Error("premature close"));
              }, _ = function() {
                e2.req.on("finish", d);
              };
              return !function(e3) {
                return e3.setHeader && "function" == typeof e3.abort;
              }(e2) ? c && !a && (e2.on("end", f), e2.on("close", f)) : (e2.on("complete", d), e2.on("abort", m), e2.req ? _() : e2.on("request", _)), function(e3) {
                return e3.stdio && Array.isArray(e3.stdio) && 3 === e3.stdio.length;
              }(e2) && e2.on("exit", b), e2.on("end", p), e2.on("finish", d), false !== t2.error && e2.on("error", g), e2.on("close", m), function() {
                h = true, e2.removeListener("complete", d), e2.removeListener("abort", m), e2.removeListener("request", _), e2.req && e2.req.removeListener("finish", d), e2.removeListener("end", f), e2.removeListener("close", f), e2.removeListener("finish", d), e2.removeListener("exit", b), e2.removeListener("end", p), e2.removeListener("error", g), e2.removeListener("close", m);
              };
            };
            t.exports = s;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 102, once: 100 }], 49: [function(e, t, r) {
        "use strict";
        var n, i = "object" == typeof Reflect ? Reflect : null, s = i && "function" == typeof i.apply ? i.apply : function(e2, t2, r2) {
          return Function.prototype.apply.call(e2, t2, r2);
        };
        n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var o = Number.isNaN || function(e2) {
          return e2 != e2;
        };
        function a() {
          a.init.call(this);
        }
        t.exports = a, t.exports.once = function(e2, t2) {
          return new Promise(function(r2, n2) {
            function i2(r3) {
              e2.removeListener(t2, s2), n2(r3);
            }
            function s2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", i2), r2([].slice.call(arguments));
            }
            m(e2, t2, s2, { once: true }), "error" !== t2 && function(e3, t3, r3) {
              "function" == typeof e3.on && m(e3, "error", t3, r3);
            }(e2, i2, { once: true });
          });
        }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
        var l = 10;
        function u(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function c(e2) {
          return void 0 === e2._maxListeners ? a.defaultMaxListeners : e2._maxListeners;
        }
        function h(e2, t2, r2, n2) {
          var i2, s2, o2, a2;
          if (u(r2), void 0 === (s2 = e2._events) ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), s2 = e2._events), o2 = s2[t2]), void 0 === o2)
            o2 = s2[t2] = r2, ++e2._eventsCount;
          else if ("function" == typeof o2 ? o2 = s2[t2] = n2 ? [r2, o2] : [o2, r2] : n2 ? o2.unshift(r2) : o2.push(r2), (i2 = c(e2)) > 0 && o2.length > i2 && !o2.warned) {
            o2.warned = true;
            var l2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            l2.name = "MaxListenersExceededWarning", l2.emitter = e2, l2.type = t2, l2.count = o2.length, a2 = l2, console && console.warn && console.warn(a2);
          }
          return e2;
        }
        function f() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function d(e2, t2, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: r2 }, i2 = f.bind(n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function p(e2, t2, r2) {
          var n2 = e2._events;
          if (void 0 === n2)
            return [];
          var i2 = n2[t2];
          return void 0 === i2 ? [] : "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
            for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3)
              t3[r3] = e3[r3].listener || e3[r3];
            return t3;
          }(i2) : g(i2, i2.length);
        }
        function b(e2) {
          var t2 = this._events;
          if (void 0 !== t2) {
            var r2 = t2[e2];
            if ("function" == typeof r2)
              return 1;
            if (void 0 !== r2)
              return r2.length;
          }
          return 0;
        }
        function g(e2, t2) {
          for (var r2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
            r2[n2] = e2[n2];
          return r2;
        }
        function m(e2, t2, r2, n2) {
          if ("function" == typeof e2.on)
            n2.once ? e2.once(t2, r2) : e2.on(t2, r2);
          else {
            if ("function" != typeof e2.addEventListener)
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
            e2.addEventListener(t2, function i2(s2) {
              n2.once && e2.removeEventListener(t2, i2), r2(s2);
            });
          }
        }
        Object.defineProperty(a, "defaultMaxListeners", { enumerable: true, get: function() {
          return l;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || o(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          l = e2;
        } }), a.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, a.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || o(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, a.prototype.getMaxListeners = function() {
          return c(this);
        }, a.prototype.emit = function(e2) {
          for (var t2 = [], r2 = 1; r2 < arguments.length; r2++)
            t2.push(arguments[r2]);
          var n2 = "error" === e2, i2 = this._events;
          if (void 0 !== i2)
            n2 = n2 && void 0 === i2.error;
          else if (!n2)
            return false;
          if (n2) {
            var o2;
            if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error)
              throw o2;
            var a2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw a2.context = o2, a2;
          }
          var l2 = i2[e2];
          if (void 0 === l2)
            return false;
          if ("function" == typeof l2)
            s(l2, this, t2);
          else {
            var u2 = l2.length, c2 = g(l2, u2);
            for (r2 = 0; r2 < u2; ++r2)
              s(c2[r2], this, t2);
          }
          return true;
        }, a.prototype.addListener = function(e2, t2) {
          return h(this, e2, t2, false);
        }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e2, t2) {
          return h(this, e2, t2, true);
        }, a.prototype.once = function(e2, t2) {
          return u(t2), this.on(e2, d(this, e2, t2)), this;
        }, a.prototype.prependOnceListener = function(e2, t2) {
          return u(t2), this.prependListener(e2, d(this, e2, t2)), this;
        }, a.prototype.removeListener = function(e2, t2) {
          var r2, n2, i2, s2, o2;
          if (u(t2), void 0 === (n2 = this._events))
            return this;
          if (void 0 === (r2 = n2[e2]))
            return this;
          if (r2 === t2 || r2.listener === t2)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
          else if ("function" != typeof r2) {
            for (i2 = -1, s2 = r2.length - 1; s2 >= 0; s2--)
              if (r2[s2] === t2 || r2[s2].listener === t2) {
                o2 = r2[s2].listener, i2 = s2;
                break;
              }
            if (i2 < 0)
              return this;
            0 === i2 ? r2.shift() : function(e3, t3) {
              for (; t3 + 1 < e3.length; t3++)
                e3[t3] = e3[t3 + 1];
              e3.pop();
            }(r2, i2), 1 === r2.length && (n2[e2] = r2[0]), void 0 !== n2.removeListener && this.emit("removeListener", e2, o2 || t2);
          }
          return this;
        }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(e2) {
          var t2, r2, n2;
          if (void 0 === (r2 = this._events))
            return this;
          if (void 0 === r2.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[e2]), this;
          if (0 === arguments.length) {
            var i2, s2 = Object.keys(r2);
            for (n2 = 0; n2 < s2.length; ++n2)
              "removeListener" !== (i2 = s2[n2]) && this.removeAllListeners(i2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = r2[e2]))
            this.removeListener(e2, t2);
          else if (void 0 !== t2)
            for (n2 = t2.length - 1; n2 >= 0; n2--)
              this.removeListener(e2, t2[n2]);
          return this;
        }, a.prototype.listeners = function(e2) {
          return p(this, e2, true);
        }, a.prototype.rawListeners = function(e2) {
          return p(this, e2, false);
        }, a.listenerCount = function(e2, t2) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : b.call(e2, t2);
        }, a.prototype.listenerCount = b, a.prototype.eventNames = function() {
          return this._eventsCount > 0 ? n(this._events) : [];
        };
      }, {}], 50: [function(e, t, r) {
        r.read = function(e2, t2, r2, n, i) {
          var s, o, a = 8 * i - n - 1, l = (1 << a) - 1, u = l >> 1, c = -7, h = r2 ? i - 1 : 0, f = r2 ? -1 : 1, d = e2[t2 + h];
          for (h += f, s = d & (1 << -c) - 1, d >>= -c, c += a; c > 0; s = 256 * s + e2[t2 + h], h += f, c -= 8)
            ;
          for (o = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; o = 256 * o + e2[t2 + h], h += f, c -= 8)
            ;
          if (0 === s)
            s = 1 - u;
          else {
            if (s === l)
              return o ? NaN : 1 / 0 * (d ? -1 : 1);
            o += Math.pow(2, n), s -= u;
          }
          return (d ? -1 : 1) * o * Math.pow(2, s - n);
        }, r.write = function(e2, t2, r2, n, i, s) {
          var o, a, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : s - 1, p = n ? 1 : -1, b = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (a = isNaN(t2) ? 1 : 0, o = c) : (o = Math.floor(Math.log(t2) / Math.LN2), t2 * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t2 += o + h >= 1 ? f / l : f * Math.pow(2, 1 - h)) * l >= 2 && (o++, l /= 2), o + h >= c ? (a = 0, o = c) : o + h >= 1 ? (a = (t2 * l - 1) * Math.pow(2, i), o += h) : (a = t2 * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); i >= 8; e2[r2 + d] = 255 & a, d += p, a /= 256, i -= 8)
            ;
          for (o = o << i | a, u += i; u > 0; e2[r2 + d] = 255 & o, d += p, o /= 256, u -= 8)
            ;
          e2[r2 + d - p] |= 128 * b;
        };
      }, {}], 51: [function(e, t, r) {
        "function" == typeof Object.create ? t.exports = function(e2, t2) {
          t2 && (e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : t.exports = function(e2, t2) {
          if (t2) {
            e2.super_ = t2;
            var r2 = function() {
            };
            r2.prototype = t2.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.ContainerIterator = r.Container = r.Base = void 0;
        r.ContainerIterator = class {
          constructor(e2 = 0) {
            this.iteratorType = e2;
          }
          equals(e2) {
            return this.o === e2.o;
          }
        };
        class n {
          constructor() {
            this.i = 0;
          }
          get length() {
            return this.i;
          }
          size() {
            return this.i;
          }
          empty() {
            return 0 === this.i;
          }
        }
        r.Base = n;
        r.Container = class extends n {
        };
      }, {}], 53: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.HashContainerIterator = r.HashContainer = void 0;
        var n, i = e("../../ContainerBase"), s = (n = e("../../../utils/checkObject")) && n.t ? n : { default: n }, o = e("../../../utils/throwError");
        class a extends i.ContainerIterator {
          constructor(e2, t2, r2) {
            super(r2), this.o = e2, this.h = t2, 0 === this.iteratorType ? (this.pre = function() {
              return this.o.L === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.L, this;
            }, this.next = function() {
              return this.o === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.B, this;
            }) : (this.pre = function() {
              return this.o.B === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.B, this;
            }, this.next = function() {
              return this.o === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.L, this;
            });
          }
        }
        r.HashContainerIterator = a;
        class l extends i.Container {
          constructor() {
            super(), this.H = [], this.g = {}, this.HASH_TAG = Symbol("@@HASH_TAG"), Object.setPrototypeOf(this.g, null), this.h = {}, this.h.L = this.h.B = this.p = this._ = this.h;
          }
          V(e2) {
            const { L: t2, B: r2 } = e2;
            t2.B = r2, r2.L = t2, e2 === this.p && (this.p = r2), e2 === this._ && (this._ = t2), this.i -= 1;
          }
          M(e2, t2, r2) {
            let n2;
            if (void 0 === r2 && (r2 = (0, s.default)(e2)), r2) {
              const r3 = e2[this.HASH_TAG];
              if (void 0 !== r3)
                return this.H[r3].l = t2, this.i;
              Object.defineProperty(e2, this.HASH_TAG, { value: this.H.length, configurable: true }), n2 = { u: e2, l: t2, L: this._, B: this.h }, this.H.push(n2);
            } else {
              const r3 = this.g[e2];
              if (r3)
                return r3.l = t2, this.i;
              n2 = { u: e2, l: t2, L: this._, B: this.h }, this.g[e2] = n2;
            }
            return 0 === this.i ? (this.p = n2, this.h.B = n2) : this._.B = n2, this._ = n2, this.h.L = n2, ++this.i;
          }
          I(e2, t2) {
            if (void 0 === t2 && (t2 = (0, s.default)(e2)), t2) {
              const t3 = e2[this.HASH_TAG];
              return void 0 === t3 ? this.h : this.H[t3];
            }
            return this.g[e2] || this.h;
          }
          clear() {
            const e2 = this.HASH_TAG;
            this.H.forEach(function(t2) {
              delete t2.u[e2];
            }), this.H = [], this.g = {}, Object.setPrototypeOf(this.g, null), this.i = 0, this.p = this._ = this.h.L = this.h.B = this.h;
          }
          eraseElementByKey(e2, t2) {
            let r2;
            if (void 0 === t2 && (t2 = (0, s.default)(e2)), t2) {
              const t3 = e2[this.HASH_TAG];
              if (void 0 === t3)
                return false;
              delete e2[this.HASH_TAG], r2 = this.H[t3], delete this.H[t3];
            } else {
              if (r2 = this.g[e2], void 0 === r2)
                return false;
              delete this.g[e2];
            }
            return this.V(r2), true;
          }
          eraseElementByIterator(e2) {
            const t2 = e2.o;
            return t2 === this.h && (0, o.throwIteratorAccessError)(), this.V(t2), e2.next();
          }
          eraseElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = this.p;
            for (; e2--; )
              t2 = t2.B;
            return this.V(t2), this.i;
          }
        }
        r.HashContainer = l;
      }, { "../../../utils/checkObject": 70, "../../../utils/throwError": 71, "../../ContainerBase": 52 }], 54: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n, i = e("./Base"), s = (n = e("../../utils/checkObject")) && n.t ? n : { default: n }, o = e("../../utils/throwError");
        class a extends i.HashContainerIterator {
          constructor(e2, t2, r2, n2) {
            super(e2, t2, n2), this.container = r2;
          }
          get pointer() {
            this.o === this.h && (0, o.throwIteratorAccessError)();
            const e2 = this;
            return new Proxy([], { get: (t2, r2) => "0" === r2 ? e2.o.u : "1" === r2 ? e2.o.l : void 0, set(t2, r2, n2) {
              if ("1" !== r2)
                throw new TypeError("props must be 1");
              return e2.o.l = n2, true;
            } });
          }
          copy() {
            return new a(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class l extends i.HashContainer {
          constructor(e2 = []) {
            super();
            const t2 = this;
            e2.forEach(function(e3) {
              t2.setElement(e3[0], e3[1]);
            });
          }
          begin() {
            return new a(this.p, this.h, this);
          }
          end() {
            return new a(this.h, this.h, this);
          }
          rBegin() {
            return new a(this._, this.h, this, 1);
          }
          rEnd() {
            return new a(this.h, this.h, this, 1);
          }
          front() {
            if (0 !== this.i)
              return [this.p.u, this.p.l];
          }
          back() {
            if (0 !== this.i)
              return [this._.u, this._.l];
          }
          setElement(e2, t2, r2) {
            return this.M(e2, t2, r2);
          }
          getElementByKey(e2, t2) {
            if (void 0 === t2 && (t2 = (0, s.default)(e2)), t2) {
              const t3 = e2[this.HASH_TAG];
              return void 0 !== t3 ? this.H[t3].l : void 0;
            }
            const r2 = this.g[e2];
            return r2 ? r2.l : void 0;
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = this.p;
            for (; e2--; )
              t2 = t2.B;
            return [t2.u, t2.l];
          }
          find(e2, t2) {
            const r2 = this.I(e2, t2);
            return new a(r2, this.h, this);
          }
          forEach(e2) {
            let t2 = 0, r2 = this.p;
            for (; r2 !== this.h; )
              e2([r2.u, r2.l], t2++, this), r2 = r2.B;
          }
          [Symbol.iterator]() {
            return (function* () {
              let e2 = this.p;
              for (; e2 !== this.h; )
                yield [e2.u, e2.l], e2 = e2.B;
            }).bind(this)();
          }
        }
        var u = l;
        r.default = u;
      }, { "../../utils/checkObject": 70, "../../utils/throwError": 71, "./Base": 53 }], 55: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("./Base"), i = e("../../utils/throwError");
        class s extends n.HashContainerIterator {
          constructor(e2, t2, r2, n2) {
            super(e2, t2, n2), this.container = r2;
          }
          get pointer() {
            return this.o === this.h && (0, i.throwIteratorAccessError)(), this.o.u;
          }
          copy() {
            return new s(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class o extends n.HashContainer {
          constructor(e2 = []) {
            super();
            const t2 = this;
            e2.forEach(function(e3) {
              t2.insert(e3);
            });
          }
          begin() {
            return new s(this.p, this.h, this);
          }
          end() {
            return new s(this.h, this.h, this);
          }
          rBegin() {
            return new s(this._, this.h, this, 1);
          }
          rEnd() {
            return new s(this.h, this.h, this, 1);
          }
          front() {
            return this.p.u;
          }
          back() {
            return this._.u;
          }
          insert(e2, t2) {
            return this.M(e2, void 0, t2);
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = this.p;
            for (; e2--; )
              t2 = t2.B;
            return t2.u;
          }
          find(e2, t2) {
            const r2 = this.I(e2, t2);
            return new s(r2, this.h, this);
          }
          forEach(e2) {
            let t2 = 0, r2 = this.p;
            for (; r2 !== this.h; )
              e2(r2.u, t2++, this), r2 = r2.B;
          }
          [Symbol.iterator]() {
            return (function* () {
              let e2 = this.p;
              for (; e2 !== this.h; )
                yield e2.u, e2 = e2.B;
            }).bind(this)();
          }
        }
        var a = o;
        r.default = a;
      }, { "../../utils/throwError": 71, "./Base": 53 }], 56: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("../ContainerBase");
        class i extends n.Base {
          constructor(e2 = [], t2 = function(e3, t3) {
            return e3 > t3 ? -1 : e3 < t3 ? 1 : 0;
          }, r2 = true) {
            if (super(), this.v = t2, Array.isArray(e2))
              this.C = r2 ? [...e2] : e2;
            else {
              this.C = [];
              const t3 = this;
              e2.forEach(function(e3) {
                t3.C.push(e3);
              });
            }
            this.i = this.C.length;
            const n2 = this.i >> 1;
            for (let e3 = this.i - 1 >> 1; e3 >= 0; --e3)
              this.k(e3, n2);
          }
          m(e2) {
            const t2 = this.C[e2];
            for (; e2 > 0; ) {
              const r2 = e2 - 1 >> 1, n2 = this.C[r2];
              if (this.v(n2, t2) <= 0)
                break;
              this.C[e2] = n2, e2 = r2;
            }
            this.C[e2] = t2;
          }
          k(e2, t2) {
            const r2 = this.C[e2];
            for (; e2 < t2; ) {
              let t3 = e2 << 1 | 1;
              const n2 = t3 + 1;
              let i2 = this.C[t3];
              if (n2 < this.i && this.v(i2, this.C[n2]) > 0 && (t3 = n2, i2 = this.C[n2]), this.v(i2, r2) >= 0)
                break;
              this.C[e2] = i2, e2 = t3;
            }
            this.C[e2] = r2;
          }
          clear() {
            this.i = 0, this.C.length = 0;
          }
          push(e2) {
            this.C.push(e2), this.m(this.i), this.i += 1;
          }
          pop() {
            if (0 === this.i)
              return;
            const e2 = this.C[0], t2 = this.C.pop();
            return this.i -= 1, this.i && (this.C[0] = t2, this.k(0, this.i >> 1)), e2;
          }
          top() {
            return this.C[0];
          }
          find(e2) {
            return this.C.indexOf(e2) >= 0;
          }
          remove(e2) {
            const t2 = this.C.indexOf(e2);
            return !(t2 < 0) && (0 === t2 ? this.pop() : t2 === this.i - 1 ? (this.C.pop(), this.i -= 1) : (this.C.splice(t2, 1, this.C.pop()), this.i -= 1, this.m(t2), this.k(t2, this.i >> 1)), true);
          }
          updateItem(e2) {
            const t2 = this.C.indexOf(e2);
            return !(t2 < 0) && (this.m(t2), this.k(t2, this.i >> 1), true);
          }
          toArray() {
            return [...this.C];
          }
        }
        var s = i;
        r.default = s;
      }, { "../ContainerBase": 52 }], 57: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("../ContainerBase");
        class i extends n.Base {
          constructor(e2 = []) {
            super(), this.j = 0, this.q = [];
            const t2 = this;
            e2.forEach(function(e3) {
              t2.push(e3);
            });
          }
          clear() {
            this.q = [], this.i = this.j = 0;
          }
          push(e2) {
            const t2 = this.q.length;
            if (this.j / t2 > 0.5 && this.j + this.i >= t2 && t2 > 4096) {
              const t3 = this.i;
              for (let e3 = 0; e3 < t3; ++e3)
                this.q[e3] = this.q[this.j + e3];
              this.j = 0, this.q[this.i] = e2;
            } else
              this.q[this.j + this.i] = e2;
            return ++this.i;
          }
          pop() {
            if (0 === this.i)
              return;
            const e2 = this.q[this.j++];
            return this.i -= 1, e2;
          }
          front() {
            if (0 !== this.i)
              return this.q[this.j];
          }
        }
        var s = i;
        r.default = s;
      }, { "../ContainerBase": 52 }], 58: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("../ContainerBase");
        class i extends n.Base {
          constructor(e2 = []) {
            super(), this.S = [];
            const t2 = this;
            e2.forEach(function(e3) {
              t2.push(e3);
            });
          }
          clear() {
            this.i = 0, this.S = [];
          }
          push(e2) {
            return this.S.push(e2), this.i += 1, this.i;
          }
          pop() {
            if (0 !== this.i)
              return this.i -= 1, this.S.pop();
          }
          top() {
            return this.S[this.i - 1];
          }
        }
        var s = i;
        r.default = s;
      }, { "../ContainerBase": 52 }], 59: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.RandomIterator = void 0;
        var n = e("../../ContainerBase"), i = e("../../../utils/throwError");
        class s extends n.ContainerIterator {
          constructor(e2, t2) {
            super(t2), this.o = e2, 0 === this.iteratorType ? (this.pre = function() {
              return 0 === this.o && (0, i.throwIteratorAccessError)(), this.o -= 1, this;
            }, this.next = function() {
              return this.o === this.container.size() && (0, i.throwIteratorAccessError)(), this.o += 1, this;
            }) : (this.pre = function() {
              return this.o === this.container.size() - 1 && (0, i.throwIteratorAccessError)(), this.o += 1, this;
            }, this.next = function() {
              return -1 === this.o && (0, i.throwIteratorAccessError)(), this.o -= 1, this;
            });
          }
          get pointer() {
            return this.container.getElementByPos(this.o);
          }
          set pointer(e2) {
            this.container.setElementByPos(this.o, e2);
          }
        }
        r.RandomIterator = s;
      }, { "../../../utils/throwError": 71, "../../ContainerBase": 52 }], 60: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("../../ContainerBase");
        class i extends n.Container {
        }
        var s = i;
        r.default = s;
      }, { "../../ContainerBase": 52 }], 61: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n, i = (n = e("./Base")) && n.t ? n : { default: n }, s = e("./Base/RandomIterator");
        class o extends s.RandomIterator {
          constructor(e2, t2, r2) {
            super(e2, r2), this.container = t2;
          }
          copy() {
            return new o(this.o, this.container, this.iteratorType);
          }
        }
        class a extends i.default {
          constructor(e2 = [], t2 = 4096) {
            super(), this.j = 0, this.D = 0, this.R = 0, this.N = 0, this.P = 0, this.A = [];
            const r2 = (() => {
              if ("number" == typeof e2.length)
                return e2.length;
              if ("number" == typeof e2.size)
                return e2.size;
              if ("function" == typeof e2.size)
                return e2.size();
              throw new TypeError("Cannot get the length or size of the container");
            })();
            this.F = t2, this.P = Math.max(Math.ceil(r2 / this.F), 1);
            for (let e3 = 0; e3 < this.P; ++e3)
              this.A.push(new Array(this.F));
            const n2 = Math.ceil(r2 / this.F);
            this.j = this.R = (this.P >> 1) - (n2 >> 1), this.D = this.N = this.F - r2 % this.F >> 1;
            const i2 = this;
            e2.forEach(function(e3) {
              i2.pushBack(e3);
            });
          }
          T() {
            const e2 = [], t2 = Math.max(this.P >> 1, 1);
            for (let r2 = 0; r2 < t2; ++r2)
              e2[r2] = new Array(this.F);
            for (let t3 = this.j; t3 < this.P; ++t3)
              e2[e2.length] = this.A[t3];
            for (let t3 = 0; t3 < this.R; ++t3)
              e2[e2.length] = this.A[t3];
            e2[e2.length] = [...this.A[this.R]], this.j = t2, this.R = e2.length - 1;
            for (let r2 = 0; r2 < t2; ++r2)
              e2[e2.length] = new Array(this.F);
            this.A = e2, this.P = e2.length;
          }
          O(e2) {
            const t2 = this.D + e2 + 1, r2 = t2 % this.F;
            let n2 = r2 - 1, i2 = this.j + (t2 - r2) / this.F;
            return 0 === r2 && (i2 -= 1), i2 %= this.P, n2 < 0 && (n2 += this.F), { curNodeBucketIndex: i2, curNodePointerIndex: n2 };
          }
          clear() {
            this.A = [new Array(this.F)], this.P = 1, this.j = this.R = this.i = 0, this.D = this.N = this.F >> 1;
          }
          begin() {
            return new o(0, this);
          }
          end() {
            return new o(this.i, this);
          }
          rBegin() {
            return new o(this.i - 1, this, 1);
          }
          rEnd() {
            return new o(-1, this, 1);
          }
          front() {
            if (0 !== this.i)
              return this.A[this.j][this.D];
          }
          back() {
            if (0 !== this.i)
              return this.A[this.R][this.N];
          }
          pushBack(e2) {
            return this.i && (this.N < this.F - 1 ? this.N += 1 : this.R < this.P - 1 ? (this.R += 1, this.N = 0) : (this.R = 0, this.N = 0), this.R === this.j && this.N === this.D && this.T()), this.i += 1, this.A[this.R][this.N] = e2, this.i;
          }
          popBack() {
            if (0 === this.i)
              return;
            const e2 = this.A[this.R][this.N];
            return 1 !== this.i && (this.N > 0 ? this.N -= 1 : this.R > 0 ? (this.R -= 1, this.N = this.F - 1) : (this.R = this.P - 1, this.N = this.F - 1)), this.i -= 1, e2;
          }
          pushFront(e2) {
            return this.i && (this.D > 0 ? this.D -= 1 : this.j > 0 ? (this.j -= 1, this.D = this.F - 1) : (this.j = this.P - 1, this.D = this.F - 1), this.j === this.R && this.D === this.N && this.T()), this.i += 1, this.A[this.j][this.D] = e2, this.i;
          }
          popFront() {
            if (0 === this.i)
              return;
            const e2 = this.A[this.j][this.D];
            return 1 !== this.i && (this.D < this.F - 1 ? this.D += 1 : this.j < this.P - 1 ? (this.j += 1, this.D = 0) : (this.j = 0, this.D = 0)), this.i -= 1, e2;
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            const { curNodeBucketIndex: t2, curNodePointerIndex: r2 } = this.O(e2);
            return this.A[t2][r2];
          }
          setElementByPos(e2, t2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            const { curNodeBucketIndex: r2, curNodePointerIndex: n2 } = this.O(e2);
            this.A[r2][n2] = t2;
          }
          insert(e2, t2, r2 = 1) {
            if (e2 < 0 || e2 > this.i)
              throw new RangeError();
            if (0 === e2)
              for (; r2--; )
                this.pushFront(t2);
            else if (e2 === this.i)
              for (; r2--; )
                this.pushBack(t2);
            else {
              const n2 = [];
              for (let t3 = e2; t3 < this.i; ++t3)
                n2.push(this.getElementByPos(t3));
              this.cut(e2 - 1);
              for (let e3 = 0; e3 < r2; ++e3)
                this.pushBack(t2);
              for (let e3 = 0; e3 < n2.length; ++e3)
                this.pushBack(n2[e3]);
            }
            return this.i;
          }
          cut(e2) {
            if (e2 < 0)
              return this.clear(), 0;
            const { curNodeBucketIndex: t2, curNodePointerIndex: r2 } = this.O(e2);
            return this.R = t2, this.N = r2, this.i = e2 + 1, this.i;
          }
          eraseElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            if (0 === e2)
              this.popFront();
            else if (e2 === this.i - 1)
              this.popBack();
            else {
              const t2 = [];
              for (let r3 = e2 + 1; r3 < this.i; ++r3)
                t2.push(this.getElementByPos(r3));
              this.cut(e2), this.popBack();
              const r2 = this;
              t2.forEach(function(e3) {
                r2.pushBack(e3);
              });
            }
            return this.i;
          }
          eraseElementByValue(e2) {
            if (0 === this.i)
              return 0;
            const t2 = [];
            for (let r3 = 0; r3 < this.i; ++r3) {
              const n2 = this.getElementByPos(r3);
              n2 !== e2 && t2.push(n2);
            }
            const r2 = t2.length;
            for (let e3 = 0; e3 < r2; ++e3)
              this.setElementByPos(e3, t2[e3]);
            return this.cut(r2 - 1);
          }
          eraseElementByIterator(e2) {
            const t2 = e2.o;
            return this.eraseElementByPos(t2), e2 = e2.next();
          }
          find(e2) {
            for (let t2 = 0; t2 < this.i; ++t2)
              if (this.getElementByPos(t2) === e2)
                return new o(t2, this);
            return this.end();
          }
          reverse() {
            let e2 = 0, t2 = this.i - 1;
            for (; e2 < t2; ) {
              const r2 = this.getElementByPos(e2);
              this.setElementByPos(e2, this.getElementByPos(t2)), this.setElementByPos(t2, r2), e2 += 1, t2 -= 1;
            }
          }
          unique() {
            if (this.i <= 1)
              return this.i;
            let e2 = 1, t2 = this.getElementByPos(0);
            for (let r2 = 1; r2 < this.i; ++r2) {
              const n2 = this.getElementByPos(r2);
              n2 !== t2 && (t2 = n2, this.setElementByPos(e2++, n2));
            }
            for (; this.i > e2; )
              this.popBack();
            return this.i;
          }
          sort(e2) {
            const t2 = [];
            for (let e3 = 0; e3 < this.i; ++e3)
              t2.push(this.getElementByPos(e3));
            t2.sort(e2);
            for (let e3 = 0; e3 < this.i; ++e3)
              this.setElementByPos(e3, t2[e3]);
          }
          shrinkToFit() {
            if (0 === this.i)
              return;
            const e2 = [];
            this.forEach(function(t2) {
              e2.push(t2);
            }), this.P = Math.max(Math.ceil(this.i / this.F), 1), this.i = this.j = this.R = this.D = this.N = 0, this.A = [];
            for (let e3 = 0; e3 < this.P; ++e3)
              this.A.push(new Array(this.F));
            for (let t2 = 0; t2 < e2.length; ++t2)
              this.pushBack(e2[t2]);
          }
          forEach(e2) {
            for (let t2 = 0; t2 < this.i; ++t2)
              e2(this.getElementByPos(t2), t2, this);
          }
          [Symbol.iterator]() {
            return (function* () {
              for (let e2 = 0; e2 < this.i; ++e2)
                yield this.getElementByPos(e2);
            }).bind(this)();
          }
        }
        var l = a;
        r.default = l;
      }, { "./Base": 60, "./Base/RandomIterator": 59 }], 62: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n, i = (n = e("./Base")) && n.t ? n : { default: n }, s = e("../ContainerBase"), o = e("../../utils/throwError");
        class a extends s.ContainerIterator {
          constructor(e2, t2, r2, n2) {
            super(n2), this.o = e2, this.h = t2, this.container = r2, 0 === this.iteratorType ? (this.pre = function() {
              return this.o.L === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.L, this;
            }, this.next = function() {
              return this.o === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.B, this;
            }) : (this.pre = function() {
              return this.o.B === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.B, this;
            }, this.next = function() {
              return this.o === this.h && (0, o.throwIteratorAccessError)(), this.o = this.o.L, this;
            });
          }
          get pointer() {
            return this.o === this.h && (0, o.throwIteratorAccessError)(), this.o.l;
          }
          set pointer(e2) {
            this.o === this.h && (0, o.throwIteratorAccessError)(), this.o.l = e2;
          }
          copy() {
            return new a(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class l extends i.default {
          constructor(e2 = []) {
            super(), this.h = {}, this.p = this._ = this.h.L = this.h.B = this.h;
            const t2 = this;
            e2.forEach(function(e3) {
              t2.pushBack(e3);
            });
          }
          V(e2) {
            const { L: t2, B: r2 } = e2;
            t2.B = r2, r2.L = t2, e2 === this.p && (this.p = r2), e2 === this._ && (this._ = t2), this.i -= 1;
          }
          G(e2, t2) {
            const r2 = t2.B, n2 = { l: e2, L: t2, B: r2 };
            t2.B = n2, r2.L = n2, t2 === this.h && (this.p = n2), r2 === this.h && (this._ = n2), this.i += 1;
          }
          clear() {
            this.i = 0, this.p = this._ = this.h.L = this.h.B = this.h;
          }
          begin() {
            return new a(this.p, this.h, this);
          }
          end() {
            return new a(this.h, this.h, this);
          }
          rBegin() {
            return new a(this._, this.h, this, 1);
          }
          rEnd() {
            return new a(this.h, this.h, this, 1);
          }
          front() {
            return this.p.l;
          }
          back() {
            return this._.l;
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = this.p;
            for (; e2--; )
              t2 = t2.B;
            return t2.l;
          }
          eraseElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = this.p;
            for (; e2--; )
              t2 = t2.B;
            return this.V(t2), this.i;
          }
          eraseElementByValue(e2) {
            let t2 = this.p;
            for (; t2 !== this.h; )
              t2.l === e2 && this.V(t2), t2 = t2.B;
            return this.i;
          }
          eraseElementByIterator(e2) {
            const t2 = e2.o;
            return t2 === this.h && (0, o.throwIteratorAccessError)(), e2 = e2.next(), this.V(t2), e2;
          }
          pushBack(e2) {
            return this.G(e2, this._), this.i;
          }
          popBack() {
            if (0 === this.i)
              return;
            const e2 = this._.l;
            return this.V(this._), e2;
          }
          pushFront(e2) {
            return this.G(e2, this.h), this.i;
          }
          popFront() {
            if (0 === this.i)
              return;
            const e2 = this.p.l;
            return this.V(this.p), e2;
          }
          setElementByPos(e2, t2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let r2 = this.p;
            for (; e2--; )
              r2 = r2.B;
            r2.l = t2;
          }
          insert(e2, t2, r2 = 1) {
            if (e2 < 0 || e2 > this.i)
              throw new RangeError();
            if (r2 <= 0)
              return this.i;
            if (0 === e2)
              for (; r2--; )
                this.pushFront(t2);
            else if (e2 === this.i)
              for (; r2--; )
                this.pushBack(t2);
            else {
              let n2 = this.p;
              for (let t3 = 1; t3 < e2; ++t3)
                n2 = n2.B;
              const i2 = n2.B;
              for (this.i += r2; r2--; )
                n2.B = { l: t2, L: n2 }, n2.B.L = n2, n2 = n2.B;
              n2.B = i2, i2.L = n2;
            }
            return this.i;
          }
          find(e2) {
            let t2 = this.p;
            for (; t2 !== this.h; ) {
              if (t2.l === e2)
                return new a(t2, this.h, this);
              t2 = t2.B;
            }
            return this.end();
          }
          reverse() {
            if (this.i <= 1)
              return;
            let e2 = this.p, t2 = this._, r2 = 0;
            for (; r2 << 1 < this.i; ) {
              const n2 = e2.l;
              e2.l = t2.l, t2.l = n2, e2 = e2.B, t2 = t2.L, r2 += 1;
            }
          }
          unique() {
            if (this.i <= 1)
              return this.i;
            let e2 = this.p;
            for (; e2 !== this.h; ) {
              let t2 = e2;
              for (; t2.B !== this.h && t2.l === t2.B.l; )
                t2 = t2.B, this.i -= 1;
              e2.B = t2.B, e2.B.L = e2, e2 = e2.B;
            }
            return this.i;
          }
          sort(e2) {
            if (this.i <= 1)
              return;
            const t2 = [];
            this.forEach(function(e3) {
              t2.push(e3);
            }), t2.sort(e2);
            let r2 = this.p;
            t2.forEach(function(e3) {
              r2.l = e3, r2 = r2.B;
            });
          }
          merge(e2) {
            const t2 = this;
            if (0 === this.i)
              e2.forEach(function(e3) {
                t2.pushBack(e3);
              });
            else {
              let r2 = this.p;
              e2.forEach(function(e3) {
                for (; r2 !== t2.h && r2.l <= e3; )
                  r2 = r2.B;
                t2.G(e3, r2.L);
              });
            }
            return this.i;
          }
          forEach(e2) {
            let t2 = this.p, r2 = 0;
            for (; t2 !== this.h; )
              e2(t2.l, r2++, this), t2 = t2.B;
          }
          [Symbol.iterator]() {
            return (function* () {
              if (0 === this.i)
                return;
              let e2 = this.p;
              for (; e2 !== this.h; )
                yield e2.l, e2 = e2.B;
            }).bind(this)();
          }
        }
        var u = l;
        r.default = u;
      }, { "../../utils/throwError": 71, "../ContainerBase": 52, "./Base": 60 }], 63: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n, i = (n = e("./Base")) && n.t ? n : { default: n }, s = e("./Base/RandomIterator");
        class o extends s.RandomIterator {
          constructor(e2, t2, r2) {
            super(e2, r2), this.container = t2;
          }
          copy() {
            return new o(this.o, this.container, this.iteratorType);
          }
        }
        class a extends i.default {
          constructor(e2 = [], t2 = true) {
            if (super(), Array.isArray(e2))
              this.J = t2 ? [...e2] : e2, this.i = e2.length;
            else {
              this.J = [];
              const t3 = this;
              e2.forEach(function(e3) {
                t3.pushBack(e3);
              });
            }
          }
          clear() {
            this.i = 0, this.J.length = 0;
          }
          begin() {
            return new o(0, this);
          }
          end() {
            return new o(this.i, this);
          }
          rBegin() {
            return new o(this.i - 1, this, 1);
          }
          rEnd() {
            return new o(-1, this, 1);
          }
          front() {
            return this.J[0];
          }
          back() {
            return this.J[this.i - 1];
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            return this.J[e2];
          }
          eraseElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            return this.J.splice(e2, 1), this.i -= 1, this.i;
          }
          eraseElementByValue(e2) {
            let t2 = 0;
            for (let r2 = 0; r2 < this.i; ++r2)
              this.J[r2] !== e2 && (this.J[t2++] = this.J[r2]);
            return this.i = this.J.length = t2, this.i;
          }
          eraseElementByIterator(e2) {
            const t2 = e2.o;
            return e2 = e2.next(), this.eraseElementByPos(t2), e2;
          }
          pushBack(e2) {
            return this.J.push(e2), this.i += 1, this.i;
          }
          popBack() {
            if (0 !== this.i)
              return this.i -= 1, this.J.pop();
          }
          setElementByPos(e2, t2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            this.J[e2] = t2;
          }
          insert(e2, t2, r2 = 1) {
            if (e2 < 0 || e2 > this.i)
              throw new RangeError();
            return this.J.splice(e2, 0, ...new Array(r2).fill(t2)), this.i += r2, this.i;
          }
          find(e2) {
            for (let t2 = 0; t2 < this.i; ++t2)
              if (this.J[t2] === e2)
                return new o(t2, this);
            return this.end();
          }
          reverse() {
            this.J.reverse();
          }
          unique() {
            let e2 = 1;
            for (let t2 = 1; t2 < this.i; ++t2)
              this.J[t2] !== this.J[t2 - 1] && (this.J[e2++] = this.J[t2]);
            return this.i = this.J.length = e2, this.i;
          }
          sort(e2) {
            this.J.sort(e2);
          }
          forEach(e2) {
            for (let t2 = 0; t2 < this.i; ++t2)
              e2(this.J[t2], t2, this);
          }
          [Symbol.iterator]() {
            return (function* () {
              yield* this.J;
            }).bind(this)();
          }
        }
        var l = a;
        r.default = l;
      }, { "./Base": 60, "./Base/RandomIterator": 59 }], 64: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("../../ContainerBase"), i = e("../../../utils/throwError");
        class s extends n.ContainerIterator {
          constructor(e2, t2, r2) {
            super(r2), this.o = e2, this.h = t2, 0 === this.iteratorType ? (this.pre = function() {
              return this.o === this.h.U && (0, i.throwIteratorAccessError)(), this.o = this.o.L(), this;
            }, this.next = function() {
              return this.o === this.h && (0, i.throwIteratorAccessError)(), this.o = this.o.B(), this;
            }) : (this.pre = function() {
              return this.o === this.h.W && (0, i.throwIteratorAccessError)(), this.o = this.o.B(), this;
            }, this.next = function() {
              return this.o === this.h && (0, i.throwIteratorAccessError)(), this.o = this.o.L(), this;
            });
          }
          get index() {
            let e2 = this.o;
            const t2 = this.h.tt;
            if (e2 === this.h)
              return t2 ? t2.rt - 1 : 0;
            let r2 = 0;
            for (e2.U && (r2 += e2.U.rt); e2 !== t2; ) {
              const t3 = e2.tt;
              e2 === t3.W && (r2 += 1, t3.U && (r2 += t3.U.rt)), e2 = t3;
            }
            return r2;
          }
        }
        var o = s;
        r.default = o;
      }, { "../../../utils/throwError": 71, "../../ContainerBase": 52 }], 65: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.TreeNodeEnableIndex = r.TreeNode = void 0;
        class n {
          constructor(e2, t2) {
            this.ee = 1, this.u = void 0, this.l = void 0, this.U = void 0, this.W = void 0, this.tt = void 0, this.u = e2, this.l = t2;
          }
          L() {
            let e2 = this;
            if (1 === e2.ee && e2.tt.tt === e2)
              e2 = e2.W;
            else if (e2.U)
              for (e2 = e2.U; e2.W; )
                e2 = e2.W;
            else {
              let t2 = e2.tt;
              for (; t2.U === e2; )
                e2 = t2, t2 = e2.tt;
              e2 = t2;
            }
            return e2;
          }
          B() {
            let e2 = this;
            if (e2.W) {
              for (e2 = e2.W; e2.U; )
                e2 = e2.U;
              return e2;
            }
            {
              let t2 = e2.tt;
              for (; t2.W === e2; )
                e2 = t2, t2 = e2.tt;
              return e2.W !== t2 ? t2 : e2;
            }
          }
          te() {
            const e2 = this.tt, t2 = this.W, r2 = t2.U;
            return e2.tt === this ? e2.tt = t2 : e2.U === this ? e2.U = t2 : e2.W = t2, t2.tt = e2, t2.U = this, this.tt = t2, this.W = r2, r2 && (r2.tt = this), t2;
          }
          se() {
            const e2 = this.tt, t2 = this.U, r2 = t2.W;
            return e2.tt === this ? e2.tt = t2 : e2.U === this ? e2.U = t2 : e2.W = t2, t2.tt = e2, t2.W = this, this.tt = t2, this.U = r2, r2 && (r2.tt = this), t2;
          }
        }
        r.TreeNode = n;
        r.TreeNodeEnableIndex = class extends n {
          constructor() {
            super(...arguments), this.rt = 1;
          }
          te() {
            const e2 = super.te();
            return this.ie(), e2.ie(), e2;
          }
          se() {
            const e2 = super.se();
            return this.ie(), e2.ie(), e2;
          }
          ie() {
            this.rt = 1, this.U && (this.rt += this.U.rt), this.W && (this.rt += this.W.rt);
          }
        };
      }, {}], 66: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = e("./TreeNode"), i = e("../../ContainerBase"), s = e("../../../utils/throwError");
        class o extends i.Container {
          constructor(e2 = function(e3, t3) {
            return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
          }, t2 = false) {
            super(), this.Y = void 0, this.v = e2, t2 ? (this.re = n.TreeNodeEnableIndex, this.M = function(e3, t3, r2) {
              const n2 = this.ne(e3, t3, r2);
              if (n2) {
                let e4 = n2.tt;
                for (; e4 !== this.h; )
                  e4.rt += 1, e4 = e4.tt;
                const t4 = this.he(n2);
                if (t4) {
                  const { parentNode: e5, grandParent: r3, curNode: n3 } = t4;
                  e5.ie(), r3.ie(), n3.ie();
                }
              }
              return this.i;
            }, this.V = function(e3) {
              let t3 = this.fe(e3);
              for (; t3 !== this.h; )
                t3.rt -= 1, t3 = t3.tt;
            }) : (this.re = n.TreeNode, this.M = function(e3, t3, r2) {
              const n2 = this.ne(e3, t3, r2);
              return n2 && this.he(n2), this.i;
            }, this.V = this.fe), this.h = new this.re();
          }
          X(e2, t2) {
            let r2 = this.h;
            for (; e2; ) {
              const n2 = this.v(e2.u, t2);
              if (n2 < 0)
                e2 = e2.W;
              else {
                if (!(n2 > 0))
                  return e2;
                r2 = e2, e2 = e2.U;
              }
            }
            return r2;
          }
          Z(e2, t2) {
            let r2 = this.h;
            for (; e2; ) {
              this.v(e2.u, t2) <= 0 ? e2 = e2.W : (r2 = e2, e2 = e2.U);
            }
            return r2;
          }
          $(e2, t2) {
            let r2 = this.h;
            for (; e2; ) {
              const n2 = this.v(e2.u, t2);
              if (n2 < 0)
                r2 = e2, e2 = e2.W;
              else {
                if (!(n2 > 0))
                  return e2;
                e2 = e2.U;
              }
            }
            return r2;
          }
          rr(e2, t2) {
            let r2 = this.h;
            for (; e2; ) {
              this.v(e2.u, t2) < 0 ? (r2 = e2, e2 = e2.W) : e2 = e2.U;
            }
            return r2;
          }
          ue(e2) {
            for (; ; ) {
              const t2 = e2.tt;
              if (t2 === this.h)
                return;
              if (1 === e2.ee)
                return void (e2.ee = 0);
              if (e2 === t2.U) {
                const r2 = t2.W;
                if (1 === r2.ee)
                  r2.ee = 0, t2.ee = 1, t2 === this.Y ? this.Y = t2.te() : t2.te();
                else {
                  if (r2.W && 1 === r2.W.ee)
                    return r2.ee = t2.ee, t2.ee = 0, r2.W.ee = 0, void (t2 === this.Y ? this.Y = t2.te() : t2.te());
                  r2.U && 1 === r2.U.ee ? (r2.ee = 1, r2.U.ee = 0, r2.se()) : (r2.ee = 1, e2 = t2);
                }
              } else {
                const r2 = t2.U;
                if (1 === r2.ee)
                  r2.ee = 0, t2.ee = 1, t2 === this.Y ? this.Y = t2.se() : t2.se();
                else {
                  if (r2.U && 1 === r2.U.ee)
                    return r2.ee = t2.ee, t2.ee = 0, r2.U.ee = 0, void (t2 === this.Y ? this.Y = t2.se() : t2.se());
                  r2.W && 1 === r2.W.ee ? (r2.ee = 1, r2.W.ee = 0, r2.te()) : (r2.ee = 1, e2 = t2);
                }
              }
            }
          }
          fe(e2) {
            if (1 === this.i)
              return this.clear(), this.h;
            let t2 = e2;
            for (; t2.U || t2.W; ) {
              if (t2.W)
                for (t2 = t2.W; t2.U; )
                  t2 = t2.U;
              else
                t2 = t2.U;
              [e2.u, t2.u] = [t2.u, e2.u], [e2.l, t2.l] = [t2.l, e2.l], e2 = t2;
            }
            this.h.U === t2 ? this.h.U = t2.tt : this.h.W === t2 && (this.h.W = t2.tt), this.ue(t2);
            const r2 = t2.tt;
            return t2 === r2.U ? r2.U = void 0 : r2.W = void 0, this.i -= 1, this.Y.ee = 0, r2;
          }
          oe(e2, t2) {
            if (void 0 === e2)
              return false;
            return !!this.oe(e2.U, t2) || (!!t2(e2) || this.oe(e2.W, t2));
          }
          he(e2) {
            for (; ; ) {
              const t2 = e2.tt;
              if (0 === t2.ee)
                return;
              const r2 = t2.tt;
              if (t2 === r2.U) {
                const n2 = r2.W;
                if (n2 && 1 === n2.ee) {
                  if (n2.ee = t2.ee = 0, r2 === this.Y)
                    return;
                  r2.ee = 1, e2 = r2;
                  continue;
                }
                if (e2 === t2.W) {
                  if (e2.ee = 0, e2.U && (e2.U.tt = t2), e2.W && (e2.W.tt = r2), t2.W = e2.U, r2.U = e2.W, e2.U = t2, e2.W = r2, r2 === this.Y)
                    this.Y = e2, this.h.tt = e2;
                  else {
                    const t3 = r2.tt;
                    t3.U === r2 ? t3.U = e2 : t3.W = e2;
                  }
                  return e2.tt = r2.tt, t2.tt = e2, r2.tt = e2, r2.ee = 1, { parentNode: t2, grandParent: r2, curNode: e2 };
                }
                t2.ee = 0, r2 === this.Y ? this.Y = r2.se() : r2.se(), r2.ee = 1;
              } else {
                const n2 = r2.U;
                if (n2 && 1 === n2.ee) {
                  if (n2.ee = t2.ee = 0, r2 === this.Y)
                    return;
                  r2.ee = 1, e2 = r2;
                  continue;
                }
                if (e2 === t2.U) {
                  if (e2.ee = 0, e2.U && (e2.U.tt = r2), e2.W && (e2.W.tt = t2), r2.W = e2.U, t2.U = e2.W, e2.U = r2, e2.W = t2, r2 === this.Y)
                    this.Y = e2, this.h.tt = e2;
                  else {
                    const t3 = r2.tt;
                    t3.U === r2 ? t3.U = e2 : t3.W = e2;
                  }
                  return e2.tt = r2.tt, t2.tt = e2, r2.tt = e2, r2.ee = 1, { parentNode: t2, grandParent: r2, curNode: e2 };
                }
                t2.ee = 0, r2 === this.Y ? this.Y = r2.te() : r2.te(), r2.ee = 1;
              }
              return;
            }
          }
          ne(e2, t2, r2) {
            if (void 0 === this.Y)
              return this.i += 1, this.Y = new this.re(e2, t2), this.Y.ee = 0, this.Y.tt = this.h, this.h.tt = this.Y, this.h.U = this.Y, void (this.h.W = this.Y);
            let n2;
            const i2 = this.h.U, s2 = this.v(i2.u, e2);
            if (0 !== s2) {
              if (s2 > 0)
                i2.U = new this.re(e2, t2), i2.U.tt = i2, n2 = i2.U, this.h.U = n2;
              else {
                const i3 = this.h.W, s3 = this.v(i3.u, e2);
                if (0 === s3)
                  return void (i3.l = t2);
                if (s3 < 0)
                  i3.W = new this.re(e2, t2), i3.W.tt = i3, n2 = i3.W, this.h.W = n2;
                else {
                  if (void 0 !== r2) {
                    const i4 = r2.o;
                    if (i4 !== this.h) {
                      const r3 = this.v(i4.u, e2);
                      if (0 === r3)
                        return void (i4.l = t2);
                      if (r3 > 0) {
                        const r4 = i4.L(), s4 = this.v(r4.u, e2);
                        if (0 === s4)
                          return void (r4.l = t2);
                        s4 < 0 && (n2 = new this.re(e2, t2), void 0 === r4.W ? (r4.W = n2, n2.tt = r4) : (i4.U = n2, n2.tt = i4));
                      }
                    }
                  }
                  if (void 0 === n2)
                    for (n2 = this.Y; ; ) {
                      const r3 = this.v(n2.u, e2);
                      if (r3 > 0) {
                        if (void 0 === n2.U) {
                          n2.U = new this.re(e2, t2), n2.U.tt = n2, n2 = n2.U;
                          break;
                        }
                        n2 = n2.U;
                      } else {
                        if (!(r3 < 0))
                          return void (n2.l = t2);
                        if (void 0 === n2.W) {
                          n2.W = new this.re(e2, t2), n2.W.tt = n2, n2 = n2.W;
                          break;
                        }
                        n2 = n2.W;
                      }
                    }
                }
              }
              return this.i += 1, n2;
            }
            i2.l = t2;
          }
          I(e2, t2) {
            for (; e2; ) {
              const r2 = this.v(e2.u, t2);
              if (r2 < 0)
                e2 = e2.W;
              else {
                if (!(r2 > 0))
                  return e2;
                e2 = e2.U;
              }
            }
            return e2 || this.h;
          }
          clear() {
            this.i = 0, this.Y = void 0, this.h.tt = void 0, this.h.U = this.h.W = void 0;
          }
          updateKeyByIterator(e2, t2) {
            const r2 = e2.o;
            if (r2 === this.h && (0, s.throwIteratorAccessError)(), 1 === this.i)
              return r2.u = t2, true;
            if (r2 === this.h.U)
              return this.v(r2.B().u, t2) > 0 && (r2.u = t2, true);
            if (r2 === this.h.W)
              return this.v(r2.L().u, t2) < 0 && (r2.u = t2, true);
            const n2 = r2.L().u;
            if (this.v(n2, t2) >= 0)
              return false;
            const i2 = r2.B().u;
            return !(this.v(i2, t2) <= 0) && (r2.u = t2, true);
          }
          eraseElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2 = 0;
            const r2 = this;
            return this.oe(this.Y, function(n2) {
              return e2 === t2 ? (r2.V(n2), true) : (t2 += 1, false);
            }), this.i;
          }
          eraseElementByKey(e2) {
            if (0 === this.i)
              return false;
            const t2 = this.I(this.Y, e2);
            return t2 !== this.h && (this.V(t2), true);
          }
          eraseElementByIterator(e2) {
            const t2 = e2.o;
            t2 === this.h && (0, s.throwIteratorAccessError)();
            const r2 = void 0 === t2.W;
            return 0 === e2.iteratorType ? r2 && e2.next() : r2 && void 0 !== t2.U || e2.next(), this.V(t2), e2;
          }
          forEach(e2) {
            let t2 = 0;
            for (const r2 of this)
              e2(r2, t2++, this);
          }
          getElementByPos(e2) {
            if (e2 < 0 || e2 > this.i - 1)
              throw new RangeError();
            let t2, r2 = 0;
            for (const n2 of this) {
              if (r2 === e2) {
                t2 = n2;
                break;
              }
              r2 += 1;
            }
            return t2;
          }
          getHeight() {
            if (0 === this.i)
              return 0;
            const e2 = function(t2) {
              return t2 ? Math.max(e2(t2.U), e2(t2.W)) + 1 : 0;
            };
            return e2(this.Y);
          }
        }
        var a = o;
        r.default = a;
      }, { "../../../utils/throwError": 71, "../../ContainerBase": 52, "./TreeNode": 65 }], 67: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = o(e("./Base")), i = o(e("./Base/TreeIterator")), s = e("../../utils/throwError");
        function o(e2) {
          return e2 && e2.t ? e2 : { default: e2 };
        }
        class a extends i.default {
          constructor(e2, t2, r2, n2) {
            super(e2, t2, n2), this.container = r2;
          }
          get pointer() {
            this.o === this.h && (0, s.throwIteratorAccessError)();
            const e2 = this;
            return new Proxy([], { get: (t2, r2) => "0" === r2 ? e2.o.u : "1" === r2 ? e2.o.l : void 0, set(t2, r2, n2) {
              if ("1" !== r2)
                throw new TypeError("props must be 1");
              return e2.o.l = n2, true;
            } });
          }
          copy() {
            return new a(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class l extends n.default {
          constructor(e2 = [], t2, r2) {
            super(t2, r2);
            const n2 = this;
            e2.forEach(function(e3) {
              n2.setElement(e3[0], e3[1]);
            });
          }
          *K(e2) {
            void 0 !== e2 && (yield* this.K(e2.U), yield [e2.u, e2.l], yield* this.K(e2.W));
          }
          begin() {
            return new a(this.h.U || this.h, this.h, this);
          }
          end() {
            return new a(this.h, this.h, this);
          }
          rBegin() {
            return new a(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new a(this.h, this.h, this, 1);
          }
          front() {
            if (0 === this.i)
              return;
            const e2 = this.h.U;
            return [e2.u, e2.l];
          }
          back() {
            if (0 === this.i)
              return;
            const e2 = this.h.W;
            return [e2.u, e2.l];
          }
          lowerBound(e2) {
            const t2 = this.X(this.Y, e2);
            return new a(t2, this.h, this);
          }
          upperBound(e2) {
            const t2 = this.Z(this.Y, e2);
            return new a(t2, this.h, this);
          }
          reverseLowerBound(e2) {
            const t2 = this.$(this.Y, e2);
            return new a(t2, this.h, this);
          }
          reverseUpperBound(e2) {
            const t2 = this.rr(this.Y, e2);
            return new a(t2, this.h, this);
          }
          setElement(e2, t2, r2) {
            return this.M(e2, t2, r2);
          }
          find(e2) {
            const t2 = this.I(this.Y, e2);
            return new a(t2, this.h, this);
          }
          getElementByKey(e2) {
            return this.I(this.Y, e2).l;
          }
          union(e2) {
            const t2 = this;
            return e2.forEach(function(e3) {
              t2.setElement(e3[0], e3[1]);
            }), this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }
        var u = l;
        r.default = u;
      }, { "../../utils/throwError": 71, "./Base": 66, "./Base/TreeIterator": 64 }], 68: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = void 0;
        var n = o(e("./Base")), i = o(e("./Base/TreeIterator")), s = e("../../utils/throwError");
        function o(e2) {
          return e2 && e2.t ? e2 : { default: e2 };
        }
        class a extends i.default {
          constructor(e2, t2, r2, n2) {
            super(e2, t2, n2), this.container = r2;
          }
          get pointer() {
            return this.o === this.h && (0, s.throwIteratorAccessError)(), this.o.u;
          }
          copy() {
            return new a(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class l extends n.default {
          constructor(e2 = [], t2, r2) {
            super(t2, r2);
            const n2 = this;
            e2.forEach(function(e3) {
              n2.insert(e3);
            });
          }
          *K(e2) {
            void 0 !== e2 && (yield* this.K(e2.U), yield e2.u, yield* this.K(e2.W));
          }
          begin() {
            return new a(this.h.U || this.h, this.h, this);
          }
          end() {
            return new a(this.h, this.h, this);
          }
          rBegin() {
            return new a(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new a(this.h, this.h, this, 1);
          }
          front() {
            return this.h.U ? this.h.U.u : void 0;
          }
          back() {
            return this.h.W ? this.h.W.u : void 0;
          }
          insert(e2, t2) {
            return this.M(e2, void 0, t2);
          }
          find(e2) {
            const t2 = this.I(this.Y, e2);
            return new a(t2, this.h, this);
          }
          lowerBound(e2) {
            const t2 = this.X(this.Y, e2);
            return new a(t2, this.h, this);
          }
          upperBound(e2) {
            const t2 = this.Z(this.Y, e2);
            return new a(t2, this.h, this);
          }
          reverseLowerBound(e2) {
            const t2 = this.$(this.Y, e2);
            return new a(t2, this.h, this);
          }
          reverseUpperBound(e2) {
            const t2 = this.rr(this.Y, e2);
            return new a(t2, this.h, this);
          }
          union(e2) {
            const t2 = this;
            return e2.forEach(function(e3) {
              t2.insert(e3);
            }), this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }
        var u = l;
        r.default = u;
      }, { "../../utils/throwError": 71, "./Base": 66, "./Base/TreeIterator": 64 }], 69: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), Object.defineProperty(r, "Deque", { enumerable: true, get: function() {
          return l.default;
        } }), Object.defineProperty(r, "HashMap", { enumerable: true, get: function() {
          return f.default;
        } }), Object.defineProperty(r, "HashSet", { enumerable: true, get: function() {
          return h.default;
        } }), Object.defineProperty(r, "LinkList", { enumerable: true, get: function() {
          return a.default;
        } }), Object.defineProperty(r, "OrderedMap", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(r, "OrderedSet", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(r, "PriorityQueue", { enumerable: true, get: function() {
          return s.default;
        } }), Object.defineProperty(r, "Queue", { enumerable: true, get: function() {
          return i.default;
        } }), Object.defineProperty(r, "Stack", { enumerable: true, get: function() {
          return n.default;
        } }), Object.defineProperty(r, "Vector", { enumerable: true, get: function() {
          return o.default;
        } });
        var n = d(e("./container/OtherContainer/Stack")), i = d(e("./container/OtherContainer/Queue")), s = d(e("./container/OtherContainer/PriorityQueue")), o = d(e("./container/SequentialContainer/Vector")), a = d(e("./container/SequentialContainer/LinkList")), l = d(e("./container/SequentialContainer/Deque")), u = d(e("./container/TreeContainer/OrderedSet")), c = d(e("./container/TreeContainer/OrderedMap")), h = d(e("./container/HashContainer/HashSet")), f = d(e("./container/HashContainer/HashMap"));
        function d(e2) {
          return e2 && e2.t ? e2 : { default: e2 };
        }
      }, { "./container/HashContainer/HashMap": 54, "./container/HashContainer/HashSet": 55, "./container/OtherContainer/PriorityQueue": 56, "./container/OtherContainer/Queue": 57, "./container/OtherContainer/Stack": 58, "./container/SequentialContainer/Deque": 61, "./container/SequentialContainer/LinkList": 62, "./container/SequentialContainer/Vector": 63, "./container/TreeContainer/OrderedMap": 67, "./container/TreeContainer/OrderedSet": 68 }], 70: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.default = function(e2) {
          const t2 = typeof e2;
          return "object" === t2 && null !== e2 || "function" === t2;
        };
      }, {}], 71: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "t", { value: true }), r.throwIteratorAccessError = function() {
          throw new RangeError("Iterator access denied!");
        };
      }, {}], 72: [function(e, t, r) {
        (function(e2) {
          (function() {
            const r2 = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date, n = "function" == typeof AbortController ? AbortController : class {
              constructor() {
                this.signal = new o();
              }
              abort(e3 = new Error("This operation was aborted")) {
                this.signal.reason = this.signal.reason || e3, this.signal.aborted = true, this.signal.dispatchEvent({ type: "abort", target: this.signal });
              }
            }, i = "function" == typeof AbortSignal, s = "function" == typeof n.AbortSignal, o = i ? AbortSignal : s ? n.AbortController : class {
              constructor() {
                this.reason = void 0, this.aborted = false, this._listeners = [];
              }
              dispatchEvent(e3) {
                "abort" === e3.type && (this.aborted = true, this.onabort(e3), this._listeners.forEach((t2) => t2(e3), this));
              }
              onabort() {
              }
              addEventListener(e3, t2) {
                "abort" === e3 && this._listeners.push(t2);
              }
              removeEventListener(e3, t2) {
                "abort" === e3 && (this._listeners = this._listeners.filter((e4) => e4 !== t2));
              }
            }, a = /* @__PURE__ */ new Set(), l = (e3, t2) => {
              const r3 = `LRU_CACHE_OPTION_${e3}`;
              h(r3) && f(r3, `${e3} option`, `options.${t2}`, m);
            }, u = (e3, t2) => {
              const r3 = `LRU_CACHE_METHOD_${e3}`;
              if (h(r3)) {
                const { prototype: n2 } = m, { get: i2 } = Object.getOwnPropertyDescriptor(n2, e3);
                f(r3, `${e3} method`, `cache.${t2}()`, i2);
              }
            }, c = (...t2) => {
              "object" == typeof e2 && e2 && "function" == typeof e2.emitWarning ? e2.emitWarning(...t2) : console.error(...t2);
            }, h = (e3) => !a.has(e3), f = (e3, t2, r3, n2) => {
              a.add(e3);
              c(`The ${t2} is deprecated. Please use ${r3} instead.`, "DeprecationWarning", e3, n2);
            }, d = (e3) => e3 && e3 === Math.floor(e3) && e3 > 0 && isFinite(e3), p = (e3) => d(e3) ? e3 <= Math.pow(2, 8) ? Uint8Array : e3 <= Math.pow(2, 16) ? Uint16Array : e3 <= Math.pow(2, 32) ? Uint32Array : e3 <= Number.MAX_SAFE_INTEGER ? b : null : null;
            class b extends Array {
              constructor(e3) {
                super(e3), this.fill(0);
              }
            }
            class g {
              constructor(e3) {
                if (0 === e3)
                  return [];
                const t2 = p(e3);
                this.heap = new t2(e3), this.length = 0;
              }
              push(e3) {
                this.heap[this.length++] = e3;
              }
              pop() {
                return this.heap[--this.length];
              }
            }
            class m {
              constructor(e3 = {}) {
                const { max: t2 = 0, ttl: r3, ttlResolution: n2 = 1, ttlAutopurge: i2, updateAgeOnGet: s2, updateAgeOnHas: o2, allowStale: u2, dispose: f2, disposeAfter: b2, noDisposeOnSet: y, noUpdateTTL: _, maxSize: w = 0, maxEntrySize: v = 0, sizeCalculation: S, fetchMethod: E, fetchContext: A, noDeleteOnFetchRejection: k, noDeleteOnStaleGet: T, allowStaleOnFetchRejection: I, allowStaleOnFetchAbort: R, ignoreFetchAbort: O } = e3, { length: C, maxAge: P, stale: x } = e3 instanceof m ? {} : e3;
                if (0 !== t2 && !d(t2))
                  throw new TypeError("max option must be a nonnegative integer");
                const M = t2 ? p(t2) : Array;
                if (!M)
                  throw new Error("invalid max value: " + t2);
                if (this.max = t2, this.maxSize = w, this.maxEntrySize = v || this.maxSize, this.sizeCalculation = S || C, this.sizeCalculation) {
                  if (!this.maxSize && !this.maxEntrySize)
                    throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
                  if ("function" != typeof this.sizeCalculation)
                    throw new TypeError("sizeCalculation set to non-function");
                }
                if (this.fetchMethod = E || null, this.fetchMethod && "function" != typeof this.fetchMethod)
                  throw new TypeError("fetchMethod must be a function if specified");
                if (this.fetchContext = A, !this.fetchMethod && void 0 !== A)
                  throw new TypeError("cannot set fetchContext without fetchMethod");
                if (this.keyMap = /* @__PURE__ */ new Map(), this.keyList = new Array(t2).fill(null), this.valList = new Array(t2).fill(null), this.next = new M(t2), this.prev = new M(t2), this.head = 0, this.tail = 0, this.free = new g(t2), this.initialFill = 1, this.size = 0, "function" == typeof f2 && (this.dispose = f2), "function" == typeof b2 ? (this.disposeAfter = b2, this.disposed = []) : (this.disposeAfter = null, this.disposed = null), this.noDisposeOnSet = !!y, this.noUpdateTTL = !!_, this.noDeleteOnFetchRejection = !!k, this.allowStaleOnFetchRejection = !!I, this.allowStaleOnFetchAbort = !!R, this.ignoreFetchAbort = !!O, 0 !== this.maxEntrySize) {
                  if (0 !== this.maxSize && !d(this.maxSize))
                    throw new TypeError("maxSize must be a positive integer if specified");
                  if (!d(this.maxEntrySize))
                    throw new TypeError("maxEntrySize must be a positive integer if specified");
                  this.initializeSizeTracking();
                }
                if (this.allowStale = !!u2 || !!x, this.noDeleteOnStaleGet = !!T, this.updateAgeOnGet = !!s2, this.updateAgeOnHas = !!o2, this.ttlResolution = d(n2) || 0 === n2 ? n2 : 1, this.ttlAutopurge = !!i2, this.ttl = r3 || P || 0, this.ttl) {
                  if (!d(this.ttl))
                    throw new TypeError("ttl must be a positive integer if specified");
                  this.initializeTTLTracking();
                }
                if (0 === this.max && 0 === this.ttl && 0 === this.maxSize)
                  throw new TypeError("At least one of max, maxSize, or ttl is required");
                if (!this.ttlAutopurge && !this.max && !this.maxSize) {
                  const e4 = "LRU_CACHE_UNBOUNDED";
                  if (h(e4)) {
                    a.add(e4);
                    c("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", e4, m);
                  }
                }
                x && l("stale", "allowStale"), P && l("maxAge", "ttl"), C && l("length", "sizeCalculation");
              }
              getRemainingTTL(e3) {
                return this.has(e3, { updateAgeOnHas: false }) ? 1 / 0 : 0;
              }
              initializeTTLTracking() {
                this.ttls = new b(this.max), this.starts = new b(this.max), this.setItemTTL = (e4, t3, n2 = r2.now()) => {
                  if (this.starts[e4] = 0 !== t3 ? n2 : 0, this.ttls[e4] = t3, 0 !== t3 && this.ttlAutopurge) {
                    const r3 = setTimeout(() => {
                      this.isStale(e4) && this.delete(this.keyList[e4]);
                    }, t3 + 1);
                    r3.unref && r3.unref();
                  }
                }, this.updateItemAge = (e4) => {
                  this.starts[e4] = 0 !== this.ttls[e4] ? r2.now() : 0;
                }, this.statusTTL = (r3, n2) => {
                  r3 && (r3.ttl = this.ttls[n2], r3.start = this.starts[n2], r3.now = e3 || t2(), r3.remainingTTL = r3.now + r3.ttl - r3.start);
                };
                let e3 = 0;
                const t2 = () => {
                  const t3 = r2.now();
                  if (this.ttlResolution > 0) {
                    e3 = t3;
                    const r3 = setTimeout(() => e3 = 0, this.ttlResolution);
                    r3.unref && r3.unref();
                  }
                  return t3;
                };
                this.getRemainingTTL = (r3) => {
                  const n2 = this.keyMap.get(r3);
                  return void 0 === n2 ? 0 : 0 === this.ttls[n2] || 0 === this.starts[n2] ? 1 / 0 : this.starts[n2] + this.ttls[n2] - (e3 || t2());
                }, this.isStale = (r3) => 0 !== this.ttls[r3] && 0 !== this.starts[r3] && (e3 || t2()) - this.starts[r3] > this.ttls[r3];
              }
              updateItemAge(e3) {
              }
              statusTTL(e3, t2) {
              }
              setItemTTL(e3, t2, r3) {
              }
              isStale(e3) {
                return false;
              }
              initializeSizeTracking() {
                this.calculatedSize = 0, this.sizes = new b(this.max), this.removeItemSize = (e3) => {
                  this.calculatedSize -= this.sizes[e3], this.sizes[e3] = 0;
                }, this.requireSize = (e3, t2, r3, n2) => {
                  if (this.isBackgroundFetch(t2))
                    return 0;
                  if (!d(r3)) {
                    if (!n2)
                      throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
                    if ("function" != typeof n2)
                      throw new TypeError("sizeCalculation must be a function");
                    if (r3 = n2(t2, e3), !d(r3))
                      throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                  }
                  return r3;
                }, this.addItemSize = (e3, t2, r3) => {
                  if (this.sizes[e3] = t2, this.maxSize) {
                    const t3 = this.maxSize - this.sizes[e3];
                    for (; this.calculatedSize > t3; )
                      this.evict(true);
                  }
                  this.calculatedSize += this.sizes[e3], r3 && (r3.entrySize = t2, r3.totalCalculatedSize = this.calculatedSize);
                };
              }
              removeItemSize(e3) {
              }
              addItemSize(e3, t2) {
              }
              requireSize(e3, t2, r3, n2) {
                if (r3 || n2)
                  throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
              }
              *indexes({ allowStale: e3 = this.allowStale } = {}) {
                if (this.size)
                  for (let t2 = this.tail; this.isValidIndex(t2) && (!e3 && this.isStale(t2) || (yield t2), t2 !== this.head); )
                    t2 = this.prev[t2];
              }
              *rindexes({ allowStale: e3 = this.allowStale } = {}) {
                if (this.size)
                  for (let t2 = this.head; this.isValidIndex(t2) && (!e3 && this.isStale(t2) || (yield t2), t2 !== this.tail); )
                    t2 = this.next[t2];
              }
              isValidIndex(e3) {
                return void 0 !== e3 && this.keyMap.get(this.keyList[e3]) === e3;
              }
              *entries() {
                for (const e3 of this.indexes())
                  void 0 === this.valList[e3] || void 0 === this.keyList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield [this.keyList[e3], this.valList[e3]]);
              }
              *rentries() {
                for (const e3 of this.rindexes())
                  void 0 === this.valList[e3] || void 0 === this.keyList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield [this.keyList[e3], this.valList[e3]]);
              }
              *keys() {
                for (const e3 of this.indexes())
                  void 0 === this.keyList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield this.keyList[e3]);
              }
              *rkeys() {
                for (const e3 of this.rindexes())
                  void 0 === this.keyList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield this.keyList[e3]);
              }
              *values() {
                for (const e3 of this.indexes())
                  void 0 === this.valList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield this.valList[e3]);
              }
              *rvalues() {
                for (const e3 of this.rindexes())
                  void 0 === this.valList[e3] || this.isBackgroundFetch(this.valList[e3]) || (yield this.valList[e3]);
              }
              [Symbol.iterator]() {
                return this.entries();
              }
              find(e3, t2) {
                for (const r3 of this.indexes()) {
                  const n2 = this.valList[r3], i2 = this.isBackgroundFetch(n2) ? n2.__staleWhileFetching : n2;
                  if (void 0 !== i2 && e3(i2, this.keyList[r3], this))
                    return this.get(this.keyList[r3], t2);
                }
              }
              forEach(e3, t2 = this) {
                for (const r3 of this.indexes()) {
                  const n2 = this.valList[r3], i2 = this.isBackgroundFetch(n2) ? n2.__staleWhileFetching : n2;
                  void 0 !== i2 && e3.call(t2, i2, this.keyList[r3], this);
                }
              }
              rforEach(e3, t2 = this) {
                for (const r3 of this.rindexes()) {
                  const n2 = this.valList[r3], i2 = this.isBackgroundFetch(n2) ? n2.__staleWhileFetching : n2;
                  void 0 !== i2 && e3.call(t2, i2, this.keyList[r3], this);
                }
              }
              get prune() {
                return u("prune", "purgeStale"), this.purgeStale;
              }
              purgeStale() {
                let e3 = false;
                for (const t2 of this.rindexes({ allowStale: true }))
                  this.isStale(t2) && (this.delete(this.keyList[t2]), e3 = true);
                return e3;
              }
              dump() {
                const e3 = [];
                for (const t2 of this.indexes({ allowStale: true })) {
                  const n2 = this.keyList[t2], i2 = this.valList[t2], s2 = this.isBackgroundFetch(i2) ? i2.__staleWhileFetching : i2;
                  if (void 0 === s2)
                    continue;
                  const o2 = { value: s2 };
                  if (this.ttls) {
                    o2.ttl = this.ttls[t2];
                    const e4 = r2.now() - this.starts[t2];
                    o2.start = Math.floor(Date.now() - e4);
                  }
                  this.sizes && (o2.size = this.sizes[t2]), e3.unshift([n2, o2]);
                }
                return e3;
              }
              load(e3) {
                this.clear();
                for (const [t2, n2] of e3) {
                  if (n2.start) {
                    const e4 = Date.now() - n2.start;
                    n2.start = r2.now() - e4;
                  }
                  this.set(t2, n2.value, n2);
                }
              }
              dispose(e3, t2, r3) {
              }
              set(e3, t2, { ttl: r3 = this.ttl, start: n2, noDisposeOnSet: i2 = this.noDisposeOnSet, size: s2 = 0, sizeCalculation: o2 = this.sizeCalculation, noUpdateTTL: a2 = this.noUpdateTTL, status: l2 } = {}) {
                if (s2 = this.requireSize(e3, t2, s2, o2), this.maxEntrySize && s2 > this.maxEntrySize)
                  return l2 && (l2.set = "miss", l2.maxEntrySizeExceeded = true), this.delete(e3), this;
                let u2 = 0 === this.size ? void 0 : this.keyMap.get(e3);
                if (void 0 === u2)
                  u2 = this.newIndex(), this.keyList[u2] = e3, this.valList[u2] = t2, this.keyMap.set(e3, u2), this.next[this.tail] = u2, this.prev[u2] = this.tail, this.tail = u2, this.size++, this.addItemSize(u2, s2, l2), l2 && (l2.set = "add"), a2 = false;
                else {
                  this.moveToTail(u2);
                  const r4 = this.valList[u2];
                  if (t2 !== r4) {
                    if (this.isBackgroundFetch(r4) ? r4.__abortController.abort(new Error("replaced")) : i2 || (this.dispose(r4, e3, "set"), this.disposeAfter && this.disposed.push([r4, e3, "set"])), this.removeItemSize(u2), this.valList[u2] = t2, this.addItemSize(u2, s2, l2), l2) {
                      l2.set = "replace";
                      const e4 = r4 && this.isBackgroundFetch(r4) ? r4.__staleWhileFetching : r4;
                      void 0 !== e4 && (l2.oldValue = e4);
                    }
                  } else
                    l2 && (l2.set = "update");
                }
                if (0 === r3 || 0 !== this.ttl || this.ttls || this.initializeTTLTracking(), a2 || this.setItemTTL(u2, r3, n2), this.statusTTL(l2, u2), this.disposeAfter)
                  for (; this.disposed.length; )
                    this.disposeAfter(...this.disposed.shift());
                return this;
              }
              newIndex() {
                return 0 === this.size ? this.tail : this.size === this.max && 0 !== this.max ? this.evict(false) : 0 !== this.free.length ? this.free.pop() : this.initialFill++;
              }
              pop() {
                if (this.size) {
                  const e3 = this.valList[this.head];
                  return this.evict(true), e3;
                }
              }
              evict(e3) {
                const t2 = this.head, r3 = this.keyList[t2], n2 = this.valList[t2];
                return this.isBackgroundFetch(n2) ? n2.__abortController.abort(new Error("evicted")) : (this.dispose(n2, r3, "evict"), this.disposeAfter && this.disposed.push([n2, r3, "evict"])), this.removeItemSize(t2), e3 && (this.keyList[t2] = null, this.valList[t2] = null, this.free.push(t2)), this.head = this.next[t2], this.keyMap.delete(r3), this.size--, t2;
              }
              has(e3, { updateAgeOnHas: t2 = this.updateAgeOnHas, status: r3 } = {}) {
                const n2 = this.keyMap.get(e3);
                if (void 0 !== n2) {
                  if (!this.isStale(n2))
                    return t2 && this.updateItemAge(n2), r3 && (r3.has = "hit"), this.statusTTL(r3, n2), true;
                  r3 && (r3.has = "stale", this.statusTTL(r3, n2));
                } else
                  r3 && (r3.has = "miss");
                return false;
              }
              peek(e3, { allowStale: t2 = this.allowStale } = {}) {
                const r3 = this.keyMap.get(e3);
                if (void 0 !== r3 && (t2 || !this.isStale(r3))) {
                  const e4 = this.valList[r3];
                  return this.isBackgroundFetch(e4) ? e4.__staleWhileFetching : e4;
                }
              }
              backgroundFetch(e3, t2, r3, i2) {
                const s2 = void 0 === t2 ? void 0 : this.valList[t2];
                if (this.isBackgroundFetch(s2))
                  return s2;
                const o2 = new n();
                r3.signal && r3.signal.addEventListener("abort", () => o2.abort(r3.signal.reason));
                const a2 = { signal: o2.signal, options: r3, context: i2 }, l2 = (n2, i3 = false) => {
                  const { aborted: s3 } = o2.signal, l3 = r3.ignoreFetchAbort && void 0 !== n2;
                  return r3.status && (s3 && !i3 ? (r3.status.fetchAborted = true, r3.status.fetchError = o2.signal.reason, l3 && (r3.status.fetchAbortIgnored = true)) : r3.status.fetchResolved = true), !s3 || l3 || i3 ? (this.valList[t2] === c2 && (void 0 === n2 ? c2.__staleWhileFetching ? this.valList[t2] = c2.__staleWhileFetching : this.delete(e3) : (r3.status && (r3.status.fetchUpdated = true), this.set(e3, n2, a2.options))), n2) : u2(o2.signal.reason);
                }, u2 = (n2) => {
                  const { aborted: i3 } = o2.signal, s3 = i3 && r3.allowStaleOnFetchAbort, a3 = s3 || r3.allowStaleOnFetchRejection, l3 = a3 || r3.noDeleteOnFetchRejection;
                  if (this.valList[t2] === c2) {
                    !l3 || void 0 === c2.__staleWhileFetching ? this.delete(e3) : s3 || (this.valList[t2] = c2.__staleWhileFetching);
                  }
                  if (a3)
                    return r3.status && void 0 !== c2.__staleWhileFetching && (r3.status.returnedStale = true), c2.__staleWhileFetching;
                  if (c2.__returned === c2)
                    throw n2;
                };
                r3.status && (r3.status.fetchDispatched = true);
                const c2 = new Promise((t3, n2) => {
                  this.fetchMethod(e3, s2, a2).then((e4) => t3(e4), n2), o2.signal.addEventListener("abort", () => {
                    r3.ignoreFetchAbort && !r3.allowStaleOnFetchAbort || (t3(), r3.allowStaleOnFetchAbort && (t3 = (e4) => l2(e4, true)));
                  });
                }).then(l2, (e4) => (r3.status && (r3.status.fetchRejected = true, r3.status.fetchError = e4), u2(e4)));
                return c2.__abortController = o2, c2.__staleWhileFetching = s2, c2.__returned = null, void 0 === t2 ? (this.set(e3, c2, { ...a2.options, status: void 0 }), t2 = this.keyMap.get(e3)) : this.valList[t2] = c2, c2;
              }
              isBackgroundFetch(e3) {
                return e3 && "object" == typeof e3 && "function" == typeof e3.then && Object.prototype.hasOwnProperty.call(e3, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(e3, "__returned") && (e3.__returned === e3 || null === e3.__returned);
              }
              async fetch(e3, { allowStale: t2 = this.allowStale, updateAgeOnGet: r3 = this.updateAgeOnGet, noDeleteOnStaleGet: n2 = this.noDeleteOnStaleGet, ttl: i2 = this.ttl, noDisposeOnSet: s2 = this.noDisposeOnSet, size: o2 = 0, sizeCalculation: a2 = this.sizeCalculation, noUpdateTTL: l2 = this.noUpdateTTL, noDeleteOnFetchRejection: u2 = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: c2 = this.allowStaleOnFetchRejection, ignoreFetchAbort: h2 = this.ignoreFetchAbort, allowStaleOnFetchAbort: f2 = this.allowStaleOnFetchAbort, fetchContext: d2 = this.fetchContext, forceRefresh: p2 = false, status: b2, signal: g2 } = {}) {
                if (!this.fetchMethod)
                  return b2 && (b2.fetch = "get"), this.get(e3, { allowStale: t2, updateAgeOnGet: r3, noDeleteOnStaleGet: n2, status: b2 });
                const m2 = { allowStale: t2, updateAgeOnGet: r3, noDeleteOnStaleGet: n2, ttl: i2, noDisposeOnSet: s2, size: o2, sizeCalculation: a2, noUpdateTTL: l2, noDeleteOnFetchRejection: u2, allowStaleOnFetchRejection: c2, allowStaleOnFetchAbort: f2, ignoreFetchAbort: h2, status: b2, signal: g2 };
                let y = this.keyMap.get(e3);
                if (void 0 === y) {
                  b2 && (b2.fetch = "miss");
                  const t3 = this.backgroundFetch(e3, y, m2, d2);
                  return t3.__returned = t3;
                }
                {
                  const n3 = this.valList[y];
                  if (this.isBackgroundFetch(n3)) {
                    const e4 = t2 && void 0 !== n3.__staleWhileFetching;
                    return b2 && (b2.fetch = "inflight", e4 && (b2.returnedStale = true)), e4 ? n3.__staleWhileFetching : n3.__returned = n3;
                  }
                  const i3 = this.isStale(y);
                  if (!p2 && !i3)
                    return b2 && (b2.fetch = "hit"), this.moveToTail(y), r3 && this.updateItemAge(y), this.statusTTL(b2, y), n3;
                  const s3 = this.backgroundFetch(e3, y, m2, d2), o3 = void 0 !== s3.__staleWhileFetching, a3 = o3 && t2;
                  return b2 && (b2.fetch = o3 && i3 ? "stale" : "refresh", a3 && i3 && (b2.returnedStale = true)), a3 ? s3.__staleWhileFetching : s3.__returned = s3;
                }
              }
              get(e3, { allowStale: t2 = this.allowStale, updateAgeOnGet: r3 = this.updateAgeOnGet, noDeleteOnStaleGet: n2 = this.noDeleteOnStaleGet, status: i2 } = {}) {
                const s2 = this.keyMap.get(e3);
                if (void 0 !== s2) {
                  const o2 = this.valList[s2], a2 = this.isBackgroundFetch(o2);
                  return this.statusTTL(i2, s2), this.isStale(s2) ? (i2 && (i2.get = "stale"), a2 ? (i2 && (i2.returnedStale = t2 && void 0 !== o2.__staleWhileFetching), t2 ? o2.__staleWhileFetching : void 0) : (n2 || this.delete(e3), i2 && (i2.returnedStale = t2), t2 ? o2 : void 0)) : (i2 && (i2.get = "hit"), a2 ? o2.__staleWhileFetching : (this.moveToTail(s2), r3 && this.updateItemAge(s2), o2));
                }
                i2 && (i2.get = "miss");
              }
              connect(e3, t2) {
                this.prev[t2] = e3, this.next[e3] = t2;
              }
              moveToTail(e3) {
                e3 !== this.tail && (e3 === this.head ? this.head = this.next[e3] : this.connect(this.prev[e3], this.next[e3]), this.connect(this.tail, e3), this.tail = e3);
              }
              get del() {
                return u("del", "delete"), this.delete;
              }
              delete(e3) {
                let t2 = false;
                if (0 !== this.size) {
                  const r3 = this.keyMap.get(e3);
                  if (void 0 !== r3)
                    if (t2 = true, 1 === this.size)
                      this.clear();
                    else {
                      this.removeItemSize(r3);
                      const t3 = this.valList[r3];
                      this.isBackgroundFetch(t3) ? t3.__abortController.abort(new Error("deleted")) : (this.dispose(t3, e3, "delete"), this.disposeAfter && this.disposed.push([t3, e3, "delete"])), this.keyMap.delete(e3), this.keyList[r3] = null, this.valList[r3] = null, r3 === this.tail ? this.tail = this.prev[r3] : r3 === this.head ? this.head = this.next[r3] : (this.next[this.prev[r3]] = this.next[r3], this.prev[this.next[r3]] = this.prev[r3]), this.size--, this.free.push(r3);
                    }
                }
                if (this.disposed)
                  for (; this.disposed.length; )
                    this.disposeAfter(...this.disposed.shift());
                return t2;
              }
              clear() {
                for (const e3 of this.rindexes({ allowStale: true })) {
                  const t2 = this.valList[e3];
                  if (this.isBackgroundFetch(t2))
                    t2.__abortController.abort(new Error("deleted"));
                  else {
                    const r3 = this.keyList[e3];
                    this.dispose(t2, r3, "delete"), this.disposeAfter && this.disposed.push([t2, r3, "delete"]);
                  }
                }
                if (this.keyMap.clear(), this.valList.fill(null), this.keyList.fill(null), this.ttls && (this.ttls.fill(0), this.starts.fill(0)), this.sizes && this.sizes.fill(0), this.head = 0, this.tail = 0, this.initialFill = 1, this.free.length = 0, this.calculatedSize = 0, this.size = 0, this.disposed)
                  for (; this.disposed.length; )
                    this.disposeAfter(...this.disposed.shift());
              }
              get reset() {
                return u("reset", "clear"), this.clear;
              }
              get length() {
                return ((e3, t2) => {
                  const r3 = `LRU_CACHE_PROPERTY_${e3}`;
                  if (h(r3)) {
                    const { prototype: n2 } = m, { get: i2 } = Object.getOwnPropertyDescriptor(n2, e3);
                    f(r3, `${e3} property`, `cache.${t2}`, i2);
                  }
                })("length", "size"), this.size;
              }
              static get AbortController() {
                return n;
              }
              static get AbortSignal() {
                return o;
              }
            }
            t.exports = m;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 102 }], 73: [function(e, t, r) {
        const n = t.exports, { Buffer: i } = e("buffer");
        n.types = { 0: "reserved", 1: "connect", 2: "connack", 3: "publish", 4: "puback", 5: "pubrec", 6: "pubrel", 7: "pubcomp", 8: "subscribe", 9: "suback", 10: "unsubscribe", 11: "unsuback", 12: "pingreq", 13: "pingresp", 14: "disconnect", 15: "auth" }, n.requiredHeaderFlags = { 1: 0, 2: 0, 4: 0, 5: 0, 6: 2, 7: 0, 8: 2, 9: 0, 10: 2, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0 }, n.requiredHeaderFlagsErrors = {};
        for (const e2 in n.requiredHeaderFlags) {
          const t2 = n.requiredHeaderFlags[e2];
          n.requiredHeaderFlagsErrors[e2] = "Invalid header flag bits, must be 0x" + t2.toString(16) + " for " + n.types[e2] + " packet";
        }
        n.codes = {};
        for (const e2 in n.types) {
          const t2 = n.types[e2];
          n.codes[t2] = e2;
        }
        n.CMD_SHIFT = 4, n.CMD_MASK = 240, n.DUP_MASK = 8, n.QOS_MASK = 3, n.QOS_SHIFT = 1, n.RETAIN_MASK = 1, n.VARBYTEINT_MASK = 127, n.VARBYTEINT_FIN_MASK = 128, n.VARBYTEINT_MAX = 268435455, n.SESSIONPRESENT_MASK = 1, n.SESSIONPRESENT_HEADER = i.from([n.SESSIONPRESENT_MASK]), n.CONNACK_HEADER = i.from([n.codes.connack << n.CMD_SHIFT]), n.USERNAME_MASK = 128, n.PASSWORD_MASK = 64, n.WILL_RETAIN_MASK = 32, n.WILL_QOS_MASK = 24, n.WILL_QOS_SHIFT = 3, n.WILL_FLAG_MASK = 4, n.CLEAN_SESSION_MASK = 2, n.CONNECT_HEADER = i.from([n.codes.connect << n.CMD_SHIFT]), n.properties = { sessionExpiryInterval: 17, willDelayInterval: 24, receiveMaximum: 33, maximumPacketSize: 39, topicAliasMaximum: 34, requestResponseInformation: 25, requestProblemInformation: 23, userProperties: 38, authenticationMethod: 21, authenticationData: 22, payloadFormatIndicator: 1, messageExpiryInterval: 2, contentType: 3, responseTopic: 8, correlationData: 9, maximumQoS: 36, retainAvailable: 37, assignedClientIdentifier: 18, reasonString: 31, wildcardSubscriptionAvailable: 40, subscriptionIdentifiersAvailable: 41, sharedSubscriptionAvailable: 42, serverKeepAlive: 19, responseInformation: 26, serverReference: 28, topicAlias: 35, subscriptionIdentifier: 11 }, n.propertiesCodes = {};
        for (const e2 in n.properties) {
          const t2 = n.properties[e2];
          n.propertiesCodes[t2] = e2;
        }
        function s(e2) {
          return [0, 1, 2].map((t2) => [0, 1].map((r2) => [0, 1].map((s2) => {
            const o = i.alloc(1);
            return o.writeUInt8(n.codes[e2] << n.CMD_SHIFT | (r2 ? n.DUP_MASK : 0) | t2 << n.QOS_SHIFT | s2, 0, true), o;
          })));
        }
        n.propertiesTypes = { sessionExpiryInterval: "int32", willDelayInterval: "int32", receiveMaximum: "int16", maximumPacketSize: "int32", topicAliasMaximum: "int16", requestResponseInformation: "byte", requestProblemInformation: "byte", userProperties: "pair", authenticationMethod: "string", authenticationData: "binary", payloadFormatIndicator: "byte", messageExpiryInterval: "int32", contentType: "string", responseTopic: "string", correlationData: "binary", maximumQoS: "int8", retainAvailable: "byte", assignedClientIdentifier: "string", reasonString: "string", wildcardSubscriptionAvailable: "byte", subscriptionIdentifiersAvailable: "byte", sharedSubscriptionAvailable: "byte", serverKeepAlive: "int16", responseInformation: "string", serverReference: "string", topicAlias: "int16", subscriptionIdentifier: "var" }, n.PUBLISH_HEADER = s("publish"), n.SUBSCRIBE_HEADER = s("subscribe"), n.SUBSCRIBE_OPTIONS_QOS_MASK = 3, n.SUBSCRIBE_OPTIONS_NL_MASK = 1, n.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, n.SUBSCRIBE_OPTIONS_RAP_MASK = 1, n.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, n.SUBSCRIBE_OPTIONS_RH_MASK = 3, n.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, n.SUBSCRIBE_OPTIONS_RH = [0, 16, 32], n.SUBSCRIBE_OPTIONS_NL = 4, n.SUBSCRIBE_OPTIONS_RAP = 8, n.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2], n.UNSUBSCRIBE_HEADER = s("unsubscribe"), n.ACKS = { unsuback: s("unsuback"), puback: s("puback"), pubcomp: s("pubcomp"), pubrel: s("pubrel"), pubrec: s("pubrec") }, n.SUBACK_HEADER = i.from([n.codes.suback << n.CMD_SHIFT]), n.VERSION3 = i.from([3]), n.VERSION4 = i.from([4]), n.VERSION5 = i.from([5]), n.VERSION131 = i.from([131]), n.VERSION132 = i.from([132]), n.QOS = [0, 1, 2].map((e2) => i.from([e2])), n.EMPTY = { pingreq: i.from([n.codes.pingreq << 4, 0]), pingresp: i.from([n.codes.pingresp << 4, 0]), disconnect: i.from([n.codes.disconnect << 4, 0]) }, n.MQTT5_PUBACK_PUBREC_CODES = { 0: "Success", 16: "No matching subscribers", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 144: "Topic Name invalid", 145: "Packet identifier in use", 151: "Quota exceeded", 153: "Payload format invalid" }, n.MQTT5_PUBREL_PUBCOMP_CODES = { 0: "Success", 146: "Packet Identifier not found" }, n.MQTT5_SUBACK_CODES = { 0: "Granted QoS 0", 1: "Granted QoS 1", 2: "Granted QoS 2", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 143: "Topic Filter invalid", 145: "Packet Identifier in use", 151: "Quota exceeded", 158: "Shared Subscriptions not supported", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" }, n.MQTT5_UNSUBACK_CODES = { 0: "Success", 17: "No subscription existed", 128: "Unspecified error", 131: "Implementation specific error", 135: "Not authorized", 143: "Topic Filter invalid", 145: "Packet Identifier in use" }, n.MQTT5_DISCONNECT_CODES = { 0: "Normal disconnection", 4: "Disconnect with Will Message", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 135: "Not authorized", 137: "Server busy", 139: "Server shutting down", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" }, n.MQTT5_AUTH_CODES = { 0: "Success", 24: "Continue authentication", 25: "Re-authenticate" };
      }, { buffer: 29 }], 74: [function(e, t, r) {
        const n = e("./writeToStream"), i = e("events"), { Buffer: s } = e("buffer");
        class o extends i {
          constructor() {
            super(), this._array = new Array(20), this._i = 0;
          }
          write(e2) {
            return this._array[this._i++] = e2, true;
          }
          concat() {
            let e2 = 0;
            const t2 = new Array(this._array.length), r2 = this._array;
            let n2, i2 = 0;
            for (n2 = 0; n2 < r2.length && void 0 !== r2[n2]; n2++)
              "string" != typeof r2[n2] ? t2[n2] = r2[n2].length : t2[n2] = s.byteLength(r2[n2]), e2 += t2[n2];
            const o2 = s.allocUnsafe(e2);
            for (n2 = 0; n2 < r2.length && void 0 !== r2[n2]; n2++)
              "string" != typeof r2[n2] ? (r2[n2].copy(o2, i2), i2 += t2[n2]) : (o2.write(r2[n2], i2), i2 += t2[n2]);
            return o2;
          }
          destroy(e2) {
            e2 && this.emit("error", e2);
          }
        }
        t.exports = function(e2, t2) {
          const r2 = new o();
          return n(e2, r2, t2), r2.concat();
        };
      }, { "./writeToStream": 96, buffer: 29, events: 49 }], 75: [function(e, t, r) {
        r.parser = e("./parser").parser, r.generate = e("./generate"), r.writeToStream = e("./writeToStream");
      }, { "./generate": 74, "./parser": 95, "./writeToStream": 96 }], 76: [function(e, t, r) {
        "use strict";
        const { Buffer: n } = e("buffer"), i = Symbol.for("BufferList");
        function s(e2) {
          if (!(this instanceof s))
            return new s(e2);
          s._init.call(this, e2);
        }
        s._init = function(e2) {
          Object.defineProperty(this, i, { value: true }), this._bufs = [], this.length = 0, e2 && this.append(e2);
        }, s.prototype._new = function(e2) {
          return new s(e2);
        }, s.prototype._offset = function(e2) {
          if (0 === e2)
            return [0, 0];
          let t2 = 0;
          for (let r2 = 0; r2 < this._bufs.length; r2++) {
            const n2 = t2 + this._bufs[r2].length;
            if (e2 < n2 || r2 === this._bufs.length - 1)
              return [r2, e2 - t2];
            t2 = n2;
          }
        }, s.prototype._reverseOffset = function(e2) {
          const t2 = e2[0];
          let r2 = e2[1];
          for (let e3 = 0; e3 < t2; e3++)
            r2 += this._bufs[e3].length;
          return r2;
        }, s.prototype.get = function(e2) {
          if (e2 > this.length || e2 < 0)
            return;
          const t2 = this._offset(e2);
          return this._bufs[t2[0]][t2[1]];
        }, s.prototype.slice = function(e2, t2) {
          return "number" == typeof e2 && e2 < 0 && (e2 += this.length), "number" == typeof t2 && t2 < 0 && (t2 += this.length), this.copy(null, 0, e2, t2);
        }, s.prototype.copy = function(e2, t2, r2, i2) {
          if (("number" != typeof r2 || r2 < 0) && (r2 = 0), ("number" != typeof i2 || i2 > this.length) && (i2 = this.length), r2 >= this.length)
            return e2 || n.alloc(0);
          if (i2 <= 0)
            return e2 || n.alloc(0);
          const s2 = !!e2, o = this._offset(r2), a = i2 - r2;
          let l = a, u = s2 && t2 || 0, c = o[1];
          if (0 === r2 && i2 === this.length) {
            if (!s2)
              return 1 === this._bufs.length ? this._bufs[0] : n.concat(this._bufs, this.length);
            for (let t3 = 0; t3 < this._bufs.length; t3++)
              this._bufs[t3].copy(e2, u), u += this._bufs[t3].length;
            return e2;
          }
          if (l <= this._bufs[o[0]].length - c)
            return s2 ? this._bufs[o[0]].copy(e2, t2, c, c + l) : this._bufs[o[0]].slice(c, c + l);
          s2 || (e2 = n.allocUnsafe(a));
          for (let t3 = o[0]; t3 < this._bufs.length; t3++) {
            const r3 = this._bufs[t3].length - c;
            if (!(l > r3)) {
              this._bufs[t3].copy(e2, u, c, c + l), u += r3;
              break;
            }
            this._bufs[t3].copy(e2, u, c), u += r3, l -= r3, c && (c = 0);
          }
          return e2.length > u ? e2.slice(0, u) : e2;
        }, s.prototype.shallowSlice = function(e2, t2) {
          if (e2 = e2 || 0, t2 = "number" != typeof t2 ? this.length : t2, e2 < 0 && (e2 += this.length), t2 < 0 && (t2 += this.length), e2 === t2)
            return this._new();
          const r2 = this._offset(e2), n2 = this._offset(t2), i2 = this._bufs.slice(r2[0], n2[0] + 1);
          return 0 === n2[1] ? i2.pop() : i2[i2.length - 1] = i2[i2.length - 1].slice(0, n2[1]), 0 !== r2[1] && (i2[0] = i2[0].slice(r2[1])), this._new(i2);
        }, s.prototype.toString = function(e2, t2, r2) {
          return this.slice(t2, r2).toString(e2);
        }, s.prototype.consume = function(e2) {
          if (e2 = Math.trunc(e2), Number.isNaN(e2) || e2 <= 0)
            return this;
          for (; this._bufs.length; ) {
            if (!(e2 >= this._bufs[0].length)) {
              this._bufs[0] = this._bufs[0].slice(e2), this.length -= e2;
              break;
            }
            e2 -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
          }
          return this;
        }, s.prototype.duplicate = function() {
          const e2 = this._new();
          for (let t2 = 0; t2 < this._bufs.length; t2++)
            e2.append(this._bufs[t2]);
          return e2;
        }, s.prototype.append = function(e2) {
          if (null == e2)
            return this;
          if (e2.buffer)
            this._appendBuffer(n.from(e2.buffer, e2.byteOffset, e2.byteLength));
          else if (Array.isArray(e2))
            for (let t2 = 0; t2 < e2.length; t2++)
              this.append(e2[t2]);
          else if (this._isBufferList(e2))
            for (let t2 = 0; t2 < e2._bufs.length; t2++)
              this.append(e2._bufs[t2]);
          else
            "number" == typeof e2 && (e2 = e2.toString()), this._appendBuffer(n.from(e2));
          return this;
        }, s.prototype._appendBuffer = function(e2) {
          this._bufs.push(e2), this.length += e2.length;
        }, s.prototype.indexOf = function(e2, t2, r2) {
          if (void 0 === r2 && "string" == typeof t2 && (r2 = t2, t2 = void 0), "function" == typeof e2 || Array.isArray(e2))
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
          if ("number" == typeof e2 ? e2 = n.from([e2]) : "string" == typeof e2 ? e2 = n.from(e2, r2) : this._isBufferList(e2) ? e2 = e2.slice() : Array.isArray(e2.buffer) ? e2 = n.from(e2.buffer, e2.byteOffset, e2.byteLength) : n.isBuffer(e2) || (e2 = n.from(e2)), t2 = Number(t2 || 0), isNaN(t2) && (t2 = 0), t2 < 0 && (t2 = this.length + t2), t2 < 0 && (t2 = 0), 0 === e2.length)
            return t2 > this.length ? this.length : t2;
          const i2 = this._offset(t2);
          let s2 = i2[0], o = i2[1];
          for (; s2 < this._bufs.length; s2++) {
            const t3 = this._bufs[s2];
            for (; o < t3.length; ) {
              if (t3.length - o >= e2.length) {
                const r3 = t3.indexOf(e2, o);
                if (-1 !== r3)
                  return this._reverseOffset([s2, r3]);
                o = t3.length - e2.length + 1;
              } else {
                const t4 = this._reverseOffset([s2, o]);
                if (this._match(t4, e2))
                  return t4;
                o++;
              }
            }
            o = 0;
          }
          return -1;
        }, s.prototype._match = function(e2, t2) {
          if (this.length - e2 < t2.length)
            return false;
          for (let r2 = 0; r2 < t2.length; r2++)
            if (this.get(e2 + r2) !== t2[r2])
              return false;
          return true;
        }, function() {
          const e2 = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
          for (const t2 in e2)
            !function(t3) {
              s.prototype[t3] = null === e2[t3] ? function(e3, r2) {
                return this.slice(e3, e3 + r2)[t3](0, r2);
              } : function(r2 = 0) {
                return this.slice(r2, r2 + e2[t3])[t3](0);
              };
            }(t2);
        }(), s.prototype._isBufferList = function(e2) {
          return e2 instanceof s || s.isBufferList(e2);
        }, s.isBufferList = function(e2) {
          return null != e2 && e2[i];
        }, t.exports = s;
      }, { buffer: 29 }], 77: [function(e, t, r) {
        "use strict";
        const n = e("readable-stream").Duplex, i = e("inherits"), s = e("./BufferList");
        function o(e2) {
          if (!(this instanceof o))
            return new o(e2);
          if ("function" == typeof e2) {
            this._callback = e2;
            const t2 = (function(e3) {
              this._callback && (this._callback(e3), this._callback = null);
            }).bind(this);
            this.on("pipe", function(e3) {
              e3.on("error", t2);
            }), this.on("unpipe", function(e3) {
              e3.removeListener("error", t2);
            }), e2 = null;
          }
          s._init.call(this, e2), n.call(this);
        }
        i(o, n), Object.assign(o.prototype, s.prototype), o.prototype._new = function(e2) {
          return new o(e2);
        }, o.prototype._write = function(e2, t2, r2) {
          this._appendBuffer(e2), "function" == typeof r2 && r2();
        }, o.prototype._read = function(e2) {
          if (!this.length)
            return this.push(null);
          e2 = Math.min(e2, this.length), this.push(this.slice(0, e2)), this.consume(e2);
        }, o.prototype.end = function(e2) {
          n.prototype.end.call(this, e2), this._callback && (this._callback(null, this.slice()), this._callback = null);
        }, o.prototype._destroy = function(e2, t2) {
          this._bufs.length = 0, this.length = 0, t2(e2);
        }, o.prototype._isBufferList = function(e2) {
          return e2 instanceof o || e2 instanceof s || o.isBufferList(e2);
        }, o.isBufferList = s.isBufferList, t.exports = o, t.exports.BufferListStream = o, t.exports.BufferList = s;
      }, { "./BufferList": 76, inherits: 51, "readable-stream": 92 }], 78: [function(e, t, r) {
        arguments[4][33][0].apply(r, arguments);
      }, { dup: 33 }], 79: [function(e, t, r) {
        arguments[4][34][0].apply(r, arguments);
      }, { "./_stream_readable": 81, "./_stream_writable": 83, _process: 102, dup: 34, inherits: 51 }], 80: [function(e, t, r) {
        arguments[4][35][0].apply(r, arguments);
      }, { "./_stream_transform": 82, dup: 35, inherits: 51 }], 81: [function(e, t, r) {
        arguments[4][36][0].apply(r, arguments);
      }, { "../errors": 78, "./_stream_duplex": 79, "./internal/streams/async_iterator": 84, "./internal/streams/buffer_list": 85, "./internal/streams/destroy": 86, "./internal/streams/from": 88, "./internal/streams/state": 90, "./internal/streams/stream": 91, _process: 102, buffer: 29, dup: 36, events: 49, inherits: 51, "string_decoder/": 136, util: 26 }], 82: [function(e, t, r) {
        arguments[4][37][0].apply(r, arguments);
      }, { "../errors": 78, "./_stream_duplex": 79, dup: 37, inherits: 51 }], 83: [function(e, t, r) {
        arguments[4][38][0].apply(r, arguments);
      }, { "../errors": 78, "./_stream_duplex": 79, "./internal/streams/destroy": 86, "./internal/streams/state": 90, "./internal/streams/stream": 91, _process: 102, buffer: 29, dup: 38, inherits: 51, "util-deprecate": 139 }], 84: [function(e, t, r) {
        arguments[4][39][0].apply(r, arguments);
      }, { "./end-of-stream": 87, _process: 102, dup: 39 }], 85: [function(e, t, r) {
        arguments[4][40][0].apply(r, arguments);
      }, { buffer: 29, dup: 40, util: 26 }], 86: [function(e, t, r) {
        arguments[4][41][0].apply(r, arguments);
      }, { _process: 102, dup: 41 }], 87: [function(e, t, r) {
        arguments[4][42][0].apply(r, arguments);
      }, { "../../../errors": 78, dup: 42 }], 88: [function(e, t, r) {
        arguments[4][43][0].apply(r, arguments);
      }, { dup: 43 }], 89: [function(e, t, r) {
        arguments[4][44][0].apply(r, arguments);
      }, { "../../../errors": 78, "./end-of-stream": 87, dup: 44 }], 90: [function(e, t, r) {
        arguments[4][45][0].apply(r, arguments);
      }, { "../../../errors": 78, dup: 45 }], 91: [function(e, t, r) {
        arguments[4][46][0].apply(r, arguments);
      }, { dup: 46, events: 49 }], 92: [function(e, t, r) {
        arguments[4][47][0].apply(r, arguments);
      }, { "./lib/_stream_duplex.js": 79, "./lib/_stream_passthrough.js": 80, "./lib/_stream_readable.js": 81, "./lib/_stream_transform.js": 82, "./lib/_stream_writable.js": 83, "./lib/internal/streams/end-of-stream.js": 87, "./lib/internal/streams/pipeline.js": 89, dup: 47 }], 93: [function(e, t, r) {
        const { Buffer: n } = e("buffer"), i = {}, s = n.isBuffer(n.from([1, 2]).subarray(0, 1));
        function o(e2) {
          const t2 = n.allocUnsafe(2);
          return t2.writeUInt8(e2 >> 8, 0), t2.writeUInt8(255 & e2, 1), t2;
        }
        t.exports = { cache: i, generateCache: function() {
          for (let e2 = 0; e2 < 65536; e2++)
            i[e2] = o(e2);
        }, generateNumber: o, genBufVariableByteInt: function(e2) {
          let t2 = 0, r2 = 0;
          const i2 = n.allocUnsafe(4);
          do {
            t2 = e2 % 128 | 0, (e2 = e2 / 128 | 0) > 0 && (t2 |= 128), i2.writeUInt8(t2, r2++);
          } while (e2 > 0 && r2 < 4);
          return e2 > 0 && (r2 = 0), s ? i2.subarray(0, r2) : i2.slice(0, r2);
        }, generate4ByteBuffer: function(e2) {
          const t2 = n.allocUnsafe(4);
          return t2.writeUInt32BE(e2, 0), t2;
        } };
      }, { buffer: 29 }], 94: [function(e, t, r) {
        t.exports = class {
          constructor() {
            this.cmd = null, this.retain = false, this.qos = 0, this.dup = false, this.length = -1, this.topic = null, this.payload = null;
          }
        };
      }, {}], 95: [function(e, t, r) {
        const n = e("bl"), i = e("events"), s = e("./packet"), o = e("./constants"), a = e("debug")("mqtt-packet:parser");
        class l extends i {
          constructor() {
            super(), this.parser = this.constructor.parser;
          }
          static parser(e2) {
            return this instanceof l ? (this.settings = e2 || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new l().parser(e2);
          }
          _resetState() {
            a("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new s(), this.error = null, this._list = n(), this._stateCounter = 0;
          }
          parse(e2) {
            for (this.error && this._resetState(), this._list.append(e2), a("parse: current state: %s", this._states[this._stateCounter]); (-1 !== this.packet.length || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; )
              this._stateCounter++, a("parse: state complete. _stateCounter is now: %d", this._stateCounter), a("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
            return a("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
          }
          _parseHeader() {
            const e2 = this._list.readUInt8(0), t2 = e2 >> o.CMD_SHIFT;
            this.packet.cmd = o.types[t2];
            const r2 = 15 & e2, n2 = o.requiredHeaderFlags[t2];
            return null != n2 && r2 !== n2 ? this._emitError(new Error(o.requiredHeaderFlagsErrors[t2])) : (this.packet.retain = 0 != (e2 & o.RETAIN_MASK), this.packet.qos = e2 >> o.QOS_SHIFT & o.QOS_MASK, this.packet.qos > 2 ? this._emitError(new Error("Packet must not have both QoS bits set to 1")) : (this.packet.dup = 0 != (e2 & o.DUP_MASK), a("_parseHeader: packet: %o", this.packet), this._list.consume(1), true));
          }
          _parseLength() {
            const e2 = this._parseVarByteNum(true);
            return e2 && (this.packet.length = e2.value, this._list.consume(e2.bytes)), a("_parseLength %d", e2.value), !!e2;
          }
          _parsePayload() {
            a("_parsePayload: payload %O", this._list);
            let e2 = false;
            if (0 === this.packet.length || this._list.length >= this.packet.length) {
              switch (this._pos = 0, this.packet.cmd) {
                case "connect":
                  this._parseConnect();
                  break;
                case "connack":
                  this._parseConnack();
                  break;
                case "publish":
                  this._parsePublish();
                  break;
                case "puback":
                case "pubrec":
                case "pubrel":
                case "pubcomp":
                  this._parseConfirmation();
                  break;
                case "subscribe":
                  this._parseSubscribe();
                  break;
                case "suback":
                  this._parseSuback();
                  break;
                case "unsubscribe":
                  this._parseUnsubscribe();
                  break;
                case "unsuback":
                  this._parseUnsuback();
                  break;
                case "pingreq":
                case "pingresp":
                  break;
                case "disconnect":
                  this._parseDisconnect();
                  break;
                case "auth":
                  this._parseAuth();
                  break;
                default:
                  this._emitError(new Error("Not supported"));
              }
              e2 = true;
            }
            return a("_parsePayload complete result: %s", e2), e2;
          }
          _parseConnect() {
            let e2, t2, r2, n2;
            a("_parseConnect");
            const i2 = {}, s2 = this.packet, l2 = this._parseString();
            if (null === l2)
              return this._emitError(new Error("Cannot parse protocolId"));
            if ("MQTT" !== l2 && "MQIsdp" !== l2)
              return this._emitError(new Error("Invalid protocolId"));
            if (s2.protocolId = l2, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (s2.protocolVersion = this._list.readUInt8(this._pos), s2.protocolVersion >= 128 && (s2.bridgeMode = true, s2.protocolVersion = s2.protocolVersion - 128), 3 !== s2.protocolVersion && 4 !== s2.protocolVersion && 5 !== s2.protocolVersion)
              return this._emitError(new Error("Invalid protocol version"));
            if (this._pos++, this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            if (1 & this._list.readUInt8(this._pos))
              return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
            i2.username = this._list.readUInt8(this._pos) & o.USERNAME_MASK, i2.password = this._list.readUInt8(this._pos) & o.PASSWORD_MASK, i2.will = this._list.readUInt8(this._pos) & o.WILL_FLAG_MASK;
            const u = !!(this._list.readUInt8(this._pos) & o.WILL_RETAIN_MASK), c = (this._list.readUInt8(this._pos) & o.WILL_QOS_MASK) >> o.WILL_QOS_SHIFT;
            if (i2.will)
              s2.will = {}, s2.will.retain = u, s2.will.qos = c;
            else {
              if (u)
                return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
              if (c)
                return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
            }
            if (s2.clean = 0 != (this._list.readUInt8(this._pos) & o.CLEAN_SESSION_MASK), this._pos++, s2.keepalive = this._parseNum(), -1 === s2.keepalive)
              return this._emitError(new Error("Packet too short"));
            if (5 === s2.protocolVersion) {
              const e3 = this._parseProperties();
              Object.getOwnPropertyNames(e3).length && (s2.properties = e3);
            }
            const h = this._parseString();
            if (null === h)
              return this._emitError(new Error("Packet too short"));
            if (s2.clientId = h, a("_parseConnect: packet.clientId: %s", s2.clientId), i2.will) {
              if (5 === s2.protocolVersion) {
                const e3 = this._parseProperties();
                Object.getOwnPropertyNames(e3).length && (s2.will.properties = e3);
              }
              if (e2 = this._parseString(), null === e2)
                return this._emitError(new Error("Cannot parse will topic"));
              if (s2.will.topic = e2, a("_parseConnect: packet.will.topic: %s", s2.will.topic), t2 = this._parseBuffer(), null === t2)
                return this._emitError(new Error("Cannot parse will payload"));
              s2.will.payload = t2, a("_parseConnect: packet.will.paylaod: %s", s2.will.payload);
            }
            if (i2.username) {
              if (n2 = this._parseString(), null === n2)
                return this._emitError(new Error("Cannot parse username"));
              s2.username = n2, a("_parseConnect: packet.username: %s", s2.username);
            }
            if (i2.password) {
              if (r2 = this._parseBuffer(), null === r2)
                return this._emitError(new Error("Cannot parse password"));
              s2.password = r2;
            }
            return this.settings = s2, a("_parseConnect: complete"), s2;
          }
          _parseConnack() {
            a("_parseConnack");
            const e2 = this.packet;
            if (this._list.length < 1)
              return null;
            const t2 = this._list.readUInt8(this._pos++);
            if (t2 > 1)
              return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
            if (e2.sessionPresent = !!(t2 & o.SESSIONPRESENT_MASK), 5 === this.settings.protocolVersion)
              this._list.length >= 2 ? e2.reasonCode = this._list.readUInt8(this._pos++) : e2.reasonCode = 0;
            else {
              if (this._list.length < 2)
                return null;
              e2.returnCode = this._list.readUInt8(this._pos++);
            }
            if (-1 === e2.returnCode || -1 === e2.reasonCode)
              return this._emitError(new Error("Cannot parse return code"));
            if (5 === this.settings.protocolVersion) {
              const t3 = this._parseProperties();
              Object.getOwnPropertyNames(t3).length && (e2.properties = t3);
            }
            a("_parseConnack: complete");
          }
          _parsePublish() {
            a("_parsePublish");
            const e2 = this.packet;
            if (e2.topic = this._parseString(), null === e2.topic)
              return this._emitError(new Error("Cannot parse topic"));
            if (!(e2.qos > 0) || this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              e2.payload = this._list.slice(this._pos, e2.length), a("_parsePublish: payload from buffer list: %o", e2.payload);
            }
          }
          _parseSubscribe() {
            a("_parseSubscribe");
            const e2 = this.packet;
            let t2, r2, n2, i2, s2, l2, u;
            if (e2.subscriptions = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t3 = this._parseProperties();
                Object.getOwnPropertyNames(t3).length && (e2.properties = t3);
              }
              if (e2.length <= 0)
                return this._emitError(new Error("Malformed subscribe, no payload specified"));
              for (; this._pos < e2.length; ) {
                if (t2 = this._parseString(), null === t2)
                  return this._emitError(new Error("Cannot parse topic"));
                if (this._pos >= e2.length)
                  return this._emitError(new Error("Malformed Subscribe Payload"));
                if (r2 = this._parseByte(), 5 === this.settings.protocolVersion) {
                  if (192 & r2)
                    return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
                } else if (252 & r2)
                  return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
                if (n2 = r2 & o.SUBSCRIBE_OPTIONS_QOS_MASK, n2 > 2)
                  return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
                if (l2 = 0 != (r2 >> o.SUBSCRIBE_OPTIONS_NL_SHIFT & o.SUBSCRIBE_OPTIONS_NL_MASK), s2 = 0 != (r2 >> o.SUBSCRIBE_OPTIONS_RAP_SHIFT & o.SUBSCRIBE_OPTIONS_RAP_MASK), i2 = r2 >> o.SUBSCRIBE_OPTIONS_RH_SHIFT & o.SUBSCRIBE_OPTIONS_RH_MASK, i2 > 2)
                  return this._emitError(new Error("Invalid retain handling, must be <= 2"));
                u = { topic: t2, qos: n2 }, 5 === this.settings.protocolVersion ? (u.nl = l2, u.rap = s2, u.rh = i2) : this.settings.bridgeMode && (u.rh = 0, u.rap = true, u.nl = true), a("_parseSubscribe: push subscription `%s` to subscription", u), e2.subscriptions.push(u);
              }
            }
          }
          _parseSuback() {
            a("_parseSuback");
            const e2 = this.packet;
            if (this.packet.granted = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              if (e2.length <= 0)
                return this._emitError(new Error("Malformed suback, no payload specified"));
              for (; this._pos < this.packet.length; ) {
                const e3 = this._list.readUInt8(this._pos++);
                if (5 === this.settings.protocolVersion) {
                  if (!o.MQTT5_SUBACK_CODES[e3])
                    return this._emitError(new Error("Invalid suback code"));
                } else if (e3 > 2 && 128 !== e3)
                  return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
                this.packet.granted.push(e3);
              }
            }
          }
          _parseUnsubscribe() {
            a("_parseUnsubscribe");
            const e2 = this.packet;
            if (e2.unsubscriptions = [], this._parseMessageId()) {
              if (5 === this.settings.protocolVersion) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
              if (e2.length <= 0)
                return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
              for (; this._pos < e2.length; ) {
                const t2 = this._parseString();
                if (null === t2)
                  return this._emitError(new Error("Cannot parse topic"));
                a("_parseUnsubscribe: push topic `%s` to unsubscriptions", t2), e2.unsubscriptions.push(t2);
              }
            }
          }
          _parseUnsuback() {
            a("_parseUnsuback");
            const e2 = this.packet;
            if (!this._parseMessageId())
              return this._emitError(new Error("Cannot parse messageId"));
            if ((3 === this.settings.protocolVersion || 4 === this.settings.protocolVersion) && 2 !== e2.length)
              return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
            if (e2.length <= 0)
              return this._emitError(new Error("Malformed unsuback, no payload specified"));
            if (5 === this.settings.protocolVersion) {
              const t2 = this._parseProperties();
              for (Object.getOwnPropertyNames(t2).length && (e2.properties = t2), e2.granted = []; this._pos < this.packet.length; ) {
                const e3 = this._list.readUInt8(this._pos++);
                if (!o.MQTT5_UNSUBACK_CODES[e3])
                  return this._emitError(new Error("Invalid unsuback code"));
                this.packet.granted.push(e3);
              }
            }
          }
          _parseConfirmation() {
            a("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
            const e2 = this.packet;
            if (this._parseMessageId(), 5 === this.settings.protocolVersion) {
              if (e2.length > 2) {
                switch (e2.reasonCode = this._parseByte(), this.packet.cmd) {
                  case "puback":
                  case "pubrec":
                    if (!o.MQTT5_PUBACK_PUBREC_CODES[e2.reasonCode])
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                    break;
                  case "pubrel":
                  case "pubcomp":
                    if (!o.MQTT5_PUBREL_PUBCOMP_CODES[e2.reasonCode])
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                }
                a("_parseConfirmation: packet.reasonCode `%d`", e2.reasonCode);
              } else
                e2.reasonCode = 0;
              if (e2.length > 3) {
                const t2 = this._parseProperties();
                Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
              }
            }
            return true;
          }
          _parseDisconnect() {
            const e2 = this.packet;
            if (a("_parseDisconnect"), 5 === this.settings.protocolVersion) {
              this._list.length > 0 ? (e2.reasonCode = this._parseByte(), o.MQTT5_DISCONNECT_CODES[e2.reasonCode] || this._emitError(new Error("Invalid disconnect reason code"))) : e2.reasonCode = 0;
              const t2 = this._parseProperties();
              Object.getOwnPropertyNames(t2).length && (e2.properties = t2);
            }
            return a("_parseDisconnect result: true"), true;
          }
          _parseAuth() {
            a("_parseAuth");
            const e2 = this.packet;
            if (5 !== this.settings.protocolVersion)
              return this._emitError(new Error("Not supported auth packet for this version MQTT"));
            if (e2.reasonCode = this._parseByte(), !o.MQTT5_AUTH_CODES[e2.reasonCode])
              return this._emitError(new Error("Invalid auth reason code"));
            const t2 = this._parseProperties();
            return Object.getOwnPropertyNames(t2).length && (e2.properties = t2), a("_parseAuth: result: true"), true;
          }
          _parseMessageId() {
            const e2 = this.packet;
            return e2.messageId = this._parseNum(), null === e2.messageId ? (this._emitError(new Error("Cannot parse messageId")), false) : (a("_parseMessageId: packet.messageId %d", e2.messageId), true);
          }
          _parseString(e2) {
            const t2 = this._parseNum(), r2 = t2 + this._pos;
            if (-1 === t2 || r2 > this._list.length || r2 > this.packet.length)
              return null;
            const n2 = this._list.toString("utf8", this._pos, r2);
            return this._pos += t2, a("_parseString: result: %s", n2), n2;
          }
          _parseStringPair() {
            return a("_parseStringPair"), { name: this._parseString(), value: this._parseString() };
          }
          _parseBuffer() {
            const e2 = this._parseNum(), t2 = e2 + this._pos;
            if (-1 === e2 || t2 > this._list.length || t2 > this.packet.length)
              return null;
            const r2 = this._list.slice(this._pos, t2);
            return this._pos += e2, a("_parseBuffer: result: %o", r2), r2;
          }
          _parseNum() {
            if (this._list.length - this._pos < 2)
              return -1;
            const e2 = this._list.readUInt16BE(this._pos);
            return this._pos += 2, a("_parseNum: result: %s", e2), e2;
          }
          _parse4ByteNum() {
            if (this._list.length - this._pos < 4)
              return -1;
            const e2 = this._list.readUInt32BE(this._pos);
            return this._pos += 4, a("_parse4ByteNum: result: %s", e2), e2;
          }
          _parseVarByteNum(e2) {
            a("_parseVarByteNum");
            let t2, r2 = 0, n2 = 1, i2 = 0, s2 = false;
            const l2 = this._pos ? this._pos : 0;
            for (; r2 < 4 && l2 + r2 < this._list.length; ) {
              if (t2 = this._list.readUInt8(l2 + r2++), i2 += n2 * (t2 & o.VARBYTEINT_MASK), n2 *= 128, 0 == (t2 & o.VARBYTEINT_FIN_MASK)) {
                s2 = true;
                break;
              }
              if (this._list.length <= r2)
                break;
            }
            return !s2 && 4 === r2 && this._list.length >= r2 && this._emitError(new Error("Invalid variable byte integer")), l2 && (this._pos += r2), s2 = !!s2 && (e2 ? { bytes: r2, value: i2 } : i2), a("_parseVarByteNum: result: %o", s2), s2;
          }
          _parseByte() {
            let e2;
            return this._pos < this._list.length && (e2 = this._list.readUInt8(this._pos), this._pos++), a("_parseByte: result: %o", e2), e2;
          }
          _parseByType(e2) {
            switch (a("_parseByType: type: %s", e2), e2) {
              case "byte":
                return 0 !== this._parseByte();
              case "int8":
                return this._parseByte();
              case "int16":
                return this._parseNum();
              case "int32":
                return this._parse4ByteNum();
              case "var":
                return this._parseVarByteNum();
              case "string":
                return this._parseString();
              case "pair":
                return this._parseStringPair();
              case "binary":
                return this._parseBuffer();
            }
          }
          _parseProperties() {
            a("_parseProperties");
            const e2 = this._parseVarByteNum(), t2 = this._pos + e2, r2 = {};
            for (; this._pos < t2; ) {
              const e3 = this._parseByte();
              if (!e3)
                return this._emitError(new Error("Cannot parse property code type")), false;
              const t3 = o.propertiesCodes[e3];
              if (!t3)
                return this._emitError(new Error("Unknown property")), false;
              if ("userProperties" !== t3)
                r2[t3] ? (Array.isArray(r2[t3]) || (r2[t3] = [r2[t3]]), r2[t3].push(this._parseByType(o.propertiesTypes[t3]))) : r2[t3] = this._parseByType(o.propertiesTypes[t3]);
              else {
                r2[t3] || (r2[t3] = /* @__PURE__ */ Object.create(null));
                const e4 = this._parseByType(o.propertiesTypes[t3]);
                if (r2[t3][e4.name])
                  if (Array.isArray(r2[t3][e4.name]))
                    r2[t3][e4.name].push(e4.value);
                  else {
                    const n2 = r2[t3][e4.name];
                    r2[t3][e4.name] = [n2], r2[t3][e4.name].push(e4.value);
                  }
                else
                  r2[t3][e4.name] = e4.value;
              }
            }
            return r2;
          }
          _newPacket() {
            return a("_newPacket"), this.packet && (this._list.consume(this.packet.length), a("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), a("_newPacket: new packet"), this.packet = new s(), this._pos = 0, true;
          }
          _emitError(e2) {
            a("_emitError", e2), this.error = e2, this.emit("error", e2);
          }
        }
        t.exports = l;
      }, { "./constants": 73, "./packet": 94, bl: 77, debug: 30, events: 49 }], 96: [function(e, t, r) {
        const n = e("./constants"), { Buffer: i } = e("buffer"), s = i.allocUnsafe(0), o = i.from([0]), a = e("./numbers"), l = e("process-nextick-args").nextTick, u = e("debug")("mqtt-packet:writeToStream"), c = a.cache, h = a.generateNumber, f = a.generateCache, d = a.genBufVariableByteInt, p = a.generate4ByteBuffer;
        let b = E, g = true;
        function m(e2, t2, r2) {
          switch (u("generate called"), t2.cork && (t2.cork(), l(y, t2)), g && (g = false, f()), u("generate: packet.cmd: %s", e2.cmd), e2.cmd) {
            case "connect":
              return function(e3, t3, r3) {
                const s2 = e3 || {}, o2 = s2.protocolId || "MQTT";
                let a2 = s2.protocolVersion || 4;
                const l2 = s2.will;
                let u2 = s2.clean;
                const c2 = s2.keepalive || 0, h2 = s2.clientId || "", f2 = s2.username, d2 = s2.password, p2 = s2.properties;
                void 0 === u2 && (u2 = true);
                let g2, m2, y2 = 0;
                if (!o2 || "string" != typeof o2 && !i.isBuffer(o2))
                  return t3.destroy(new Error("Invalid protocolId")), false;
                y2 += o2.length + 2;
                if (3 !== a2 && 4 !== a2 && 5 !== a2)
                  return t3.destroy(new Error("Invalid protocol version")), false;
                y2 += 1;
                if (("string" == typeof h2 || i.isBuffer(h2)) && (h2 || a2 >= 4) && (h2 || u2))
                  y2 += i.byteLength(h2) + 2;
                else {
                  if (a2 < 4)
                    return t3.destroy(new Error("clientId must be supplied before 3.1.1")), false;
                  if (1 * u2 == 0)
                    return t3.destroy(new Error("clientId must be given if cleanSession set to 0")), false;
                }
                if ("number" != typeof c2 || c2 < 0 || c2 > 65535 || c2 % 1 != 0)
                  return t3.destroy(new Error("Invalid keepalive")), false;
                y2 += 2;
                if (y2 += 1, 5 === a2) {
                  if (g2 = T(t3, p2), !g2)
                    return false;
                  y2 += g2.length;
                }
                if (l2) {
                  if ("object" != typeof l2)
                    return t3.destroy(new Error("Invalid will")), false;
                  if (!l2.topic || "string" != typeof l2.topic)
                    return t3.destroy(new Error("Invalid will topic")), false;
                  if (y2 += i.byteLength(l2.topic) + 2, y2 += 2, l2.payload) {
                    if (!(l2.payload.length >= 0))
                      return t3.destroy(new Error("Invalid will payload")), false;
                    "string" == typeof l2.payload ? y2 += i.byteLength(l2.payload) : y2 += l2.payload.length;
                  }
                  if (m2 = {}, 5 === a2) {
                    if (m2 = T(t3, l2.properties), !m2)
                      return false;
                    y2 += m2.length;
                  }
                }
                let _2 = false;
                if (null != f2) {
                  if (!P(f2))
                    return t3.destroy(new Error("Invalid username")), false;
                  _2 = true, y2 += i.byteLength(f2) + 2;
                }
                if (null != d2) {
                  if (!_2)
                    return t3.destroy(new Error("Username is required to use password")), false;
                  if (!P(d2))
                    return t3.destroy(new Error("Invalid password")), false;
                  y2 += C(d2) + 2;
                }
                t3.write(n.CONNECT_HEADER), w(t3, y2), k(t3, o2), s2.bridgeMode && (a2 += 128);
                t3.write(131 === a2 ? n.VERSION131 : 132 === a2 ? n.VERSION132 : 4 === a2 ? n.VERSION4 : 5 === a2 ? n.VERSION5 : n.VERSION3);
                let S2 = 0;
                S2 |= null != f2 ? n.USERNAME_MASK : 0, S2 |= null != d2 ? n.PASSWORD_MASK : 0, S2 |= l2 && l2.retain ? n.WILL_RETAIN_MASK : 0, S2 |= l2 && l2.qos ? l2.qos << n.WILL_QOS_SHIFT : 0, S2 |= l2 ? n.WILL_FLAG_MASK : 0, S2 |= u2 ? n.CLEAN_SESSION_MASK : 0, t3.write(i.from([S2])), b(t3, c2), 5 === a2 && g2.write();
                k(t3, h2), l2 && (5 === a2 && m2.write(), v(t3, l2.topic), k(t3, l2.payload));
                null != f2 && k(t3, f2);
                null != d2 && k(t3, d2);
                return true;
              }(e2, t2);
            case "connack":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, a2 = e3 || {}, l2 = 5 === s2 ? a2.reasonCode : a2.returnCode, u2 = a2.properties;
                let c2 = 2;
                if ("number" != typeof l2)
                  return t3.destroy(new Error("Invalid return code")), false;
                let h2 = null;
                if (5 === s2) {
                  if (h2 = T(t3, u2), !h2)
                    return false;
                  c2 += h2.length;
                }
                t3.write(n.CONNACK_HEADER), w(t3, c2), t3.write(a2.sessionPresent ? n.SESSIONPRESENT_HEADER : o), t3.write(i.from([l2])), null != h2 && h2.write();
                return true;
              }(e2, t2, r2);
            case "publish":
              return function(e3, t3, r3) {
                u("publish: packet: %o", e3);
                const o2 = r3 ? r3.protocolVersion : 4, a2 = e3 || {}, l2 = a2.qos || 0, c2 = a2.retain ? n.RETAIN_MASK : 0, h2 = a2.topic, f2 = a2.payload || s, d2 = a2.messageId, p2 = a2.properties;
                let g2 = 0;
                if ("string" == typeof h2)
                  g2 += i.byteLength(h2) + 2;
                else {
                  if (!i.isBuffer(h2))
                    return t3.destroy(new Error("Invalid topic")), false;
                  g2 += h2.length + 2;
                }
                i.isBuffer(f2) ? g2 += f2.length : g2 += i.byteLength(f2);
                if (l2 && "number" != typeof d2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                l2 && (g2 += 2);
                let m2 = null;
                if (5 === o2) {
                  if (m2 = T(t3, p2), !m2)
                    return false;
                  g2 += m2.length;
                }
                t3.write(n.PUBLISH_HEADER[l2][a2.dup ? 1 : 0][c2 ? 1 : 0]), w(t3, g2), b(t3, C(h2)), t3.write(h2), l2 > 0 && b(t3, d2);
                null != m2 && m2.write();
                return u("publish: payload: %o", f2), t3.write(f2);
              }(e2, t2, r2);
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.cmd || "puback", l2 = o2.messageId, u2 = o2.dup && "pubrel" === a2 ? n.DUP_MASK : 0;
                let c2 = 0;
                const h2 = o2.reasonCode, f2 = o2.properties;
                let d2 = 5 === s2 ? 3 : 2;
                "pubrel" === a2 && (c2 = 1);
                if ("number" != typeof l2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                let p2 = null;
                if (5 === s2 && "object" == typeof f2) {
                  if (p2 = I(t3, f2, r3, d2), !p2)
                    return false;
                  d2 += p2.length;
                }
                t3.write(n.ACKS[a2][c2][u2][0]), 3 === d2 && (d2 += 0 !== h2 ? 1 : -1);
                w(t3, d2), b(t3, l2), 5 === s2 && 2 !== d2 && t3.write(i.from([h2]));
                null !== p2 ? p2.write() : 4 === d2 && t3.write(i.from([0]));
                return true;
              }(e2, t2, r2);
            case "subscribe":
              return function(e3, t3, r3) {
                u("subscribe: packet: ");
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.dup ? n.DUP_MASK : 0, l2 = o2.messageId, c2 = o2.subscriptions, h2 = o2.properties;
                let f2 = 0;
                if ("number" != typeof l2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                f2 += 2;
                let d2 = null;
                if (5 === s2) {
                  if (d2 = T(t3, h2), !d2)
                    return false;
                  f2 += d2.length;
                }
                if ("object" != typeof c2 || !c2.length)
                  return t3.destroy(new Error("Invalid subscriptions")), false;
                for (let e4 = 0; e4 < c2.length; e4 += 1) {
                  const r4 = c2[e4].topic, n2 = c2[e4].qos;
                  if ("string" != typeof r4)
                    return t3.destroy(new Error("Invalid subscriptions - invalid topic")), false;
                  if ("number" != typeof n2)
                    return t3.destroy(new Error("Invalid subscriptions - invalid qos")), false;
                  if (5 === s2) {
                    if ("boolean" != typeof (c2[e4].nl || false))
                      return t3.destroy(new Error("Invalid subscriptions - invalid No Local")), false;
                    if ("boolean" != typeof (c2[e4].rap || false))
                      return t3.destroy(new Error("Invalid subscriptions - invalid Retain as Published")), false;
                    const r5 = c2[e4].rh || 0;
                    if ("number" != typeof r5 || r5 > 2)
                      return t3.destroy(new Error("Invalid subscriptions - invalid Retain Handling")), false;
                  }
                  f2 += i.byteLength(r4) + 2 + 1;
                }
                u("subscribe: writing to stream: %o", n.SUBSCRIBE_HEADER), t3.write(n.SUBSCRIBE_HEADER[1][a2 ? 1 : 0][0]), w(t3, f2), b(t3, l2), null !== d2 && d2.write();
                let p2 = true;
                for (const e4 of c2) {
                  const r4 = e4.topic, o3 = e4.qos, a3 = +e4.nl, l3 = +e4.rap, u2 = e4.rh;
                  let c3;
                  v(t3, r4), c3 = n.SUBSCRIBE_OPTIONS_QOS[o3], 5 === s2 && (c3 |= a3 ? n.SUBSCRIBE_OPTIONS_NL : 0, c3 |= l3 ? n.SUBSCRIBE_OPTIONS_RAP : 0, c3 |= u2 ? n.SUBSCRIBE_OPTIONS_RH[u2] : 0), p2 = t3.write(i.from([c3]));
                }
                return p2;
              }(e2, t2, r2);
            case "suback":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.messageId, l2 = o2.granted, u2 = o2.properties;
                let c2 = 0;
                if ("number" != typeof a2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                c2 += 2;
                if ("object" != typeof l2 || !l2.length)
                  return t3.destroy(new Error("Invalid qos vector")), false;
                for (let e4 = 0; e4 < l2.length; e4 += 1) {
                  if ("number" != typeof l2[e4])
                    return t3.destroy(new Error("Invalid qos vector")), false;
                  c2 += 1;
                }
                let h2 = null;
                if (5 === s2) {
                  if (h2 = I(t3, u2, r3, c2), !h2)
                    return false;
                  c2 += h2.length;
                }
                t3.write(n.SUBACK_HEADER), w(t3, c2), b(t3, a2), null !== h2 && h2.write();
                return t3.write(i.from(l2));
              }(e2, t2, r2);
            case "unsubscribe":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.messageId, l2 = o2.dup ? n.DUP_MASK : 0, u2 = o2.unsubscriptions, c2 = o2.properties;
                let h2 = 0;
                if ("number" != typeof a2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                h2 += 2;
                if ("object" != typeof u2 || !u2.length)
                  return t3.destroy(new Error("Invalid unsubscriptions")), false;
                for (let e4 = 0; e4 < u2.length; e4 += 1) {
                  if ("string" != typeof u2[e4])
                    return t3.destroy(new Error("Invalid unsubscriptions")), false;
                  h2 += i.byteLength(u2[e4]) + 2;
                }
                let f2 = null;
                if (5 === s2) {
                  if (f2 = T(t3, c2), !f2)
                    return false;
                  h2 += f2.length;
                }
                t3.write(n.UNSUBSCRIBE_HEADER[1][l2 ? 1 : 0][0]), w(t3, h2), b(t3, a2), null !== f2 && f2.write();
                let d2 = true;
                for (let e4 = 0; e4 < u2.length; e4++)
                  d2 = v(t3, u2[e4]);
                return d2;
              }(e2, t2, r2);
            case "unsuback":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.messageId, l2 = o2.dup ? n.DUP_MASK : 0, u2 = o2.granted, c2 = o2.properties, h2 = o2.cmd, f2 = 0;
                let d2 = 2;
                if ("number" != typeof a2)
                  return t3.destroy(new Error("Invalid messageId")), false;
                if (5 === s2) {
                  if ("object" != typeof u2 || !u2.length)
                    return t3.destroy(new Error("Invalid qos vector")), false;
                  for (let e4 = 0; e4 < u2.length; e4 += 1) {
                    if ("number" != typeof u2[e4])
                      return t3.destroy(new Error("Invalid qos vector")), false;
                    d2 += 1;
                  }
                }
                let p2 = null;
                if (5 === s2) {
                  if (p2 = I(t3, c2, r3, d2), !p2)
                    return false;
                  d2 += p2.length;
                }
                t3.write(n.ACKS[h2][f2][l2][0]), w(t3, d2), b(t3, a2), null !== p2 && p2.write();
                5 === s2 && t3.write(i.from(u2));
                return true;
              }(e2, t2, r2);
            case "pingreq":
            case "pingresp":
              return function(e3, t3, r3) {
                return t3.write(n.EMPTY[e3.cmd]);
              }(e2, t2);
            case "disconnect":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.reasonCode, l2 = o2.properties;
                let u2 = 5 === s2 ? 1 : 0, c2 = null;
                if (5 === s2) {
                  if (c2 = I(t3, l2, r3, u2), !c2)
                    return false;
                  u2 += c2.length;
                }
                t3.write(i.from([n.codes.disconnect << 4])), w(t3, u2), 5 === s2 && t3.write(i.from([a2]));
                null !== c2 && c2.write();
                return true;
              }(e2, t2, r2);
            case "auth":
              return function(e3, t3, r3) {
                const s2 = r3 ? r3.protocolVersion : 4, o2 = e3 || {}, a2 = o2.reasonCode, l2 = o2.properties;
                let u2 = 5 === s2 ? 1 : 0;
                5 !== s2 && t3.destroy(new Error("Invalid mqtt version for auth packet"));
                const c2 = I(t3, l2, r3, u2);
                if (!c2)
                  return false;
                u2 += c2.length, t3.write(i.from([n.codes.auth << 4])), w(t3, u2), t3.write(i.from([a2])), null !== c2 && c2.write();
                return true;
              }(e2, t2, r2);
            default:
              return t2.destroy(new Error("Unknown command")), false;
          }
        }
        function y(e2) {
          e2.uncork();
        }
        Object.defineProperty(m, "cacheNumbers", { get: () => b === E, set(e2) {
          e2 ? (c && 0 !== Object.keys(c).length || (g = true), b = E) : (g = false, b = A);
        } });
        const _ = {};
        function w(e2, t2) {
          if (t2 > n.VARBYTEINT_MAX)
            return e2.destroy(new Error(`Invalid variable byte integer: ${t2}`)), false;
          let r2 = _[t2];
          return r2 || (r2 = d(t2), t2 < 16384 && (_[t2] = r2)), u("writeVarByteInt: writing to stream: %o", r2), e2.write(r2);
        }
        function v(e2, t2) {
          const r2 = i.byteLength(t2);
          return b(e2, r2), u("writeString: %s", t2), e2.write(t2, "utf8");
        }
        function S(e2, t2, r2) {
          v(e2, t2), v(e2, r2);
        }
        function E(e2, t2) {
          return u("writeNumberCached: number: %d", t2), u("writeNumberCached: %o", c[t2]), e2.write(c[t2]);
        }
        function A(e2, t2) {
          const r2 = h(t2);
          return u("writeNumberGenerated: %o", r2), e2.write(r2);
        }
        function k(e2, t2) {
          "string" == typeof t2 ? v(e2, t2) : t2 ? (b(e2, t2.length), e2.write(t2)) : b(e2, 0);
        }
        function T(e2, t2) {
          if ("object" != typeof t2 || null != t2.length)
            return { length: 1, write() {
              O(e2, {}, 0);
            } };
          let r2 = 0;
          function s2(t3, r3) {
            let s3 = 0;
            switch (n.propertiesTypes[t3]) {
              case "byte":
                if ("boolean" != typeof r3)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 2;
                break;
              case "int8":
                if ("number" != typeof r3 || r3 < 0 || r3 > 255)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 2;
                break;
              case "binary":
                if (r3 && null === r3)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 1 + i.byteLength(r3) + 2;
                break;
              case "int16":
                if ("number" != typeof r3 || r3 < 0 || r3 > 65535)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 3;
                break;
              case "int32":
                if ("number" != typeof r3 || r3 < 0 || r3 > 4294967295)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 5;
                break;
              case "var":
                if ("number" != typeof r3 || r3 < 0 || r3 > 268435455)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 1 + i.byteLength(d(r3));
                break;
              case "string":
                if ("string" != typeof r3)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += 3 + i.byteLength(r3.toString());
                break;
              case "pair":
                if ("object" != typeof r3)
                  return e2.destroy(new Error(`Invalid ${t3}: ${r3}`)), false;
                s3 += Object.getOwnPropertyNames(r3).reduce((e3, t4) => {
                  const n2 = r3[t4];
                  return Array.isArray(n2) ? e3 += n2.reduce((e4, r4) => e4 += 3 + i.byteLength(t4.toString()) + 2 + i.byteLength(r4.toString()), 0) : e3 += 3 + i.byteLength(t4.toString()) + 2 + i.byteLength(r3[t4].toString()), e3;
                }, 0);
                break;
              default:
                return e2.destroy(new Error(`Invalid property ${t3}: ${r3}`)), false;
            }
            return s3;
          }
          if (t2)
            for (const e3 in t2) {
              let n2 = 0, i2 = 0;
              const o2 = t2[e3];
              if (Array.isArray(o2))
                for (let t3 = 0; t3 < o2.length; t3++) {
                  if (i2 = s2(e3, o2[t3]), !i2)
                    return false;
                  n2 += i2;
                }
              else {
                if (i2 = s2(e3, o2), !i2)
                  return false;
                n2 = i2;
              }
              if (!n2)
                return false;
              r2 += n2;
            }
          return { length: i.byteLength(d(r2)) + r2, write() {
            O(e2, t2, r2);
          } };
        }
        function I(e2, t2, r2, n2) {
          const i2 = ["reasonString", "userProperties"], s2 = r2 && r2.properties && r2.properties.maximumPacketSize ? r2.properties.maximumPacketSize : 0;
          let o2 = T(e2, t2);
          if (s2)
            for (; n2 + o2.length > s2; ) {
              const r3 = i2.shift();
              if (!r3 || !t2[r3])
                return false;
              delete t2[r3], o2 = T(e2, t2);
            }
          return o2;
        }
        function R(e2, t2, r2) {
          switch (n.propertiesTypes[t2]) {
            case "byte":
              e2.write(i.from([n.properties[t2]])), e2.write(i.from([+r2]));
              break;
            case "int8":
              e2.write(i.from([n.properties[t2]])), e2.write(i.from([r2]));
              break;
            case "binary":
              e2.write(i.from([n.properties[t2]])), k(e2, r2);
              break;
            case "int16":
              e2.write(i.from([n.properties[t2]])), b(e2, r2);
              break;
            case "int32":
              e2.write(i.from([n.properties[t2]])), function(e3, t3) {
                const r3 = p(t3);
                u("write4ByteNumber: %o", r3), e3.write(r3);
              }(e2, r2);
              break;
            case "var":
              e2.write(i.from([n.properties[t2]])), w(e2, r2);
              break;
            case "string":
              e2.write(i.from([n.properties[t2]])), v(e2, r2);
              break;
            case "pair":
              Object.getOwnPropertyNames(r2).forEach((s2) => {
                const o2 = r2[s2];
                Array.isArray(o2) ? o2.forEach((r3) => {
                  e2.write(i.from([n.properties[t2]])), S(e2, s2.toString(), r3.toString());
                }) : (e2.write(i.from([n.properties[t2]])), S(e2, s2.toString(), o2.toString()));
              });
              break;
            default:
              return e2.destroy(new Error(`Invalid property ${t2} value: ${r2}`)), false;
          }
        }
        function O(e2, t2, r2) {
          w(e2, r2);
          for (const r3 in t2)
            if (Object.prototype.hasOwnProperty.call(t2, r3) && null !== t2[r3]) {
              const n2 = t2[r3];
              if (Array.isArray(n2))
                for (let t3 = 0; t3 < n2.length; t3++)
                  R(e2, r3, n2[t3]);
              else
                R(e2, r3, n2);
            }
        }
        function C(e2) {
          return e2 ? e2 instanceof i ? e2.length : i.byteLength(e2) : 0;
        }
        function P(e2) {
          return "string" == typeof e2 || e2 instanceof i;
        }
        t.exports = m;
      }, { "./constants": 73, "./numbers": 93, buffer: 29, debug: 30, "process-nextick-args": 101 }], 97: [function(e, t, r) {
        var n = 1e3, i = 60 * n, s = 60 * i, o = 24 * s, a = 7 * o, l = 365.25 * o;
        function u(e2, t2, r2, n2) {
          var i2 = t2 >= 1.5 * r2;
          return Math.round(e2 / r2) + " " + n2 + (i2 ? "s" : "");
        }
        t.exports = function(e2, t2) {
          t2 = t2 || {};
          var r2 = typeof e2;
          if ("string" === r2 && e2.length > 0)
            return function(e3) {
              if ((e3 = String(e3)).length > 100)
                return;
              var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e3);
              if (!t3)
                return;
              var r3 = parseFloat(t3[1]);
              switch ((t3[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return r3 * l;
                case "weeks":
                case "week":
                case "w":
                  return r3 * a;
                case "days":
                case "day":
                case "d":
                  return r3 * o;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return r3 * s;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return r3 * i;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return r3 * n;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return r3;
                default:
                  return;
              }
            }(e2);
          if ("number" === r2 && isFinite(e2))
            return t2.long ? function(e3) {
              var t3 = Math.abs(e3);
              if (t3 >= o)
                return u(e3, t3, o, "day");
              if (t3 >= s)
                return u(e3, t3, s, "hour");
              if (t3 >= i)
                return u(e3, t3, i, "minute");
              if (t3 >= n)
                return u(e3, t3, n, "second");
              return e3 + " ms";
            }(e2) : function(e3) {
              var t3 = Math.abs(e3);
              if (t3 >= o)
                return Math.round(e3 / o) + "d";
              if (t3 >= s)
                return Math.round(e3 / s) + "h";
              if (t3 >= i)
                return Math.round(e3 / i) + "m";
              if (t3 >= n)
                return Math.round(e3 / n) + "s";
              return e3 + "ms";
            }(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 98: [function(e, t, r) {
        const n = e("./lib/number-allocator.js");
        t.exports.NumberAllocator = n;
      }, { "./lib/number-allocator.js": 99 }], 99: [function(e, t, r) {
        "use strict";
        const n = e("js-sdsl").OrderedSet, i = e("debug")("number-allocator:trace"), s = e("debug")("number-allocator:error");
        function o(e2, t2) {
          this.low = e2, this.high = t2;
        }
        function a(e2, t2) {
          if (!(this instanceof a))
            return new a(e2, t2);
          this.min = e2, this.max = t2, this.ss = new n([], (e3, t3) => e3.compare(t3)), i("Create"), this.clear();
        }
        o.prototype.equals = function(e2) {
          return this.low === e2.low && this.high === e2.high;
        }, o.prototype.compare = function(e2) {
          return this.low < e2.low && this.high < e2.low ? -1 : e2.low < this.low && e2.high < this.low ? 1 : 0;
        }, a.prototype.firstVacant = function() {
          return 0 === this.ss.size() ? null : this.ss.front().low;
        }, a.prototype.alloc = function() {
          if (0 === this.ss.size())
            return i("alloc():empty"), null;
          const e2 = this.ss.begin(), t2 = e2.pointer.low, r2 = e2.pointer.high, n2 = t2;
          return n2 + 1 <= r2 ? this.ss.updateKeyByIterator(e2, new o(t2 + 1, r2)) : this.ss.eraseElementByPos(0), i("alloc():" + n2), n2;
        }, a.prototype.use = function(e2) {
          const t2 = new o(e2, e2), r2 = this.ss.lowerBound(t2);
          if (!r2.equals(this.ss.end())) {
            const n2 = r2.pointer.low, s2 = r2.pointer.high;
            return r2.pointer.equals(t2) ? (this.ss.eraseElementByIterator(r2), i("use():" + e2), true) : !(n2 > e2) && (n2 === e2 ? (this.ss.updateKeyByIterator(r2, new o(n2 + 1, s2)), i("use():" + e2), true) : s2 === e2 ? (this.ss.updateKeyByIterator(r2, new o(n2, s2 - 1)), i("use():" + e2), true) : (this.ss.updateKeyByIterator(r2, new o(e2 + 1, s2)), this.ss.insert(new o(n2, e2 - 1)), i("use():" + e2), true));
          }
          return i("use():failed"), false;
        }, a.prototype.free = function(e2) {
          if (e2 < this.min || e2 > this.max)
            return void s("free():" + e2 + " is out of range");
          const t2 = new o(e2, e2), r2 = this.ss.upperBound(t2);
          if (r2.equals(this.ss.end())) {
            if (r2.equals(this.ss.begin()))
              return void this.ss.insert(t2);
            r2.pre();
            const n2 = r2.pointer.high;
            r2.pointer.high + 1 === e2 ? this.ss.updateKeyByIterator(r2, new o(n2, e2)) : this.ss.insert(t2);
          } else if (r2.equals(this.ss.begin()))
            if (e2 + 1 === r2.pointer.low) {
              const t3 = r2.pointer.high;
              this.ss.updateKeyByIterator(r2, new o(e2, t3));
            } else
              this.ss.insert(t2);
          else {
            const n2 = r2.pointer.low, i2 = r2.pointer.high;
            r2.pre();
            const s2 = r2.pointer.low;
            r2.pointer.high + 1 === e2 ? e2 + 1 === n2 ? (this.ss.eraseElementByIterator(r2), this.ss.updateKeyByIterator(r2, new o(s2, i2))) : this.ss.updateKeyByIterator(r2, new o(s2, e2)) : e2 + 1 === n2 ? (this.ss.eraseElementByIterator(r2.next()), this.ss.insert(new o(e2, i2))) : this.ss.insert(t2);
          }
          i("free():" + e2);
        }, a.prototype.clear = function() {
          i("clear()"), this.ss.clear(), this.ss.insert(new o(this.min, this.max));
        }, a.prototype.intervalCount = function() {
          return this.ss.size();
        }, a.prototype.dump = function() {
          console.log("length:" + this.ss.size());
          for (const e2 of this.ss)
            console.log(e2);
        }, t.exports = a;
      }, { debug: 30, "js-sdsl": 69 }], 100: [function(e, t, r) {
        var n = e("wrappy");
        function i(e2) {
          var t2 = function() {
            return t2.called ? t2.value : (t2.called = true, t2.value = e2.apply(this, arguments));
          };
          return t2.called = false, t2;
        }
        function s(e2) {
          var t2 = function() {
            if (t2.called)
              throw new Error(t2.onceError);
            return t2.called = true, t2.value = e2.apply(this, arguments);
          }, r2 = e2.name || "Function wrapped with `once`";
          return t2.onceError = r2 + " shouldn't be called more than once", t2.called = false, t2;
        }
        t.exports = n(i), t.exports.strict = n(s), i.proto = i(function() {
          Object.defineProperty(Function.prototype, "once", { value: function() {
            return i(this);
          }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
            return s(this);
          }, configurable: true });
        });
      }, { wrappy: 140 }], 101: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            void 0 === e2 || !e2.version || 0 === e2.version.indexOf("v0.") || 0 === e2.version.indexOf("v1.") && 0 !== e2.version.indexOf("v1.8.") ? t.exports = { nextTick: function(t2, r2, n, i) {
              if ("function" != typeof t2)
                throw new TypeError('"callback" argument must be a function');
              var s, o, a = arguments.length;
              switch (a) {
                case 0:
                case 1:
                  return e2.nextTick(t2);
                case 2:
                  return e2.nextTick(function() {
                    t2.call(null, r2);
                  });
                case 3:
                  return e2.nextTick(function() {
                    t2.call(null, r2, n);
                  });
                case 4:
                  return e2.nextTick(function() {
                    t2.call(null, r2, n, i);
                  });
                default:
                  for (s = new Array(a - 1), o = 0; o < s.length; )
                    s[o++] = arguments[o];
                  return e2.nextTick(function() {
                    t2.apply(null, s);
                  });
              }
            } } : t.exports = e2;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 102 }], 102: [function(e, t, r) {
        var n, i, s = t.exports = {};
        function o() {
          throw new Error("setTimeout has not been defined");
        }
        function a() {
          throw new Error("clearTimeout has not been defined");
        }
        function l(e2) {
          if (n === setTimeout)
            return setTimeout(e2, 0);
          if ((n === o || !n) && setTimeout)
            return n = setTimeout, setTimeout(e2, 0);
          try {
            return n(e2, 0);
          } catch (t2) {
            try {
              return n.call(null, e2, 0);
            } catch (t3) {
              return n.call(this, e2, 0);
            }
          }
        }
        !function() {
          try {
            n = "function" == typeof setTimeout ? setTimeout : o;
          } catch (e2) {
            n = o;
          }
          try {
            i = "function" == typeof clearTimeout ? clearTimeout : a;
          } catch (e2) {
            i = a;
          }
        }();
        var u, c = [], h = false, f = -1;
        function d() {
          h && u && (h = false, u.length ? c = u.concat(c) : f = -1, c.length && p());
        }
        function p() {
          if (!h) {
            var e2 = l(d);
            h = true;
            for (var t2 = c.length; t2; ) {
              for (u = c, c = []; ++f < t2; )
                u && u[f].run();
              f = -1, t2 = c.length;
            }
            u = null, h = false, function(e3) {
              if (i === clearTimeout)
                return clearTimeout(e3);
              if ((i === a || !i) && clearTimeout)
                return i = clearTimeout, clearTimeout(e3);
              try {
                return i(e3);
              } catch (t3) {
                try {
                  return i.call(null, e3);
                } catch (t4) {
                  return i.call(this, e3);
                }
              }
            }(e2);
          }
        }
        function b(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        function g() {
        }
        s.nextTick = function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r2 = 1; r2 < arguments.length; r2++)
              t2[r2 - 1] = arguments[r2];
          c.push(new b(e2, t2)), 1 !== c.length || h || l(p);
        }, b.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = true, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function(e2) {
          return [];
        }, s.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 103: [function(e, t, r) {
        (function(e2) {
          (function() {
            !function(n) {
              var i = "object" == typeof r && r && !r.nodeType && r, s = "object" == typeof t && t && !t.nodeType && t, o = "object" == typeof e2 && e2;
              o.global !== o && o.window !== o && o.self !== o || (n = o);
              var a, l, u = 2147483647, c = 36, h = 1, f = 26, d = 38, p = 700, b = 72, g = 128, m = "-", y = /^xn--/, _ = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, v = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, S = c - h, E = Math.floor, A = String.fromCharCode;
              function k(e3) {
                throw new RangeError(v[e3]);
              }
              function T(e3, t2) {
                for (var r2 = e3.length, n2 = []; r2--; )
                  n2[r2] = t2(e3[r2]);
                return n2;
              }
              function I(e3, t2) {
                var r2 = e3.split("@"), n2 = "";
                return r2.length > 1 && (n2 = r2[0] + "@", e3 = r2[1]), n2 + T((e3 = e3.replace(w, ".")).split("."), t2).join(".");
              }
              function R(e3) {
                for (var t2, r2, n2 = [], i2 = 0, s2 = e3.length; i2 < s2; )
                  (t2 = e3.charCodeAt(i2++)) >= 55296 && t2 <= 56319 && i2 < s2 ? 56320 == (64512 & (r2 = e3.charCodeAt(i2++))) ? n2.push(((1023 & t2) << 10) + (1023 & r2) + 65536) : (n2.push(t2), i2--) : n2.push(t2);
                return n2;
              }
              function O(e3) {
                return T(e3, function(e4) {
                  var t2 = "";
                  return e4 > 65535 && (t2 += A((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t2 += A(e4);
                }).join("");
              }
              function C(e3, t2) {
                return e3 + 22 + 75 * (e3 < 26) - ((0 != t2) << 5);
              }
              function P(e3, t2, r2) {
                var n2 = 0;
                for (e3 = r2 ? E(e3 / p) : e3 >> 1, e3 += E(e3 / t2); e3 > S * f >> 1; n2 += c)
                  e3 = E(e3 / S);
                return E(n2 + (S + 1) * e3 / (e3 + d));
              }
              function x(e3) {
                var t2, r2, n2, i2, s2, o2, a2, l2, d2, p2, y2, _2 = [], w2 = e3.length, v2 = 0, S2 = g, A2 = b;
                for ((r2 = e3.lastIndexOf(m)) < 0 && (r2 = 0), n2 = 0; n2 < r2; ++n2)
                  e3.charCodeAt(n2) >= 128 && k("not-basic"), _2.push(e3.charCodeAt(n2));
                for (i2 = r2 > 0 ? r2 + 1 : 0; i2 < w2; ) {
                  for (s2 = v2, o2 = 1, a2 = c; i2 >= w2 && k("invalid-input"), ((l2 = (y2 = e3.charCodeAt(i2++)) - 48 < 10 ? y2 - 22 : y2 - 65 < 26 ? y2 - 65 : y2 - 97 < 26 ? y2 - 97 : c) >= c || l2 > E((u - v2) / o2)) && k("overflow"), v2 += l2 * o2, !(l2 < (d2 = a2 <= A2 ? h : a2 >= A2 + f ? f : a2 - A2)); a2 += c)
                    o2 > E(u / (p2 = c - d2)) && k("overflow"), o2 *= p2;
                  A2 = P(v2 - s2, t2 = _2.length + 1, 0 == s2), E(v2 / t2) > u - S2 && k("overflow"), S2 += E(v2 / t2), v2 %= t2, _2.splice(v2++, 0, S2);
                }
                return O(_2);
              }
              function M(e3) {
                var t2, r2, n2, i2, s2, o2, a2, l2, d2, p2, y2, _2, w2, v2, S2, T2 = [];
                for (_2 = (e3 = R(e3)).length, t2 = g, r2 = 0, s2 = b, o2 = 0; o2 < _2; ++o2)
                  (y2 = e3[o2]) < 128 && T2.push(A(y2));
                for (n2 = i2 = T2.length, i2 && T2.push(m); n2 < _2; ) {
                  for (a2 = u, o2 = 0; o2 < _2; ++o2)
                    (y2 = e3[o2]) >= t2 && y2 < a2 && (a2 = y2);
                  for (a2 - t2 > E((u - r2) / (w2 = n2 + 1)) && k("overflow"), r2 += (a2 - t2) * w2, t2 = a2, o2 = 0; o2 < _2; ++o2)
                    if ((y2 = e3[o2]) < t2 && ++r2 > u && k("overflow"), y2 == t2) {
                      for (l2 = r2, d2 = c; !(l2 < (p2 = d2 <= s2 ? h : d2 >= s2 + f ? f : d2 - s2)); d2 += c)
                        S2 = l2 - p2, v2 = c - p2, T2.push(A(C(p2 + S2 % v2, 0))), l2 = E(S2 / v2);
                      T2.push(A(C(l2, 0))), s2 = P(r2, w2, n2 == i2), r2 = 0, ++n2;
                    }
                  ++r2, ++t2;
                }
                return T2.join("");
              }
              if (a = { version: "1.4.1", ucs2: { decode: R, encode: O }, decode: x, encode: M, toASCII: function(e3) {
                return I(e3, function(e4) {
                  return _.test(e4) ? "xn--" + M(e4) : e4;
                });
              }, toUnicode: function(e3) {
                return I(e3, function(e4) {
                  return y.test(e4) ? x(e4.slice(4).toLowerCase()) : e4;
                });
              } }, i && s)
                if (t.exports == i)
                  s.exports = a;
                else
                  for (l in a)
                    a.hasOwnProperty(l) && (i[l] = a[l]);
              else
                n.punycode = a;
            }(this);
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 104: [function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }
        t.exports = function(e2, t2, r2, s) {
          t2 = t2 || "&", r2 = r2 || "=";
          var o = {};
          if ("string" != typeof e2 || 0 === e2.length)
            return o;
          var a = /\+/g;
          e2 = e2.split(t2);
          var l = 1e3;
          s && "number" == typeof s.maxKeys && (l = s.maxKeys);
          var u = e2.length;
          l > 0 && u > l && (u = l);
          for (var c = 0; c < u; ++c) {
            var h, f, d, p, b = e2[c].replace(a, "%20"), g = b.indexOf(r2);
            g >= 0 ? (h = b.substr(0, g), f = b.substr(g + 1)) : (h = b, f = ""), d = decodeURIComponent(h), p = decodeURIComponent(f), n(o, d) ? i(o[d]) ? o[d].push(p) : o[d] = [o[d], p] : o[d] = p;
          }
          return o;
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
      }, {}], 105: [function(e, t, r) {
        "use strict";
        var n = function(e2) {
          switch (typeof e2) {
            case "string":
              return e2;
            case "boolean":
              return e2 ? "true" : "false";
            case "number":
              return isFinite(e2) ? e2 : "";
            default:
              return "";
          }
        };
        t.exports = function(e2, t2, r2, a) {
          return t2 = t2 || "&", r2 = r2 || "=", null === e2 && (e2 = void 0), "object" == typeof e2 ? s(o(e2), function(o2) {
            var a2 = encodeURIComponent(n(o2)) + r2;
            return i(e2[o2]) ? s(e2[o2], function(e3) {
              return a2 + encodeURIComponent(n(e3));
            }).join(t2) : a2 + encodeURIComponent(n(e2[o2]));
          }).join(t2) : a ? encodeURIComponent(n(a)) + r2 + encodeURIComponent(n(e2)) : "";
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
        function s(e2, t2) {
          if (e2.map)
            return e2.map(t2);
          for (var r2 = [], n2 = 0; n2 < e2.length; n2++)
            r2.push(t2(e2[n2], n2));
          return r2;
        }
        var o = Object.keys || function(e2) {
          var t2 = [];
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.push(r2);
          return t2;
        };
      }, {}], 106: [function(e, t, r) {
        "use strict";
        r.decode = r.parse = e("./decode"), r.encode = r.stringify = e("./encode");
      }, { "./decode": 104, "./encode": 105 }], 107: [function(e, t, r) {
        "use strict";
        const { AbortError: n, codes: i } = e("../../ours/errors"), { isNodeStream: s, isWebStream: o, kControllerErrorFunction: a } = e("./utils"), l = e("./end-of-stream"), { ERR_INVALID_ARG_TYPE: u } = i;
        t.exports.addAbortSignal = function(e2, r2) {
          if (((e3, t2) => {
            if ("object" != typeof e3 || !("aborted" in e3))
              throw new u(t2, "AbortSignal", e3);
          })(e2, "signal"), !s(r2) && !o(r2))
            throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], r2);
          return t.exports.addAbortSignalNoValidate(e2, r2);
        }, t.exports.addAbortSignalNoValidate = function(e2, t2) {
          if ("object" != typeof e2 || !("aborted" in e2))
            return t2;
          const r2 = s(t2) ? () => {
            t2.destroy(new n(void 0, { cause: e2.reason }));
          } : () => {
            t2[a](new n(void 0, { cause: e2.reason }));
          };
          return e2.aborted ? r2() : (e2.addEventListener("abort", r2), l(t2, () => e2.removeEventListener("abort", r2))), t2;
        };
      }, { "../../ours/errors": 126, "./end-of-stream": 113, "./utils": 122 }], 108: [function(e, t, r) {
        "use strict";
        const { StringPrototypeSlice: n, SymbolIterator: i, TypedArrayPrototypeSet: s, Uint8Array: o } = e("../../ours/primordials"), { Buffer: a } = e("buffer"), { inspect: l } = e("../../ours/util");
        t.exports = class {
          constructor() {
            this.head = null, this.tail = null, this.length = 0;
          }
          push(e2) {
            const t2 = { data: e2, next: null };
            this.length > 0 ? this.tail.next = t2 : this.head = t2, this.tail = t2, ++this.length;
          }
          unshift(e2) {
            const t2 = { data: e2, next: this.head };
            0 === this.length && (this.tail = t2), this.head = t2, ++this.length;
          }
          shift() {
            if (0 === this.length)
              return;
            const e2 = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e2;
          }
          clear() {
            this.head = this.tail = null, this.length = 0;
          }
          join(e2) {
            if (0 === this.length)
              return "";
            let t2 = this.head, r2 = "" + t2.data;
            for (; null !== (t2 = t2.next); )
              r2 += e2 + t2.data;
            return r2;
          }
          concat(e2) {
            if (0 === this.length)
              return a.alloc(0);
            const t2 = a.allocUnsafe(e2 >>> 0);
            let r2 = this.head, n2 = 0;
            for (; r2; )
              s(t2, r2.data, n2), n2 += r2.data.length, r2 = r2.next;
            return t2;
          }
          consume(e2, t2) {
            const r2 = this.head.data;
            if (e2 < r2.length) {
              const t3 = r2.slice(0, e2);
              return this.head.data = r2.slice(e2), t3;
            }
            return e2 === r2.length ? this.shift() : t2 ? this._getString(e2) : this._getBuffer(e2);
          }
          first() {
            return this.head.data;
          }
          *[i]() {
            for (let e2 = this.head; e2; e2 = e2.next)
              yield e2.data;
          }
          _getString(e2) {
            let t2 = "", r2 = this.head, i2 = 0;
            do {
              const s2 = r2.data;
              if (!(e2 > s2.length)) {
                e2 === s2.length ? (t2 += s2, ++i2, r2.next ? this.head = r2.next : this.head = this.tail = null) : (t2 += n(s2, 0, e2), this.head = r2, r2.data = n(s2, e2));
                break;
              }
              t2 += s2, e2 -= s2.length, ++i2;
            } while (null !== (r2 = r2.next));
            return this.length -= i2, t2;
          }
          _getBuffer(e2) {
            const t2 = a.allocUnsafe(e2), r2 = e2;
            let n2 = this.head, i2 = 0;
            do {
              const a2 = n2.data;
              if (!(e2 > a2.length)) {
                e2 === a2.length ? (s(t2, a2, r2 - e2), ++i2, n2.next ? this.head = n2.next : this.head = this.tail = null) : (s(t2, new o(a2.buffer, a2.byteOffset, e2), r2 - e2), this.head = n2, n2.data = a2.slice(e2));
                break;
              }
              s(t2, a2, r2 - e2), e2 -= a2.length, ++i2;
            } while (null !== (n2 = n2.next));
            return this.length -= i2, t2;
          }
          [Symbol.for("nodejs.util.inspect.custom")](e2, t2) {
            return l(this, { ...t2, depth: 0, customInspect: false });
          }
        };
      }, { "../../ours/primordials": 127, "../../ours/util": 128, buffer: 29 }], 109: [function(e, t, r) {
        "use strict";
        const { pipeline: n } = e("./pipeline"), i = e("./duplex"), { destroyer: s } = e("./destroy"), { isNodeStream: o, isReadable: a, isWritable: l, isWebStream: u, isTransformStream: c, isWritableStream: h, isReadableStream: f } = e("./utils"), { AbortError: d, codes: { ERR_INVALID_ARG_VALUE: p, ERR_MISSING_ARGS: b } } = e("../../ours/errors"), g = e("./end-of-stream");
        t.exports = function(...e2) {
          if (0 === e2.length)
            throw new b("streams");
          if (1 === e2.length)
            return i.from(e2[0]);
          const t2 = [...e2];
          if ("function" == typeof e2[0] && (e2[0] = i.from(e2[0])), "function" == typeof e2[e2.length - 1]) {
            const t3 = e2.length - 1;
            e2[t3] = i.from(e2[t3]);
          }
          for (let r3 = 0; r3 < e2.length; ++r3)
            if (o(e2[r3]) || u(e2[r3])) {
              if (r3 < e2.length - 1 && !(a(e2[r3]) || f(e2[r3]) || c(e2[r3])))
                throw new p(`streams[${r3}]`, t2[r3], "must be readable");
              if (r3 > 0 && !(l(e2[r3]) || h(e2[r3]) || c(e2[r3])))
                throw new p(`streams[${r3}]`, t2[r3], "must be writable");
            }
          let r2, m, y, _, w;
          const v = e2[0], S = n(e2, function(e3) {
            const t3 = _;
            _ = null, t3 ? t3(e3) : e3 ? w.destroy(e3) : A || E || w.destroy();
          }), E = !!(l(v) || h(v) || c(v)), A = !!(a(S) || f(S) || c(S));
          if (w = new i({ writableObjectMode: !(null == v || !v.writableObjectMode), readableObjectMode: !(null == S || !S.writableObjectMode), writable: E, readable: A }), E) {
            if (o(v))
              w._write = function(e4, t3, n2) {
                v.write(e4, t3) ? n2() : r2 = n2;
              }, w._final = function(e4) {
                v.end(), m = e4;
              }, v.on("drain", function() {
                if (r2) {
                  const e4 = r2;
                  r2 = null, e4();
                }
              });
            else if (u(v)) {
              const e4 = (c(v) ? v.writable : v).getWriter();
              w._write = async function(t3, r3, n2) {
                try {
                  await e4.ready, e4.write(t3).catch(() => {
                  }), n2();
                } catch (e5) {
                  n2(e5);
                }
              }, w._final = async function(t3) {
                try {
                  await e4.ready, e4.close().catch(() => {
                  }), m = t3;
                } catch (e5) {
                  t3(e5);
                }
              };
            }
            const e3 = c(S) ? S.readable : S;
            g(e3, () => {
              if (m) {
                const e4 = m;
                m = null, e4();
              }
            });
          }
          if (A) {
            if (o(S))
              S.on("readable", function() {
                if (y) {
                  const e3 = y;
                  y = null, e3();
                }
              }), S.on("end", function() {
                w.push(null);
              }), w._read = function() {
                for (; ; ) {
                  const e3 = S.read();
                  if (null === e3)
                    return void (y = w._read);
                  if (!w.push(e3))
                    return;
                }
              };
            else if (u(S)) {
              const e3 = (c(S) ? S.readable : S).getReader();
              w._read = async function() {
                for (; ; )
                  try {
                    const { value: t3, done: r3 } = await e3.read();
                    if (!w.push(t3))
                      return;
                    if (r3)
                      return void w.push(null);
                  } catch {
                    return;
                  }
              };
            }
          }
          return w._destroy = function(e3, t3) {
            e3 || null === _ || (e3 = new d()), y = null, r2 = null, m = null, null === _ ? t3(e3) : (_ = t3, o(S) && s(S, e3));
          }, w;
        };
      }, { "../../ours/errors": 126, "./destroy": 110, "./duplex": 111, "./end-of-stream": 113, "./pipeline": 118, "./utils": 122 }], 110: [function(e, t, r) {
        "use strict";
        const n = e("process/"), { aggregateTwoErrors: i, codes: { ERR_MULTIPLE_CALLBACK: s }, AbortError: o } = e("../../ours/errors"), { Symbol: a } = e("../../ours/primordials"), { kDestroyed: l, isDestroyed: u, isFinished: c, isServerRequest: h } = e("./utils"), f = a("kDestroy"), d = a("kConstruct");
        function p(e2, t2, r2) {
          e2 && (e2.stack, t2 && !t2.errored && (t2.errored = e2), r2 && !r2.errored && (r2.errored = e2));
        }
        function b(e2, t2, r2) {
          let i2 = false;
          function s2(t3) {
            if (i2)
              return;
            i2 = true;
            const s3 = e2._readableState, o2 = e2._writableState;
            p(t3, o2, s3), o2 && (o2.closed = true), s3 && (s3.closed = true), "function" == typeof r2 && r2(t3), t3 ? n.nextTick(g, e2, t3) : n.nextTick(m, e2);
          }
          try {
            e2._destroy(t2 || null, s2);
          } catch (t3) {
            s2(t3);
          }
        }
        function g(e2, t2) {
          y(e2, t2), m(e2);
        }
        function m(e2) {
          const t2 = e2._readableState, r2 = e2._writableState;
          r2 && (r2.closeEmitted = true), t2 && (t2.closeEmitted = true), (null != r2 && r2.emitClose || null != t2 && t2.emitClose) && e2.emit("close");
        }
        function y(e2, t2) {
          const r2 = e2._readableState, n2 = e2._writableState;
          null != n2 && n2.errorEmitted || null != r2 && r2.errorEmitted || (n2 && (n2.errorEmitted = true), r2 && (r2.errorEmitted = true), e2.emit("error", t2));
        }
        function _(e2, t2, r2) {
          const i2 = e2._readableState, s2 = e2._writableState;
          if (null != s2 && s2.destroyed || null != i2 && i2.destroyed)
            return this;
          null != i2 && i2.autoDestroy || null != s2 && s2.autoDestroy ? e2.destroy(t2) : t2 && (t2.stack, s2 && !s2.errored && (s2.errored = t2), i2 && !i2.errored && (i2.errored = t2), r2 ? n.nextTick(y, e2, t2) : y(e2, t2));
        }
        function w(e2) {
          let t2 = false;
          function r2(r3) {
            if (t2)
              return void _(e2, null != r3 ? r3 : new s());
            t2 = true;
            const i2 = e2._readableState, o2 = e2._writableState, a2 = o2 || i2;
            i2 && (i2.constructed = true), o2 && (o2.constructed = true), a2.destroyed ? e2.emit(f, r3) : r3 ? _(e2, r3, true) : n.nextTick(v, e2);
          }
          try {
            e2._construct((e3) => {
              n.nextTick(r2, e3);
            });
          } catch (e3) {
            n.nextTick(r2, e3);
          }
        }
        function v(e2) {
          e2.emit(d);
        }
        function S(e2) {
          return (null == e2 ? void 0 : e2.setHeader) && "function" == typeof e2.abort;
        }
        function E(e2) {
          e2.emit("close");
        }
        function A(e2, t2) {
          e2.emit("error", t2), n.nextTick(E, e2);
        }
        t.exports = { construct: function(e2, t2) {
          if ("function" != typeof e2._construct)
            return;
          const r2 = e2._readableState, i2 = e2._writableState;
          r2 && (r2.constructed = false), i2 && (i2.constructed = false), e2.once(d, t2), e2.listenerCount(d) > 1 || n.nextTick(w, e2);
        }, destroyer: function(e2, t2) {
          e2 && !u(e2) && (t2 || c(e2) || (t2 = new o()), h(e2) ? (e2.socket = null, e2.destroy(t2)) : S(e2) ? e2.abort() : S(e2.req) ? e2.req.abort() : "function" == typeof e2.destroy ? e2.destroy(t2) : "function" == typeof e2.close ? e2.close() : t2 ? n.nextTick(A, e2, t2) : n.nextTick(E, e2), e2.destroyed || (e2[l] = true));
        }, destroy: function(e2, t2) {
          const r2 = this._readableState, n2 = this._writableState, s2 = n2 || r2;
          return null != n2 && n2.destroyed || null != r2 && r2.destroyed ? ("function" == typeof t2 && t2(), this) : (p(e2, n2, r2), n2 && (n2.destroyed = true), r2 && (r2.destroyed = true), s2.constructed ? b(this, e2, t2) : this.once(f, function(r3) {
            b(this, i(r3, e2), t2);
          }), this);
        }, undestroy: function() {
          const e2 = this._readableState, t2 = this._writableState;
          e2 && (e2.constructed = true, e2.closed = false, e2.closeEmitted = false, e2.destroyed = false, e2.errored = null, e2.errorEmitted = false, e2.reading = false, e2.ended = false === e2.readable, e2.endEmitted = false === e2.readable), t2 && (t2.constructed = true, t2.destroyed = false, t2.closed = false, t2.closeEmitted = false, t2.errored = null, t2.errorEmitted = false, t2.finalCalled = false, t2.prefinished = false, t2.ended = false === t2.writable, t2.ending = false === t2.writable, t2.finished = false === t2.writable);
        }, errorOrDestroy: _ };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "./utils": 122, "process/": 102 }], 111: [function(e, t, r) {
        "use strict";
        const { ObjectDefineProperties: n, ObjectGetOwnPropertyDescriptor: i, ObjectKeys: s, ObjectSetPrototypeOf: o } = e("../../ours/primordials");
        t.exports = u;
        const a = e("./readable"), l = e("./writable");
        o(u.prototype, a.prototype), o(u, a);
        {
          const e2 = s(l.prototype);
          for (let t2 = 0; t2 < e2.length; t2++) {
            const r2 = e2[t2];
            u.prototype[r2] || (u.prototype[r2] = l.prototype[r2]);
          }
        }
        function u(e2) {
          if (!(this instanceof u))
            return new u(e2);
          a.call(this, e2), l.call(this, e2), e2 ? (this.allowHalfOpen = false !== e2.allowHalfOpen, false === e2.readable && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === e2.writable && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
        }
        let c, h;
        function f() {
          return void 0 === c && (c = {}), c;
        }
        n(u.prototype, { writable: { __proto__: null, ...i(l.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...i(l.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...i(l.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...i(l.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...i(l.prototype, "writableLength") }, writableFinished: { __proto__: null, ...i(l.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...i(l.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...i(l.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...i(l.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
          return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
        }, set(e2) {
          this._readableState && this._writableState && (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
        } } }), u.fromWeb = function(e2, t2) {
          return f().newStreamDuplexFromReadableWritablePair(e2, t2);
        }, u.toWeb = function(e2) {
          return f().newReadableWritablePairFromDuplex(e2);
        }, u.from = function(t2) {
          return h || (h = e("./duplexify")), h(t2, "body");
        };
      }, { "../../ours/primordials": 127, "./duplexify": 112, "./readable": 119, "./writable": 123 }], 112: [function(e, t, r) {
        const n = e("process/"), i = e("buffer"), { isReadable: s, isWritable: o, isIterable: a, isNodeStream: l, isReadableNodeStream: u, isWritableNodeStream: c, isDuplexNodeStream: h } = e("./utils"), f = e("./end-of-stream"), { AbortError: d, codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: b } } = e("../../ours/errors"), { destroyer: g } = e("./destroy"), m = e("./duplex"), y = e("./readable"), { createDeferredPromise: _ } = e("../../ours/util"), w = e("./from"), v = globalThis.Blob || i.Blob, S = void 0 !== v ? function(e2) {
          return e2 instanceof v;
        } : function(e2) {
          return false;
        }, E = globalThis.AbortController || e("abort-controller").AbortController, { FunctionPrototypeCall: A } = e("../../ours/primordials");
        class k extends m {
          constructor(e2) {
            super(e2), false === (null == e2 ? void 0 : e2.readable) && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === (null == e2 ? void 0 : e2.writable) && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
          }
        }
        function T(e2) {
          const t2 = e2.readable && "function" != typeof e2.readable.read ? y.wrap(e2.readable) : e2.readable, r2 = e2.writable;
          let n2, i2, a2, l2, u2, c2 = !!s(t2), h2 = !!o(r2);
          function p2(e3) {
            const t3 = l2;
            l2 = null, t3 ? t3(e3) : e3 && u2.destroy(e3);
          }
          return u2 = new k({ readableObjectMode: !(null == t2 || !t2.readableObjectMode), writableObjectMode: !(null == r2 || !r2.writableObjectMode), readable: c2, writable: h2 }), h2 && (f(r2, (e3) => {
            h2 = false, e3 && g(t2, e3), p2(e3);
          }), u2._write = function(e3, t3, i3) {
            r2.write(e3, t3) ? i3() : n2 = i3;
          }, u2._final = function(e3) {
            r2.end(), i2 = e3;
          }, r2.on("drain", function() {
            if (n2) {
              const e3 = n2;
              n2 = null, e3();
            }
          }), r2.on("finish", function() {
            if (i2) {
              const e3 = i2;
              i2 = null, e3();
            }
          })), c2 && (f(t2, (e3) => {
            c2 = false, e3 && g(t2, e3), p2(e3);
          }), t2.on("readable", function() {
            if (a2) {
              const e3 = a2;
              a2 = null, e3();
            }
          }), t2.on("end", function() {
            u2.push(null);
          }), u2._read = function() {
            for (; ; ) {
              const e3 = t2.read();
              if (null === e3)
                return void (a2 = u2._read);
              if (!u2.push(e3))
                return;
            }
          }), u2._destroy = function(e3, s2) {
            e3 || null === l2 || (e3 = new d()), a2 = null, n2 = null, i2 = null, null === l2 ? s2(e3) : (l2 = s2, g(r2, e3), g(t2, e3));
          }, u2;
        }
        t.exports = function e2(t2, r2) {
          if (h(t2))
            return t2;
          if (u(t2))
            return T({ readable: t2 });
          if (c(t2))
            return T({ writable: t2 });
          if (l(t2))
            return T({ writable: false, readable: false });
          if ("function" == typeof t2) {
            const { value: e3, write: i3, final: s2, destroy: o2 } = function(e4) {
              let { promise: t3, resolve: r3 } = _();
              const i4 = new E(), s3 = i4.signal, o3 = e4(async function* () {
                for (; ; ) {
                  const e5 = t3;
                  t3 = null;
                  const { chunk: i5, done: o4, cb: a2 } = await e5;
                  if (n.nextTick(a2), o4)
                    return;
                  if (s3.aborted)
                    throw new d(void 0, { cause: s3.reason });
                  ({ promise: t3, resolve: r3 } = _()), yield i5;
                }
              }(), { signal: s3 });
              return { value: o3, write(e5, t4, n2) {
                const i5 = r3;
                r3 = null, i5({ chunk: e5, done: false, cb: n2 });
              }, final(e5) {
                const t4 = r3;
                r3 = null, t4({ done: true, cb: e5 });
              }, destroy(e5, t4) {
                i4.abort(), t4(e5);
              } };
            }(t2);
            if (a(e3))
              return w(k, e3, { objectMode: true, write: i3, final: s2, destroy: o2 });
            const l2 = null == e3 ? void 0 : e3.then;
            if ("function" == typeof l2) {
              let t3;
              const r3 = A(l2, e3, (e4) => {
                if (null != e4)
                  throw new b("nully", "body", e4);
              }, (e4) => {
                g(t3, e4);
              });
              return t3 = new k({ objectMode: true, readable: false, write: i3, final(e4) {
                s2(async () => {
                  try {
                    await r3, n.nextTick(e4, null);
                  } catch (t4) {
                    n.nextTick(e4, t4);
                  }
                });
              }, destroy: o2 });
            }
            throw new b("Iterable, AsyncIterable or AsyncFunction", r2, e3);
          }
          if (S(t2))
            return e2(t2.arrayBuffer());
          if (a(t2))
            return w(k, t2, { objectMode: true, writable: false });
          if ("object" == typeof (null == t2 ? void 0 : t2.writable) || "object" == typeof (null == t2 ? void 0 : t2.readable)) {
            return T({ readable: null != t2 && t2.readable ? u(null == t2 ? void 0 : t2.readable) ? null == t2 ? void 0 : t2.readable : e2(t2.readable) : void 0, writable: null != t2 && t2.writable ? c(null == t2 ? void 0 : t2.writable) ? null == t2 ? void 0 : t2.writable : e2(t2.writable) : void 0 });
          }
          const i2 = null == t2 ? void 0 : t2.then;
          if ("function" == typeof i2) {
            let e3;
            return A(i2, t2, (t3) => {
              null != t3 && e3.push(t3), e3.push(null);
            }, (t3) => {
              g(e3, t3);
            }), e3 = new k({ objectMode: true, writable: false, read() {
            } });
          }
          throw new p(r2, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t2);
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "../../ours/util": 128, "./destroy": 110, "./duplex": 111, "./end-of-stream": 113, "./from": 114, "./readable": 119, "./utils": 122, "abort-controller": 24, buffer: 29, "process/": 102 }], 113: [function(e, t, r) {
        const n = e("process/"), { AbortError: i, codes: s } = e("../../ours/errors"), { ERR_INVALID_ARG_TYPE: o, ERR_STREAM_PREMATURE_CLOSE: a } = s, { kEmptyObject: l, once: u } = e("../../ours/util"), { validateAbortSignal: c, validateFunction: h, validateObject: f, validateBoolean: d } = e("../validators"), { Promise: p, PromisePrototypeThen: b } = e("../../ours/primordials"), { isClosed: g, isReadable: m, isReadableNodeStream: y, isReadableStream: _, isReadableFinished: w, isReadableErrored: v, isWritable: S, isWritableNodeStream: E, isWritableStream: A, isWritableFinished: k, isWritableErrored: T, isNodeStream: I, willEmitClose: R, kIsClosedPromise: O } = e("./utils");
        const C = () => {
        };
        function P(e2, t2, r2) {
          var s2, d2;
          if (2 === arguments.length ? (r2 = t2, t2 = l) : null == t2 ? t2 = l : f(t2, "options"), h(r2, "callback"), c(t2.signal, "options.signal"), r2 = u(r2), _(e2) || A(e2))
            return function(e3, t3, r3) {
              let s3 = false, o2 = C;
              if (t3.signal)
                if (o2 = () => {
                  s3 = true, r3.call(e3, new i(void 0, { cause: t3.signal.reason }));
                }, t3.signal.aborted)
                  n.nextTick(o2);
                else {
                  const n2 = r3;
                  r3 = u((...r4) => {
                    t3.signal.removeEventListener("abort", o2), n2.apply(e3, r4);
                  }), t3.signal.addEventListener("abort", o2);
                }
              const a2 = (...t4) => {
                s3 || n.nextTick(() => r3.apply(e3, t4));
              };
              return b(e3[O].promise, a2, a2), C;
            }(e2, t2, r2);
          if (!I(e2))
            throw new o("stream", ["ReadableStream", "WritableStream", "Stream"], e2);
          const p2 = null !== (s2 = t2.readable) && void 0 !== s2 ? s2 : y(e2), P2 = null !== (d2 = t2.writable) && void 0 !== d2 ? d2 : E(e2), x = e2._writableState, M = e2._readableState, B = () => {
            e2.writable || N();
          };
          let L = R(e2) && y(e2) === p2 && E(e2) === P2, j = k(e2, false);
          const N = () => {
            j = true, e2.destroyed && (L = false), (!L || e2.readable && !p2) && (p2 && !U || r2.call(e2));
          };
          let U = w(e2, false);
          const D = () => {
            U = true, e2.destroyed && (L = false), (!L || e2.writable && !P2) && (P2 && !j || r2.call(e2));
          }, F = (t3) => {
            r2.call(e2, t3);
          };
          let W = g(e2);
          const q = () => {
            W = true;
            const t3 = T(e2) || v(e2);
            return t3 && "boolean" != typeof t3 ? r2.call(e2, t3) : p2 && !U && y(e2, true) && !w(e2, false) ? r2.call(e2, new a()) : !P2 || j || k(e2, false) ? void r2.call(e2) : r2.call(e2, new a());
          }, H = () => {
            W = true;
            const t3 = T(e2) || v(e2);
            if (t3 && "boolean" != typeof t3)
              return r2.call(e2, t3);
            r2.call(e2);
          }, z = () => {
            e2.req.on("finish", N);
          };
          !function(e3) {
            return e3.setHeader && "function" == typeof e3.abort;
          }(e2) ? P2 && !x && (e2.on("end", B), e2.on("close", B)) : (e2.on("complete", N), L || e2.on("abort", q), e2.req ? z() : e2.on("request", z)), L || "boolean" != typeof e2.aborted || e2.on("aborted", q), e2.on("end", D), e2.on("finish", N), false !== t2.error && e2.on("error", F), e2.on("close", q), W ? n.nextTick(q) : null != x && x.errorEmitted || null != M && M.errorEmitted ? L || n.nextTick(H) : (p2 || L && !m(e2) || !j && false !== S(e2)) && (P2 || L && !S(e2) || !U && false !== m(e2)) ? M && e2.req && e2.aborted && n.nextTick(H) : n.nextTick(H);
          const V = () => {
            r2 = C, e2.removeListener("aborted", q), e2.removeListener("complete", N), e2.removeListener("abort", q), e2.removeListener("request", z), e2.req && e2.req.removeListener("finish", N), e2.removeListener("end", B), e2.removeListener("close", B), e2.removeListener("finish", N), e2.removeListener("end", D), e2.removeListener("error", F), e2.removeListener("close", q);
          };
          if (t2.signal && !W) {
            const s3 = () => {
              const n2 = r2;
              V(), n2.call(e2, new i(void 0, { cause: t2.signal.reason }));
            };
            if (t2.signal.aborted)
              n.nextTick(s3);
            else {
              const n2 = r2;
              r2 = u((...r3) => {
                t2.signal.removeEventListener("abort", s3), n2.apply(e2, r3);
              }), t2.signal.addEventListener("abort", s3);
            }
          }
          return V;
        }
        t.exports = P, t.exports.finished = function(e2, t2) {
          var r2;
          let n2 = false;
          return null === t2 && (t2 = l), null !== (r2 = t2) && void 0 !== r2 && r2.cleanup && (d(t2.cleanup, "cleanup"), n2 = t2.cleanup), new p((r3, i2) => {
            const s2 = P(e2, t2, (e3) => {
              n2 && s2(), e3 ? i2(e3) : r3();
            });
          });
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "../../ours/util": 128, "../validators": 124, "./utils": 122, "process/": 102 }], 114: [function(e, t, r) {
        "use strict";
        const n = e("process/"), { PromisePrototypeThen: i, SymbolAsyncIterator: s, SymbolIterator: o } = e("../../ours/primordials"), { Buffer: a } = e("buffer"), { ERR_INVALID_ARG_TYPE: l, ERR_STREAM_NULL_VALUES: u } = e("../../ours/errors").codes;
        t.exports = function(e2, t2, r2) {
          let c, h;
          if ("string" == typeof t2 || t2 instanceof a)
            return new e2({ objectMode: true, ...r2, read() {
              this.push(t2), this.push(null);
            } });
          if (t2 && t2[s])
            h = true, c = t2[s]();
          else {
            if (!t2 || !t2[o])
              throw new l("iterable", ["Iterable"], t2);
            h = false, c = t2[o]();
          }
          const f = new e2({ objectMode: true, highWaterMark: 1, ...r2 });
          let d = false;
          return f._read = function() {
            d || (d = true, async function() {
              for (; ; ) {
                try {
                  const { value: e3, done: t3 } = h ? await c.next() : c.next();
                  if (t3)
                    f.push(null);
                  else {
                    const t4 = e3 && "function" == typeof e3.then ? await e3 : e3;
                    if (null === t4)
                      throw d = false, new u();
                    if (f.push(t4))
                      continue;
                    d = false;
                  }
                } catch (e3) {
                  f.destroy(e3);
                }
                break;
              }
            }());
          }, f._destroy = function(e3, t3) {
            i(async function(e4) {
              const t4 = null != e4, r3 = "function" == typeof c.throw;
              if (t4 && r3) {
                const { value: t5, done: r4 } = await c.throw(e4);
                if (await t5, r4)
                  return;
              }
              if ("function" == typeof c.return) {
                const { value: e5 } = await c.return();
                await e5;
              }
            }(e3), () => n.nextTick(t3, e3), (r3) => n.nextTick(t3, r3 || e3));
          }, f;
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, buffer: 29, "process/": 102 }], 115: [function(e, t, r) {
        "use strict";
        const { ArrayIsArray: n, ObjectSetPrototypeOf: i } = e("../../ours/primordials"), { EventEmitter: s } = e("events");
        function o(e2) {
          s.call(this, e2);
        }
        function a(e2, t2, r2) {
          if ("function" == typeof e2.prependListener)
            return e2.prependListener(t2, r2);
          e2._events && e2._events[t2] ? n(e2._events[t2]) ? e2._events[t2].unshift(r2) : e2._events[t2] = [r2, e2._events[t2]] : e2.on(t2, r2);
        }
        i(o.prototype, s.prototype), i(o, s), o.prototype.pipe = function(e2, t2) {
          const r2 = this;
          function n2(t3) {
            e2.writable && false === e2.write(t3) && r2.pause && r2.pause();
          }
          function i2() {
            r2.readable && r2.resume && r2.resume();
          }
          r2.on("data", n2), e2.on("drain", i2), e2._isStdio || t2 && false === t2.end || (r2.on("end", l), r2.on("close", u));
          let o2 = false;
          function l() {
            o2 || (o2 = true, e2.end());
          }
          function u() {
            o2 || (o2 = true, "function" == typeof e2.destroy && e2.destroy());
          }
          function c(e3) {
            h(), 0 === s.listenerCount(this, "error") && this.emit("error", e3);
          }
          function h() {
            r2.removeListener("data", n2), e2.removeListener("drain", i2), r2.removeListener("end", l), r2.removeListener("close", u), r2.removeListener("error", c), e2.removeListener("error", c), r2.removeListener("end", h), r2.removeListener("close", h), e2.removeListener("close", h);
          }
          return a(r2, "error", c), a(e2, "error", c), r2.on("end", h), r2.on("close", h), e2.on("close", h), e2.emit("pipe", r2), e2;
        }, t.exports = { Stream: o, prependListener: a };
      }, { "../../ours/primordials": 127, events: 49 }], 116: [function(e, t, r) {
        "use strict";
        const n = globalThis.AbortController || e("abort-controller").AbortController, { codes: { ERR_INVALID_ARG_VALUE: i, ERR_INVALID_ARG_TYPE: s, ERR_MISSING_ARGS: o, ERR_OUT_OF_RANGE: a }, AbortError: l } = e("../../ours/errors"), { validateAbortSignal: u, validateInteger: c, validateObject: h } = e("../validators"), f = e("../../ours/primordials").Symbol("kWeak"), { finished: d } = e("./end-of-stream"), p = e("./compose"), { addAbortSignalNoValidate: b } = e("./add-abort-signal"), { isWritable: g, isNodeStream: m } = e("./utils"), { ArrayPrototypePush: y, MathFloor: _, Number: w, NumberIsNaN: v, Promise: S, PromiseReject: E, PromisePrototypeThen: A, Symbol: k } = e("../../ours/primordials"), T = k("kEmpty"), I = k("kEof");
        function R(e2, t2) {
          if ("function" != typeof e2)
            throw new s("fn", ["Function", "AsyncFunction"], e2);
          null != t2 && h(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u(t2.signal, "options.signal");
          let r2 = 1;
          return null != (null == t2 ? void 0 : t2.concurrency) && (r2 = _(t2.concurrency)), c(r2, "concurrency", 1), (async function* () {
            var i2, s2;
            const o2 = new n(), a2 = this, u2 = [], c2 = o2.signal, h2 = { signal: c2 }, f2 = () => o2.abort();
            let d2, p2;
            null != t2 && null !== (i2 = t2.signal) && void 0 !== i2 && i2.aborted && f2(), null == t2 || null === (s2 = t2.signal) || void 0 === s2 || s2.addEventListener("abort", f2);
            let b2 = false;
            function g2() {
              b2 = true;
            }
            !async function() {
              try {
                for await (let t3 of a2) {
                  var n2;
                  if (b2)
                    return;
                  if (c2.aborted)
                    throw new l();
                  try {
                    t3 = e2(t3, h2);
                  } catch (e3) {
                    t3 = E(e3);
                  }
                  t3 !== T && ("function" == typeof (null === (n2 = t3) || void 0 === n2 ? void 0 : n2.catch) && t3.catch(g2), u2.push(t3), d2 && (d2(), d2 = null), !b2 && u2.length && u2.length >= r2 && await new S((e3) => {
                    p2 = e3;
                  }));
                }
                u2.push(I);
              } catch (e3) {
                const t3 = E(e3);
                A(t3, void 0, g2), u2.push(t3);
              } finally {
                var i3;
                b2 = true, d2 && (d2(), d2 = null), null == t2 || null === (i3 = t2.signal) || void 0 === i3 || i3.removeEventListener("abort", f2);
              }
            }();
            try {
              for (; ; ) {
                for (; u2.length > 0; ) {
                  const e3 = await u2[0];
                  if (e3 === I)
                    return;
                  if (c2.aborted)
                    throw new l();
                  e3 !== T && (yield e3), u2.shift(), p2 && (p2(), p2 = null);
                }
                await new S((e3) => {
                  d2 = e3;
                });
              }
            } finally {
              o2.abort(), b2 = true, p2 && (p2(), p2 = null);
            }
          }).call(this);
        }
        async function O(e2, t2 = void 0) {
          for await (const r2 of C.call(this, e2, t2))
            return true;
          return false;
        }
        function C(e2, t2) {
          if ("function" != typeof e2)
            throw new s("fn", ["Function", "AsyncFunction"], e2);
          return R.call(this, async function(t3, r2) {
            return await e2(t3, r2) ? t3 : T;
          }, t2);
        }
        class P extends o {
          constructor() {
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
          }
        }
        function x(e2) {
          if (e2 = w(e2), v(e2))
            return 0;
          if (e2 < 0)
            throw new a("number", ">= 0", e2);
          return e2;
        }
        t.exports.streamReturningOperators = { asIndexedPairs: function(e2 = void 0) {
          return null != e2 && h(e2, "options"), null != (null == e2 ? void 0 : e2.signal) && u(e2.signal, "options.signal"), (async function* () {
            let t2 = 0;
            for await (const n2 of this) {
              var r2;
              if (null != e2 && null !== (r2 = e2.signal) && void 0 !== r2 && r2.aborted)
                throw new l({ cause: e2.signal.reason });
              yield [t2++, n2];
            }
          }).call(this);
        }, drop: function(e2, t2 = void 0) {
          return null != t2 && h(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u(t2.signal, "options.signal"), e2 = x(e2), (async function* () {
            var r2;
            if (null != t2 && null !== (r2 = t2.signal) && void 0 !== r2 && r2.aborted)
              throw new l();
            for await (const r3 of this) {
              var n2;
              if (null != t2 && null !== (n2 = t2.signal) && void 0 !== n2 && n2.aborted)
                throw new l();
              e2-- <= 0 && (yield r3);
            }
          }).call(this);
        }, filter: C, flatMap: function(e2, t2) {
          const r2 = R.call(this, e2, t2);
          return (async function* () {
            for await (const e3 of r2)
              yield* e3;
          }).call(this);
        }, map: R, take: function(e2, t2 = void 0) {
          return null != t2 && h(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u(t2.signal, "options.signal"), e2 = x(e2), (async function* () {
            var r2;
            if (null != t2 && null !== (r2 = t2.signal) && void 0 !== r2 && r2.aborted)
              throw new l();
            for await (const r3 of this) {
              var n2;
              if (null != t2 && null !== (n2 = t2.signal) && void 0 !== n2 && n2.aborted)
                throw new l();
              if (!(e2-- > 0))
                return;
              yield r3;
            }
          }).call(this);
        }, compose: function(e2, t2) {
          if (null != t2 && h(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u(t2.signal, "options.signal"), m(e2) && !g(e2))
            throw new i("stream", e2, "must be writable");
          const r2 = p(this, e2);
          return null != t2 && t2.signal && b(t2.signal, r2), r2;
        } }, t.exports.promiseReturningOperators = { every: async function(e2, t2 = void 0) {
          if ("function" != typeof e2)
            throw new s("fn", ["Function", "AsyncFunction"], e2);
          return !await O.call(this, async (...t3) => !await e2(...t3), t2);
        }, forEach: async function(e2, t2) {
          if ("function" != typeof e2)
            throw new s("fn", ["Function", "AsyncFunction"], e2);
          for await (const r2 of R.call(this, async function(t3, r3) {
            return await e2(t3, r3), T;
          }, t2))
            ;
        }, reduce: async function(e2, t2, r2) {
          var i2;
          if ("function" != typeof e2)
            throw new s("reducer", ["Function", "AsyncFunction"], e2);
          null != r2 && h(r2, "options"), null != (null == r2 ? void 0 : r2.signal) && u(r2.signal, "options.signal");
          let o2 = arguments.length > 1;
          if (null != r2 && null !== (i2 = r2.signal) && void 0 !== i2 && i2.aborted) {
            const e3 = new l(void 0, { cause: r2.signal.reason });
            throw this.once("error", () => {
            }), await d(this.destroy(e3)), e3;
          }
          const a2 = new n(), c2 = a2.signal;
          if (null != r2 && r2.signal) {
            const e3 = { once: true, [f]: this };
            r2.signal.addEventListener("abort", () => a2.abort(), e3);
          }
          let p2 = false;
          try {
            for await (const n2 of this) {
              var b2;
              if (p2 = true, null != r2 && null !== (b2 = r2.signal) && void 0 !== b2 && b2.aborted)
                throw new l();
              o2 ? t2 = await e2(t2, n2, { signal: c2 }) : (t2 = n2, o2 = true);
            }
            if (!p2 && !o2)
              throw new P();
          } finally {
            a2.abort();
          }
          return t2;
        }, toArray: async function(e2) {
          null != e2 && h(e2, "options"), null != (null == e2 ? void 0 : e2.signal) && u(e2.signal, "options.signal");
          const t2 = [];
          for await (const n2 of this) {
            var r2;
            if (null != e2 && null !== (r2 = e2.signal) && void 0 !== r2 && r2.aborted)
              throw new l(void 0, { cause: e2.signal.reason });
            y(t2, n2);
          }
          return t2;
        }, some: O, find: async function(e2, t2) {
          for await (const r2 of C.call(this, e2, t2))
            return r2;
        } };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "../validators": 124, "./add-abort-signal": 107, "./compose": 109, "./end-of-stream": 113, "./utils": 122, "abort-controller": 24 }], 117: [function(e, t, r) {
        "use strict";
        const { ObjectSetPrototypeOf: n } = e("../../ours/primordials");
        t.exports = s;
        const i = e("./transform");
        function s(e2) {
          if (!(this instanceof s))
            return new s(e2);
          i.call(this, e2);
        }
        n(s.prototype, i.prototype), n(s, i), s.prototype._transform = function(e2, t2, r2) {
          r2(null, e2);
        };
      }, { "../../ours/primordials": 127, "./transform": 121 }], 118: [function(e, t, r) {
        const n = e("process/"), { ArrayIsArray: i, Promise: s, SymbolAsyncIterator: o } = e("../../ours/primordials"), a = e("./end-of-stream"), { once: l } = e("../../ours/util"), u = e("./destroy"), c = e("./duplex"), { aggregateTwoErrors: h, codes: { ERR_INVALID_ARG_TYPE: f, ERR_INVALID_RETURN_VALUE: d, ERR_MISSING_ARGS: p, ERR_STREAM_DESTROYED: b, ERR_STREAM_PREMATURE_CLOSE: g }, AbortError: m } = e("../../ours/errors"), { validateFunction: y, validateAbortSignal: _ } = e("../validators"), { isIterable: w, isReadable: v, isReadableNodeStream: S, isNodeStream: E, isTransformStream: A, isWebStream: k, isReadableStream: T, isReadableEnded: I } = e("./utils"), R = globalThis.AbortController || e("abort-controller").AbortController;
        let O, C;
        function P(e2, t2, r2) {
          let n2 = false;
          e2.on("close", () => {
            n2 = true;
          });
          return { destroy: (t3) => {
            n2 || (n2 = true, u.destroyer(e2, t3 || new b("pipe")));
          }, cleanup: a(e2, { readable: t2, writable: r2 }, (e3) => {
            n2 = !e3;
          }) };
        }
        function x(t2) {
          if (w(t2))
            return t2;
          if (S(t2))
            return async function* (t3) {
              C || (C = e("./readable"));
              yield* C.prototype[o].call(t3);
            }(t2);
          throw new f("val", ["Readable", "Iterable", "AsyncIterable"], t2);
        }
        async function M(e2, t2, r2, { end: n2 }) {
          let i2, o2 = null;
          const l2 = (e3) => {
            if (e3 && (i2 = e3), o2) {
              const e4 = o2;
              o2 = null, e4();
            }
          }, u2 = () => new s((e3, t3) => {
            i2 ? t3(i2) : o2 = () => {
              i2 ? t3(i2) : e3();
            };
          });
          t2.on("drain", l2);
          const c2 = a(t2, { readable: false }, l2);
          try {
            t2.writableNeedDrain && await u2();
            for await (const r3 of e2)
              t2.write(r3) || await u2();
            n2 && t2.end(), await u2(), r2();
          } catch (e3) {
            r2(i2 !== e3 ? h(i2, e3) : e3);
          } finally {
            c2(), t2.off("drain", l2);
          }
        }
        async function B(e2, t2, r2, { end: n2 }) {
          A(t2) && (t2 = t2.writable);
          const i2 = t2.getWriter();
          try {
            for await (const t3 of e2)
              await i2.ready, i2.write(t3).catch(() => {
              });
            await i2.ready, n2 && await i2.close(), r2();
          } catch (e3) {
            try {
              await i2.abort(e3), r2(e3);
            } catch (e4) {
              r2(e4);
            }
          }
        }
        function L(t2, r2, s2) {
          if (1 === t2.length && i(t2[0]) && (t2 = t2[0]), t2.length < 2)
            throw new p("streams");
          const o2 = new R(), a2 = o2.signal, l2 = null == s2 ? void 0 : s2.signal, u2 = [];
          function h2() {
            N(new m());
          }
          let b2, g2;
          _(l2, "options.signal"), null == l2 || l2.addEventListener("abort", h2);
          const y2 = [];
          let I2, C2 = 0;
          function L2(e2) {
            N(e2, 0 == --C2);
          }
          function N(e2, t3) {
            if (!e2 || b2 && "ERR_STREAM_PREMATURE_CLOSE" !== b2.code || (b2 = e2), b2 || t3) {
              for (; y2.length; )
                y2.shift()(b2);
              null == l2 || l2.removeEventListener("abort", h2), o2.abort(), t3 && (b2 || u2.forEach((e3) => e3()), n.nextTick(r2, b2, g2));
            }
          }
          for (let W = 0; W < t2.length; W++) {
            const q = t2[W], H = W < t2.length - 1, z = W > 0, V = H || false !== (null == s2 ? void 0 : s2.end), $ = W === t2.length - 1;
            if (E(q)) {
              let U2 = function(e2) {
                e2 && "AbortError" !== e2.name && "ERR_STREAM_PREMATURE_CLOSE" !== e2.code && L2(e2);
              };
              var U = U2;
              if (V) {
                const { destroy: K, cleanup: G } = P(q, H, z);
                y2.push(K), v(q) && $ && u2.push(G);
              }
              q.on("error", U2), v(q) && $ && u2.push(() => {
                q.removeListener("error", U2);
              });
            }
            if (0 === W)
              if ("function" == typeof q) {
                if (I2 = q({ signal: a2 }), !w(I2))
                  throw new d("Iterable, AsyncIterable or Stream", "source", I2);
              } else
                I2 = w(q) || S(q) || A(q) ? q : c.from(q);
            else if ("function" == typeof q) {
              var D;
              if (A(I2))
                I2 = x(null === (D = I2) || void 0 === D ? void 0 : D.readable);
              else
                I2 = x(I2);
              if (I2 = q(I2, { signal: a2 }), H) {
                if (!w(I2, true))
                  throw new d("AsyncIterable", `transform[${W - 1}]`, I2);
              } else {
                var F;
                O || (O = e("./passthrough"));
                const Q = new O({ objectMode: true }), Y = null === (F = I2) || void 0 === F ? void 0 : F.then;
                if ("function" == typeof Y)
                  C2++, Y.call(I2, (e2) => {
                    g2 = e2, null != e2 && Q.write(e2), V && Q.end(), n.nextTick(L2);
                  }, (e2) => {
                    Q.destroy(e2), n.nextTick(L2, e2);
                  });
                else if (w(I2, true))
                  C2++, M(I2, Q, L2, { end: V });
                else {
                  if (!T(I2) && !A(I2))
                    throw new d("AsyncIterable or Promise", "destination", I2);
                  {
                    const X = I2.readable || I2;
                    C2++, M(X, Q, L2, { end: V });
                  }
                }
                I2 = Q;
                const { destroy: J, cleanup: Z } = P(I2, false, true);
                y2.push(J), $ && u2.push(Z);
              }
            } else if (E(q)) {
              if (S(I2)) {
                C2 += 2;
                const ee = j(I2, q, L2, { end: V });
                v(q) && $ && u2.push(ee);
              } else if (A(I2) || T(I2)) {
                const te = I2.readable || I2;
                C2++, M(te, q, L2, { end: V });
              } else {
                if (!w(I2))
                  throw new f("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], I2);
                C2++, M(I2, q, L2, { end: V });
              }
              I2 = q;
            } else if (k(q)) {
              if (S(I2))
                C2++, B(x(I2), q, L2, { end: V });
              else if (T(I2) || w(I2))
                C2++, B(I2, q, L2, { end: V });
              else {
                if (!A(I2))
                  throw new f("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], I2);
                C2++, B(I2.readable, q, L2, { end: V });
              }
              I2 = q;
            } else
              I2 = c.from(q);
          }
          return (null != a2 && a2.aborted || null != l2 && l2.aborted) && n.nextTick(h2), I2;
        }
        function j(e2, t2, r2, { end: i2 }) {
          let s2 = false;
          if (t2.on("close", () => {
            s2 || r2(new g());
          }), e2.pipe(t2, { end: false }), i2) {
            let o3 = function() {
              s2 = true, t2.end();
            };
            var o2 = o3;
            I(e2) ? n.nextTick(o3) : e2.once("end", o3);
          } else
            r2();
          return a(e2, { readable: true, writable: false }, (t3) => {
            const n2 = e2._readableState;
            t3 && "ERR_STREAM_PREMATURE_CLOSE" === t3.code && n2 && n2.ended && !n2.errored && !n2.errorEmitted ? e2.once("end", r2).once("error", r2) : r2(t3);
          }), a(t2, { readable: false, writable: true }, r2);
        }
        t.exports = { pipelineImpl: L, pipeline: function(...e2) {
          return L(e2, l(function(e3) {
            return y(e3[e3.length - 1], "streams[stream.length - 1]"), e3.pop();
          }(e2)));
        } };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "../../ours/util": 128, "../validators": 124, "./destroy": 110, "./duplex": 111, "./end-of-stream": 113, "./passthrough": 117, "./readable": 119, "./utils": 122, "abort-controller": 24, "process/": 102 }], 119: [function(e, t, r) {
        const n = e("process/"), { ArrayPrototypeIndexOf: i, NumberIsInteger: s, NumberIsNaN: o, NumberParseInt: a, ObjectDefineProperties: l, ObjectKeys: u, ObjectSetPrototypeOf: c, Promise: h, SafeSet: f, SymbolAsyncIterator: d, Symbol: p } = e("../../ours/primordials");
        t.exports = D, D.ReadableState = U;
        const { EventEmitter: b } = e("events"), { Stream: g, prependListener: m } = e("./legacy"), { Buffer: y } = e("buffer"), { addAbortSignal: _ } = e("./add-abort-signal"), w = e("./end-of-stream");
        let v = e("../../ours/util").debuglog("stream", (e2) => {
          v = e2;
        });
        const S = e("./buffer_list"), E = e("./destroy"), { getHighWaterMark: A, getDefaultHighWaterMark: k } = e("./state"), { aggregateTwoErrors: T, codes: { ERR_INVALID_ARG_TYPE: I, ERR_METHOD_NOT_IMPLEMENTED: R, ERR_OUT_OF_RANGE: O, ERR_STREAM_PUSH_AFTER_EOF: C, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: P } } = e("../../ours/errors"), { validateObject: x } = e("../validators"), M = p("kPaused"), { StringDecoder: B } = e("string_decoder"), L = e("./from");
        c(D.prototype, g.prototype), c(D, g);
        const j = () => {
        }, { errorOrDestroy: N } = E;
        function U(t2, r2, n2) {
          "boolean" != typeof n2 && (n2 = r2 instanceof e("./duplex")), this.objectMode = !(!t2 || !t2.objectMode), n2 && (this.objectMode = this.objectMode || !(!t2 || !t2.readableObjectMode)), this.highWaterMark = t2 ? A(this, t2, "readableHighWaterMark", n2) : k(false), this.buffer = new S(), this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[M] = null, this.errorEmitted = false, this.emitClose = !t2 || false !== t2.emitClose, this.autoDestroy = !t2 || false !== t2.autoDestroy, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t2 && t2.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t2 && t2.encoding && (this.decoder = new B(t2.encoding), this.encoding = t2.encoding);
        }
        function D(t2) {
          if (!(this instanceof D))
            return new D(t2);
          const r2 = this instanceof e("./duplex");
          this._readableState = new U(t2, this, r2), t2 && ("function" == typeof t2.read && (this._read = t2.read), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.construct && (this._construct = t2.construct), t2.signal && !r2 && _(t2.signal, this)), g.call(this, t2), E.construct(this, () => {
            this._readableState.needReadable && V(this, this._readableState);
          });
        }
        function F(e2, t2, r2, n2) {
          v("readableAddChunk", t2);
          const i2 = e2._readableState;
          let s2;
          if (i2.objectMode || ("string" == typeof t2 ? (r2 = r2 || i2.defaultEncoding, i2.encoding !== r2 && (n2 && i2.encoding ? t2 = y.from(t2, r2).toString(i2.encoding) : (t2 = y.from(t2, r2), r2 = ""))) : t2 instanceof y ? r2 = "" : g._isUint8Array(t2) ? (t2 = g._uint8ArrayToBuffer(t2), r2 = "") : null != t2 && (s2 = new I("chunk", ["string", "Buffer", "Uint8Array"], t2))), s2)
            N(e2, s2);
          else if (null === t2)
            i2.reading = false, function(e3, t3) {
              if (v("onEofChunk"), t3.ended)
                return;
              if (t3.decoder) {
                const e4 = t3.decoder.end();
                e4 && e4.length && (t3.buffer.push(e4), t3.length += t3.objectMode ? 1 : e4.length);
              }
              t3.ended = true, t3.sync ? H(e3) : (t3.needReadable = false, t3.emittedReadable = true, z(e3));
            }(e2, i2);
          else if (i2.objectMode || t2 && t2.length > 0)
            if (n2)
              if (i2.endEmitted)
                N(e2, new P());
              else {
                if (i2.destroyed || i2.errored)
                  return false;
                W(e2, i2, t2, true);
              }
            else if (i2.ended)
              N(e2, new C());
            else {
              if (i2.destroyed || i2.errored)
                return false;
              i2.reading = false, i2.decoder && !r2 ? (t2 = i2.decoder.write(t2), i2.objectMode || 0 !== t2.length ? W(e2, i2, t2, false) : V(e2, i2)) : W(e2, i2, t2, false);
            }
          else
            n2 || (i2.reading = false, V(e2, i2));
          return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
        }
        function W(e2, t2, r2, n2) {
          t2.flowing && 0 === t2.length && !t2.sync && e2.listenerCount("data") > 0 ? (t2.multiAwaitDrain ? t2.awaitDrainWriters.clear() : t2.awaitDrainWriters = null, t2.dataEmitted = true, e2.emit("data", r2)) : (t2.length += t2.objectMode ? 1 : r2.length, n2 ? t2.buffer.unshift(r2) : t2.buffer.push(r2), t2.needReadable && H(e2)), V(e2, t2);
        }
        D.prototype.destroy = E.destroy, D.prototype._undestroy = E.undestroy, D.prototype._destroy = function(e2, t2) {
          t2(e2);
        }, D.prototype[b.captureRejectionSymbol] = function(e2) {
          this.destroy(e2);
        }, D.prototype.push = function(e2, t2) {
          return F(this, e2, t2, false);
        }, D.prototype.unshift = function(e2, t2) {
          return F(this, e2, t2, true);
        }, D.prototype.isPaused = function() {
          const e2 = this._readableState;
          return true === e2[M] || false === e2.flowing;
        }, D.prototype.setEncoding = function(e2) {
          const t2 = new B(e2);
          this._readableState.decoder = t2, this._readableState.encoding = this._readableState.decoder.encoding;
          const r2 = this._readableState.buffer;
          let n2 = "";
          for (const e3 of r2)
            n2 += t2.write(e3);
          return r2.clear(), "" !== n2 && r2.push(n2), this._readableState.length = n2.length, this;
        };
        function q(e2, t2) {
          return e2 <= 0 || 0 === t2.length && t2.ended ? 0 : t2.objectMode ? 1 : o(e2) ? t2.flowing && t2.length ? t2.buffer.first().length : t2.length : e2 <= t2.length ? e2 : t2.ended ? t2.length : 0;
        }
        function H(e2) {
          const t2 = e2._readableState;
          v("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (v("emitReadable", t2.flowing), t2.emittedReadable = true, n.nextTick(z, e2));
        }
        function z(e2) {
          const t2 = e2._readableState;
          v("emitReadable_", t2.destroyed, t2.length, t2.ended), t2.destroyed || t2.errored || !t2.length && !t2.ended || (e2.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, Y(e2);
        }
        function V(e2, t2) {
          !t2.readingMore && t2.constructed && (t2.readingMore = true, n.nextTick($, e2, t2));
        }
        function $(e2, t2) {
          for (; !t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && 0 === t2.length); ) {
            const r2 = t2.length;
            if (v("maybeReadMore read 0"), e2.read(0), r2 === t2.length)
              break;
          }
          t2.readingMore = false;
        }
        function K(e2) {
          const t2 = e2._readableState;
          t2.readableListening = e2.listenerCount("readable") > 0, t2.resumeScheduled && false === t2[M] ? t2.flowing = true : e2.listenerCount("data") > 0 ? e2.resume() : t2.readableListening || (t2.flowing = null);
        }
        function G(e2) {
          v("readable nexttick read 0"), e2.read(0);
        }
        function Q(e2, t2) {
          v("resume", t2.reading), t2.reading || e2.read(0), t2.resumeScheduled = false, e2.emit("resume"), Y(e2), t2.flowing && !t2.reading && e2.read(0);
        }
        function Y(e2) {
          const t2 = e2._readableState;
          for (v("flow", t2.flowing); t2.flowing && null !== e2.read(); )
            ;
        }
        function J(e2, t2) {
          "function" != typeof e2.read && (e2 = D.wrap(e2, { objectMode: true }));
          const r2 = async function* (e3, t3) {
            let r3, n2 = j;
            function i2(t4) {
              this === e3 ? (n2(), n2 = j) : n2 = t4;
            }
            e3.on("readable", i2);
            const s2 = w(e3, { writable: false }, (e4) => {
              r3 = e4 ? T(r3, e4) : null, n2(), n2 = j;
            });
            try {
              for (; ; ) {
                const t4 = e3.destroyed ? null : e3.read();
                if (null !== t4)
                  yield t4;
                else {
                  if (r3)
                    throw r3;
                  if (null === r3)
                    return;
                  await new h(i2);
                }
              }
            } catch (e4) {
              throw r3 = T(r3, e4), r3;
            } finally {
              !r3 && false === (null == t3 ? void 0 : t3.destroyOnReturn) || void 0 !== r3 && !e3._readableState.autoDestroy ? (e3.off("readable", i2), s2()) : E.destroyer(e3, null);
            }
          }(e2, t2);
          return r2.stream = e2, r2;
        }
        function Z(e2, t2) {
          if (0 === t2.length)
            return null;
          let r2;
          return t2.objectMode ? r2 = t2.buffer.shift() : !e2 || e2 >= t2.length ? (r2 = t2.decoder ? t2.buffer.join("") : 1 === t2.buffer.length ? t2.buffer.first() : t2.buffer.concat(t2.length), t2.buffer.clear()) : r2 = t2.buffer.consume(e2, t2.decoder), r2;
        }
        function X(e2) {
          const t2 = e2._readableState;
          v("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, n.nextTick(ee, t2, e2));
        }
        function ee(e2, t2) {
          if (v("endReadableNT", e2.endEmitted, e2.length), !e2.errored && !e2.closeEmitted && !e2.endEmitted && 0 === e2.length) {
            if (e2.endEmitted = true, t2.emit("end"), t2.writable && false === t2.allowHalfOpen)
              n.nextTick(te, t2);
            else if (e2.autoDestroy) {
              const e3 = t2._writableState;
              (!e3 || e3.autoDestroy && (e3.finished || false === e3.writable)) && t2.destroy();
            }
          }
        }
        function te(e2) {
          e2.writable && !e2.writableEnded && !e2.destroyed && e2.end();
        }
        let re;
        function ne() {
          return void 0 === re && (re = {}), re;
        }
        D.prototype.read = function(e2) {
          v("read", e2), void 0 === e2 ? e2 = NaN : s(e2) || (e2 = a(e2, 10));
          const t2 = this._readableState, r2 = e2;
          if (e2 > t2.highWaterMark && (t2.highWaterMark = function(e3) {
            if (e3 > 1073741824)
              throw new O("size", "<= 1GiB", e3);
            return e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, ++e3;
          }(e2)), 0 !== e2 && (t2.emittedReadable = false), 0 === e2 && t2.needReadable && ((0 !== t2.highWaterMark ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
            return v("read: emitReadable", t2.length, t2.ended), 0 === t2.length && t2.ended ? X(this) : H(this), null;
          if (0 === (e2 = q(e2, t2)) && t2.ended)
            return 0 === t2.length && X(this), null;
          let n2, i2 = t2.needReadable;
          if (v("need readable", i2), (0 === t2.length || t2.length - e2 < t2.highWaterMark) && (i2 = true, v("length less than watermark", i2)), t2.ended || t2.reading || t2.destroyed || t2.errored || !t2.constructed)
            i2 = false, v("reading, ended or constructing", i2);
          else if (i2) {
            v("do read"), t2.reading = true, t2.sync = true, 0 === t2.length && (t2.needReadable = true);
            try {
              this._read(t2.highWaterMark);
            } catch (e3) {
              N(this, e3);
            }
            t2.sync = false, t2.reading || (e2 = q(r2, t2));
          }
          return n2 = e2 > 0 ? Z(e2, t2) : null, null === n2 ? (t2.needReadable = t2.length <= t2.highWaterMark, e2 = 0) : (t2.length -= e2, t2.multiAwaitDrain ? t2.awaitDrainWriters.clear() : t2.awaitDrainWriters = null), 0 === t2.length && (t2.ended || (t2.needReadable = true), r2 !== e2 && t2.ended && X(this)), null === n2 || t2.errorEmitted || t2.closeEmitted || (t2.dataEmitted = true, this.emit("data", n2)), n2;
        }, D.prototype._read = function(e2) {
          throw new R("_read()");
        }, D.prototype.pipe = function(e2, t2) {
          const r2 = this, i2 = this._readableState;
          1 === i2.pipes.length && (i2.multiAwaitDrain || (i2.multiAwaitDrain = true, i2.awaitDrainWriters = new f(i2.awaitDrainWriters ? [i2.awaitDrainWriters] : []))), i2.pipes.push(e2), v("pipe count=%d opts=%j", i2.pipes.length, t2);
          const s2 = (!t2 || false !== t2.end) && e2 !== n.stdout && e2 !== n.stderr ? a2 : g2;
          function o2(t3, n2) {
            v("onunpipe"), t3 === r2 && n2 && false === n2.hasUnpiped && (n2.hasUnpiped = true, function() {
              v("cleanup"), e2.removeListener("close", p2), e2.removeListener("finish", b2), l2 && e2.removeListener("drain", l2);
              e2.removeListener("error", d2), e2.removeListener("unpipe", o2), r2.removeListener("end", a2), r2.removeListener("end", g2), r2.removeListener("data", h2), u2 = true, l2 && i2.awaitDrainWriters && (!e2._writableState || e2._writableState.needDrain) && l2();
            }());
          }
          function a2() {
            v("onend"), e2.end();
          }
          let l2;
          i2.endEmitted ? n.nextTick(s2) : r2.once("end", s2), e2.on("unpipe", o2);
          let u2 = false;
          function c2() {
            u2 || (1 === i2.pipes.length && i2.pipes[0] === e2 ? (v("false write response, pause", 0), i2.awaitDrainWriters = e2, i2.multiAwaitDrain = false) : i2.pipes.length > 1 && i2.pipes.includes(e2) && (v("false write response, pause", i2.awaitDrainWriters.size), i2.awaitDrainWriters.add(e2)), r2.pause()), l2 || (l2 = function(e3, t3) {
              return function() {
                const r3 = e3._readableState;
                r3.awaitDrainWriters === t3 ? (v("pipeOnDrain", 1), r3.awaitDrainWriters = null) : r3.multiAwaitDrain && (v("pipeOnDrain", r3.awaitDrainWriters.size), r3.awaitDrainWriters.delete(t3)), r3.awaitDrainWriters && 0 !== r3.awaitDrainWriters.size || !e3.listenerCount("data") || e3.resume();
              };
            }(r2, e2), e2.on("drain", l2));
          }
          function h2(t3) {
            v("ondata");
            const r3 = e2.write(t3);
            v("dest.write", r3), false === r3 && c2();
          }
          function d2(t3) {
            if (v("onerror", t3), g2(), e2.removeListener("error", d2), 0 === e2.listenerCount("error")) {
              const r3 = e2._writableState || e2._readableState;
              r3 && !r3.errorEmitted ? N(e2, t3) : e2.emit("error", t3);
            }
          }
          function p2() {
            e2.removeListener("finish", b2), g2();
          }
          function b2() {
            v("onfinish"), e2.removeListener("close", p2), g2();
          }
          function g2() {
            v("unpipe"), r2.unpipe(e2);
          }
          return r2.on("data", h2), m(e2, "error", d2), e2.once("close", p2), e2.once("finish", b2), e2.emit("pipe", r2), true === e2.writableNeedDrain ? i2.flowing && c2() : i2.flowing || (v("pipe resume"), r2.resume()), e2;
        }, D.prototype.unpipe = function(e2) {
          const t2 = this._readableState;
          if (0 === t2.pipes.length)
            return this;
          if (!e2) {
            const e3 = t2.pipes;
            t2.pipes = [], this.pause();
            for (let t3 = 0; t3 < e3.length; t3++)
              e3[t3].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          const r2 = i(t2.pipes, e2);
          return -1 === r2 || (t2.pipes.splice(r2, 1), 0 === t2.pipes.length && this.pause(), e2.emit("unpipe", this, { hasUnpiped: false })), this;
        }, D.prototype.on = function(e2, t2) {
          const r2 = g.prototype.on.call(this, e2, t2), i2 = this._readableState;
          return "data" === e2 ? (i2.readableListening = this.listenerCount("readable") > 0, false !== i2.flowing && this.resume()) : "readable" === e2 && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, v("on readable", i2.length, i2.reading), i2.length ? H(this) : i2.reading || n.nextTick(G, this))), r2;
        }, D.prototype.addListener = D.prototype.on, D.prototype.removeListener = function(e2, t2) {
          const r2 = g.prototype.removeListener.call(this, e2, t2);
          return "readable" === e2 && n.nextTick(K, this), r2;
        }, D.prototype.off = D.prototype.removeListener, D.prototype.removeAllListeners = function(e2) {
          const t2 = g.prototype.removeAllListeners.apply(this, arguments);
          return "readable" !== e2 && void 0 !== e2 || n.nextTick(K, this), t2;
        }, D.prototype.resume = function() {
          const e2 = this._readableState;
          return e2.flowing || (v("resume"), e2.flowing = !e2.readableListening, function(e3, t2) {
            t2.resumeScheduled || (t2.resumeScheduled = true, n.nextTick(Q, e3, t2));
          }(this, e2)), e2[M] = false, this;
        }, D.prototype.pause = function() {
          return v("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (v("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[M] = true, this;
        }, D.prototype.wrap = function(e2) {
          let t2 = false;
          e2.on("data", (r3) => {
            !this.push(r3) && e2.pause && (t2 = true, e2.pause());
          }), e2.on("end", () => {
            this.push(null);
          }), e2.on("error", (e3) => {
            N(this, e3);
          }), e2.on("close", () => {
            this.destroy();
          }), e2.on("destroy", () => {
            this.destroy();
          }), this._read = () => {
            t2 && e2.resume && (t2 = false, e2.resume());
          };
          const r2 = u(e2);
          for (let t3 = 1; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            void 0 === this[n2] && "function" == typeof e2[n2] && (this[n2] = e2[n2].bind(e2));
          }
          return this;
        }, D.prototype[d] = function() {
          return J(this);
        }, D.prototype.iterator = function(e2) {
          return void 0 !== e2 && x(e2, "options"), J(this, e2);
        }, l(D.prototype, { readable: { __proto__: null, get() {
          const e2 = this._readableState;
          return !(!e2 || false === e2.readable || e2.destroyed || e2.errorEmitted || e2.endEmitted);
        }, set(e2) {
          this._readableState && (this._readableState.readable = !!e2);
        } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.dataEmitted;
        } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
          return !(false === this._readableState.readable || !this._readableState.destroyed && !this._readableState.errored || this._readableState.endEmitted);
        } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(e2) {
          this._readableState && (this._readableState.flowing = e2);
        } }, readableLength: { __proto__: null, enumerable: false, get() {
          return this._readableState.length;
        } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.objectMode;
        } }, readableEncoding: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.encoding : null;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._readableState ? this._readableState.errored : null;
        } }, closed: { __proto__: null, get() {
          return !!this._readableState && this._readableState.closed;
        } }, destroyed: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.destroyed;
        }, set(e2) {
          this._readableState && (this._readableState.destroyed = e2);
        } }, readableEnded: { __proto__: null, enumerable: false, get() {
          return !!this._readableState && this._readableState.endEmitted;
        } } }), l(U.prototype, { pipesCount: { __proto__: null, get() {
          return this.pipes.length;
        } }, paused: { __proto__: null, get() {
          return false !== this[M];
        }, set(e2) {
          this[M] = !!e2;
        } } }), D._fromList = Z, D.from = function(e2, t2) {
          return L(D, e2, t2);
        }, D.fromWeb = function(e2, t2) {
          return ne().newStreamReadableFromReadableStream(e2, t2);
        }, D.toWeb = function(e2, t2) {
          return ne().newReadableStreamFromStreamReadable(e2, t2);
        }, D.wrap = function(e2, t2) {
          var r2, n2;
          return new D({ objectMode: null === (r2 = null !== (n2 = e2.readableObjectMode) && void 0 !== n2 ? n2 : e2.objectMode) || void 0 === r2 || r2, ...t2, destroy(t3, r3) {
            E.destroyer(e2, t3), r3(t3);
          } }).wrap(e2);
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "../../ours/util": 128, "../validators": 124, "./add-abort-signal": 107, "./buffer_list": 108, "./destroy": 110, "./duplex": 111, "./end-of-stream": 113, "./from": 114, "./legacy": 115, "./state": 120, buffer: 29, events: 49, "process/": 102, string_decoder: 28 }], 120: [function(e, t, r) {
        "use strict";
        const { MathFloor: n, NumberIsInteger: i } = e("../../ours/primordials"), { ERR_INVALID_ARG_VALUE: s } = e("../../ours/errors").codes;
        function o(e2) {
          return e2 ? 16 : 16384;
        }
        t.exports = { getHighWaterMark: function(e2, t2, r2, a) {
          const l = function(e3, t3, r3) {
            return null != e3.highWaterMark ? e3.highWaterMark : t3 ? e3[r3] : null;
          }(t2, a, r2);
          if (null != l) {
            if (!i(l) || l < 0) {
              throw new s(a ? `options.${r2}` : "options.highWaterMark", l);
            }
            return n(l);
          }
          return o(e2.objectMode);
        }, getDefaultHighWaterMark: o };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127 }], 121: [function(e, t, r) {
        "use strict";
        const { ObjectSetPrototypeOf: n, Symbol: i } = e("../../ours/primordials");
        t.exports = u;
        const { ERR_METHOD_NOT_IMPLEMENTED: s } = e("../../ours/errors").codes, o = e("./duplex"), { getHighWaterMark: a } = e("./state");
        n(u.prototype, o.prototype), n(u, o);
        const l = i("kCallback");
        function u(e2) {
          if (!(this instanceof u))
            return new u(e2);
          const t2 = e2 ? a(this, e2, "readableHighWaterMark", true) : null;
          0 === t2 && (e2 = { ...e2, highWaterMark: null, readableHighWaterMark: t2, writableHighWaterMark: e2.writableHighWaterMark || 0 }), o.call(this, e2), this._readableState.sync = false, this[l] = null, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", h);
        }
        function c(e2) {
          "function" != typeof this._flush || this.destroyed ? (this.push(null), e2 && e2()) : this._flush((t2, r2) => {
            t2 ? e2 ? e2(t2) : this.destroy(t2) : (null != r2 && this.push(r2), this.push(null), e2 && e2());
          });
        }
        function h() {
          this._final !== c && c.call(this);
        }
        u.prototype._final = c, u.prototype._transform = function(e2, t2, r2) {
          throw new s("_transform()");
        }, u.prototype._write = function(e2, t2, r2) {
          const n2 = this._readableState, i2 = this._writableState, s2 = n2.length;
          this._transform(e2, t2, (e3, t3) => {
            e3 ? r2(e3) : (null != t3 && this.push(t3), i2.ended || s2 === n2.length || n2.length < n2.highWaterMark ? r2() : this[l] = r2);
          });
        }, u.prototype._read = function() {
          if (this[l]) {
            const e2 = this[l];
            this[l] = null, e2();
          }
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "./duplex": 111, "./state": 120 }], 122: [function(e, t, r) {
        "use strict";
        const { Symbol: n, SymbolAsyncIterator: i, SymbolIterator: s, SymbolFor: o } = e("../../ours/primordials"), a = n("kDestroyed"), l = n("kIsErrored"), u = n("kIsReadable"), c = n("kIsDisturbed"), h = o("nodejs.webstream.isClosedPromise"), f = o("nodejs.webstream.controllerErrorFunction");
        function d(e2, t2 = false) {
          var r2;
          return !(!e2 || "function" != typeof e2.pipe || "function" != typeof e2.on || t2 && ("function" != typeof e2.pause || "function" != typeof e2.resume) || e2._writableState && false === (null === (r2 = e2._readableState) || void 0 === r2 ? void 0 : r2.readable) || e2._writableState && !e2._readableState);
        }
        function p(e2) {
          var t2;
          return !(!e2 || "function" != typeof e2.write || "function" != typeof e2.on || e2._readableState && false === (null === (t2 = e2._writableState) || void 0 === t2 ? void 0 : t2.writable));
        }
        function b(e2) {
          return e2 && (e2._readableState || e2._writableState || "function" == typeof e2.write && "function" == typeof e2.on || "function" == typeof e2.pipe && "function" == typeof e2.on);
        }
        function g(e2) {
          return !(!e2 || b(e2) || "function" != typeof e2.pipeThrough || "function" != typeof e2.getReader || "function" != typeof e2.cancel);
        }
        function m(e2) {
          return !(!e2 || b(e2) || "function" != typeof e2.getWriter || "function" != typeof e2.abort);
        }
        function y(e2) {
          return !(!e2 || b(e2) || "object" != typeof e2.readable || "object" != typeof e2.writable);
        }
        function _(e2) {
          if (!b(e2))
            return null;
          const t2 = e2._writableState, r2 = e2._readableState, n2 = t2 || r2;
          return !!(e2.destroyed || e2[a] || null != n2 && n2.destroyed);
        }
        function w(e2) {
          if (!p(e2))
            return null;
          if (true === e2.writableEnded)
            return true;
          const t2 = e2._writableState;
          return (null == t2 || !t2.errored) && ("boolean" != typeof (null == t2 ? void 0 : t2.ended) ? null : t2.ended);
        }
        function v(e2, t2) {
          if (!d(e2))
            return null;
          const r2 = e2._readableState;
          return (null == r2 || !r2.errored) && ("boolean" != typeof (null == r2 ? void 0 : r2.endEmitted) ? null : !!(r2.endEmitted || false === t2 && true === r2.ended && 0 === r2.length));
        }
        function S(e2) {
          return e2 && null != e2[u] ? e2[u] : "boolean" != typeof (null == e2 ? void 0 : e2.readable) ? null : !_(e2) && (d(e2) && e2.readable && !v(e2));
        }
        function E(e2) {
          return "boolean" != typeof (null == e2 ? void 0 : e2.writable) ? null : !_(e2) && (p(e2) && e2.writable && !w(e2));
        }
        function A(e2) {
          return "boolean" == typeof e2._closed && "boolean" == typeof e2._defaultKeepAlive && "boolean" == typeof e2._removedConnection && "boolean" == typeof e2._removedContLen;
        }
        function k(e2) {
          return "boolean" == typeof e2._sent100 && A(e2);
        }
        t.exports = { kDestroyed: a, isDisturbed: function(e2) {
          var t2;
          return !(!e2 || !(null !== (t2 = e2[c]) && void 0 !== t2 ? t2 : e2.readableDidRead || e2.readableAborted));
        }, kIsDisturbed: c, isErrored: function(e2) {
          var t2, r2, n2, i2, s2, o2, a2, u2, c2, h2;
          return !(!e2 || !(null !== (t2 = null !== (r2 = null !== (n2 = null !== (i2 = null !== (s2 = null !== (o2 = e2[l]) && void 0 !== o2 ? o2 : e2.readableErrored) && void 0 !== s2 ? s2 : e2.writableErrored) && void 0 !== i2 ? i2 : null === (a2 = e2._readableState) || void 0 === a2 ? void 0 : a2.errorEmitted) && void 0 !== n2 ? n2 : null === (u2 = e2._writableState) || void 0 === u2 ? void 0 : u2.errorEmitted) && void 0 !== r2 ? r2 : null === (c2 = e2._readableState) || void 0 === c2 ? void 0 : c2.errored) && void 0 !== t2 ? t2 : null === (h2 = e2._writableState) || void 0 === h2 ? void 0 : h2.errored));
        }, kIsErrored: l, isReadable: S, kIsReadable: u, kIsClosedPromise: h, kControllerErrorFunction: f, isClosed: function(e2) {
          if (!b(e2))
            return null;
          if ("boolean" == typeof e2.closed)
            return e2.closed;
          const t2 = e2._writableState, r2 = e2._readableState;
          return "boolean" == typeof (null == t2 ? void 0 : t2.closed) || "boolean" == typeof (null == r2 ? void 0 : r2.closed) ? (null == t2 ? void 0 : t2.closed) || (null == r2 ? void 0 : r2.closed) : "boolean" == typeof e2._closed && A(e2) ? e2._closed : null;
        }, isDestroyed: _, isDuplexNodeStream: function(e2) {
          return !(!e2 || "function" != typeof e2.pipe || !e2._readableState || "function" != typeof e2.on || "function" != typeof e2.write);
        }, isFinished: function(e2, t2) {
          return b(e2) ? !!_(e2) || (false === (null == t2 ? void 0 : t2.readable) || !S(e2)) && (false === (null == t2 ? void 0 : t2.writable) || !E(e2)) : null;
        }, isIterable: function(e2, t2) {
          return null != e2 && (true === t2 ? "function" == typeof e2[i] : false === t2 ? "function" == typeof e2[s] : "function" == typeof e2[i] || "function" == typeof e2[s]);
        }, isReadableNodeStream: d, isReadableStream: g, isReadableEnded: function(e2) {
          if (!d(e2))
            return null;
          if (true === e2.readableEnded)
            return true;
          const t2 = e2._readableState;
          return !(!t2 || t2.errored) && ("boolean" != typeof (null == t2 ? void 0 : t2.ended) ? null : t2.ended);
        }, isReadableFinished: v, isReadableErrored: function(e2) {
          var t2, r2;
          return b(e2) ? e2.readableErrored ? e2.readableErrored : null !== (t2 = null === (r2 = e2._readableState) || void 0 === r2 ? void 0 : r2.errored) && void 0 !== t2 ? t2 : null : null;
        }, isNodeStream: b, isWebStream: function(e2) {
          return g(e2) || m(e2) || y(e2);
        }, isWritable: E, isWritableNodeStream: p, isWritableStream: m, isWritableEnded: w, isWritableFinished: function(e2, t2) {
          if (!p(e2))
            return null;
          if (true === e2.writableFinished)
            return true;
          const r2 = e2._writableState;
          return (null == r2 || !r2.errored) && ("boolean" != typeof (null == r2 ? void 0 : r2.finished) ? null : !!(r2.finished || false === t2 && true === r2.ended && 0 === r2.length));
        }, isWritableErrored: function(e2) {
          var t2, r2;
          return b(e2) ? e2.writableErrored ? e2.writableErrored : null !== (t2 = null === (r2 = e2._writableState) || void 0 === r2 ? void 0 : r2.errored) && void 0 !== t2 ? t2 : null : null;
        }, isServerRequest: function(e2) {
          var t2;
          return "boolean" == typeof e2._consuming && "boolean" == typeof e2._dumped && void 0 === (null === (t2 = e2.req) || void 0 === t2 ? void 0 : t2.upgradeOrConnect);
        }, isServerResponse: k, willEmitClose: function(e2) {
          if (!b(e2))
            return null;
          const t2 = e2._writableState, r2 = e2._readableState, n2 = t2 || r2;
          return !n2 && k(e2) || !!(n2 && n2.autoDestroy && n2.emitClose && false === n2.closed);
        }, isTransformStream: y };
      }, { "../../ours/primordials": 127 }], 123: [function(e, t, r) {
        const n = e("process/"), { ArrayPrototypeSlice: i, Error: s, FunctionPrototypeSymbolHasInstance: o, ObjectDefineProperty: a, ObjectDefineProperties: l, ObjectSetPrototypeOf: u, StringPrototypeToLowerCase: c, Symbol: h, SymbolHasInstance: f } = e("../../ours/primordials");
        t.exports = B, B.WritableState = x;
        const { EventEmitter: d } = e("events"), p = e("./legacy").Stream, { Buffer: b } = e("buffer"), g = e("./destroy"), { addAbortSignal: m } = e("./add-abort-signal"), { getHighWaterMark: y, getDefaultHighWaterMark: _ } = e("./state"), { ERR_INVALID_ARG_TYPE: w, ERR_METHOD_NOT_IMPLEMENTED: v, ERR_MULTIPLE_CALLBACK: S, ERR_STREAM_CANNOT_PIPE: E, ERR_STREAM_DESTROYED: A, ERR_STREAM_ALREADY_FINISHED: k, ERR_STREAM_NULL_VALUES: T, ERR_STREAM_WRITE_AFTER_END: I, ERR_UNKNOWN_ENCODING: R } = e("../../ours/errors").codes, { errorOrDestroy: O } = g;
        function C() {
        }
        u(B.prototype, p.prototype), u(B, p);
        const P = h("kOnFinished");
        function x(t2, r2, n2) {
          "boolean" != typeof n2 && (n2 = r2 instanceof e("./duplex")), this.objectMode = !(!t2 || !t2.objectMode), n2 && (this.objectMode = this.objectMode || !(!t2 || !t2.writableObjectMode)), this.highWaterMark = t2 ? y(this, t2, "writableHighWaterMark", n2) : _(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          const i2 = !(!t2 || false !== t2.decodeStrings);
          this.decodeStrings = !i2, this.defaultEncoding = t2 && t2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = U.bind(void 0, r2), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, M(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t2 || false !== t2.emitClose, this.autoDestroy = !t2 || false !== t2.autoDestroy, this.errored = null, this.closed = false, this.closeEmitted = false, this[P] = [];
        }
        function M(e2) {
          e2.buffered = [], e2.bufferedIndex = 0, e2.allBuffers = true, e2.allNoop = true;
        }
        function B(t2) {
          const r2 = this instanceof e("./duplex");
          if (!r2 && !o(B, this))
            return new B(t2);
          this._writableState = new x(t2, this, r2), t2 && ("function" == typeof t2.write && (this._write = t2.write), "function" == typeof t2.writev && (this._writev = t2.writev), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.final && (this._final = t2.final), "function" == typeof t2.construct && (this._construct = t2.construct), t2.signal && m(t2.signal, this)), p.call(this, t2), g.construct(this, () => {
            const e2 = this._writableState;
            e2.writing || q(this, e2), V(this, e2);
          });
        }
        function L(e2, t2, r2, i2) {
          const s2 = e2._writableState;
          if ("function" == typeof r2)
            i2 = r2, r2 = s2.defaultEncoding;
          else {
            if (r2) {
              if ("buffer" !== r2 && !b.isEncoding(r2))
                throw new R(r2);
            } else
              r2 = s2.defaultEncoding;
            "function" != typeof i2 && (i2 = C);
          }
          if (null === t2)
            throw new T();
          if (!s2.objectMode)
            if ("string" == typeof t2)
              false !== s2.decodeStrings && (t2 = b.from(t2, r2), r2 = "buffer");
            else if (t2 instanceof b)
              r2 = "buffer";
            else {
              if (!p._isUint8Array(t2))
                throw new w("chunk", ["string", "Buffer", "Uint8Array"], t2);
              t2 = p._uint8ArrayToBuffer(t2), r2 = "buffer";
            }
          let o2;
          return s2.ending ? o2 = new I() : s2.destroyed && (o2 = new A("write")), o2 ? (n.nextTick(i2, o2), O(e2, o2, true), o2) : (s2.pendingcb++, function(e3, t3, r3, n2, i3) {
            const s3 = t3.objectMode ? 1 : r3.length;
            t3.length += s3;
            const o3 = t3.length < t3.highWaterMark;
            o3 || (t3.needDrain = true);
            t3.writing || t3.corked || t3.errored || !t3.constructed ? (t3.buffered.push({ chunk: r3, encoding: n2, callback: i3 }), t3.allBuffers && "buffer" !== n2 && (t3.allBuffers = false), t3.allNoop && i3 !== C && (t3.allNoop = false)) : (t3.writelen = s3, t3.writecb = i3, t3.writing = true, t3.sync = true, e3._write(r3, n2, t3.onwrite), t3.sync = false);
            return o3 && !t3.errored && !t3.destroyed;
          }(e2, s2, t2, r2, i2));
        }
        function j(e2, t2, r2, n2, i2, s2, o2) {
          t2.writelen = n2, t2.writecb = o2, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new A("write")) : r2 ? e2._writev(i2, t2.onwrite) : e2._write(i2, s2, t2.onwrite), t2.sync = false;
        }
        function N(e2, t2, r2, n2) {
          --t2.pendingcb, n2(r2), W(t2), O(e2, r2);
        }
        function U(e2, t2) {
          const r2 = e2._writableState, i2 = r2.sync, s2 = r2.writecb;
          "function" == typeof s2 ? (r2.writing = false, r2.writecb = null, r2.length -= r2.writelen, r2.writelen = 0, t2 ? (t2.stack, r2.errored || (r2.errored = t2), e2._readableState && !e2._readableState.errored && (e2._readableState.errored = t2), i2 ? n.nextTick(N, e2, r2, t2, s2) : N(e2, r2, t2, s2)) : (r2.buffered.length > r2.bufferedIndex && q(e2, r2), i2 ? null !== r2.afterWriteTickInfo && r2.afterWriteTickInfo.cb === s2 ? r2.afterWriteTickInfo.count++ : (r2.afterWriteTickInfo = { count: 1, cb: s2, stream: e2, state: r2 }, n.nextTick(D, r2.afterWriteTickInfo)) : F(e2, r2, 1, s2))) : O(e2, new S());
        }
        function D({ stream: e2, state: t2, count: r2, cb: n2 }) {
          return t2.afterWriteTickInfo = null, F(e2, t2, r2, n2);
        }
        function F(e2, t2, r2, n2) {
          for (!t2.ending && !e2.destroyed && 0 === t2.length && t2.needDrain && (t2.needDrain = false, e2.emit("drain")); r2-- > 0; )
            t2.pendingcb--, n2();
          t2.destroyed && W(t2), V(e2, t2);
        }
        function W(e2) {
          if (e2.writing)
            return;
          for (let r3 = e2.bufferedIndex; r3 < e2.buffered.length; ++r3) {
            var t2;
            const { chunk: n3, callback: i2 } = e2.buffered[r3], s2 = e2.objectMode ? 1 : n3.length;
            e2.length -= s2, i2(null !== (t2 = e2.errored) && void 0 !== t2 ? t2 : new A("write"));
          }
          const r2 = e2[P].splice(0);
          for (let t3 = 0; t3 < r2.length; t3++) {
            var n2;
            r2[t3](null !== (n2 = e2.errored) && void 0 !== n2 ? n2 : new A("end"));
          }
          M(e2);
        }
        function q(e2, t2) {
          if (t2.corked || t2.bufferProcessing || t2.destroyed || !t2.constructed)
            return;
          const { buffered: r2, bufferedIndex: n2, objectMode: s2 } = t2, o2 = r2.length - n2;
          if (!o2)
            return;
          let a2 = n2;
          if (t2.bufferProcessing = true, o2 > 1 && e2._writev) {
            t2.pendingcb -= o2 - 1;
            const n3 = t2.allNoop ? C : (e3) => {
              for (let t3 = a2; t3 < r2.length; ++t3)
                r2[t3].callback(e3);
            }, s3 = t2.allNoop && 0 === a2 ? r2 : i(r2, a2);
            s3.allBuffers = t2.allBuffers, j(e2, t2, true, t2.length, s3, "", n3), M(t2);
          } else {
            do {
              const { chunk: n3, encoding: i2, callback: o3 } = r2[a2];
              r2[a2++] = null;
              j(e2, t2, false, s2 ? 1 : n3.length, n3, i2, o3);
            } while (a2 < r2.length && !t2.writing);
            a2 === r2.length ? M(t2) : a2 > 256 ? (r2.splice(0, a2), t2.bufferedIndex = 0) : t2.bufferedIndex = a2;
          }
          t2.bufferProcessing = false;
        }
        function H(e2) {
          return e2.ending && !e2.destroyed && e2.constructed && 0 === e2.length && !e2.errored && 0 === e2.buffered.length && !e2.finished && !e2.writing && !e2.errorEmitted && !e2.closeEmitted;
        }
        function z(e2, t2) {
          t2.prefinished || t2.finalCalled || ("function" != typeof e2._final || t2.destroyed ? (t2.prefinished = true, e2.emit("prefinish")) : (t2.finalCalled = true, function(e3, t3) {
            let r2 = false;
            function i2(i3) {
              if (r2)
                O(e3, null != i3 ? i3 : S());
              else if (r2 = true, t3.pendingcb--, i3) {
                const r3 = t3[P].splice(0);
                for (let e4 = 0; e4 < r3.length; e4++)
                  r3[e4](i3);
                O(e3, i3, t3.sync);
              } else
                H(t3) && (t3.prefinished = true, e3.emit("prefinish"), t3.pendingcb++, n.nextTick($, e3, t3));
            }
            t3.sync = true, t3.pendingcb++;
            try {
              e3._final(i2);
            } catch (e4) {
              i2(e4);
            }
            t3.sync = false;
          }(e2, t2)));
        }
        function V(e2, t2, r2) {
          H(t2) && (z(e2, t2), 0 === t2.pendingcb && (r2 ? (t2.pendingcb++, n.nextTick((e3, t3) => {
            H(t3) ? $(e3, t3) : t3.pendingcb--;
          }, e2, t2)) : H(t2) && (t2.pendingcb++, $(e2, t2))));
        }
        function $(e2, t2) {
          t2.pendingcb--, t2.finished = true;
          const r2 = t2[P].splice(0);
          for (let e3 = 0; e3 < r2.length; e3++)
            r2[e3]();
          if (e2.emit("finish"), t2.autoDestroy) {
            const t3 = e2._readableState;
            (!t3 || t3.autoDestroy && (t3.endEmitted || false === t3.readable)) && e2.destroy();
          }
        }
        x.prototype.getBuffer = function() {
          return i(this.buffered, this.bufferedIndex);
        }, a(x.prototype, "bufferedRequestCount", { __proto__: null, get() {
          return this.buffered.length - this.bufferedIndex;
        } }), a(B, f, { __proto__: null, value: function(e2) {
          return !!o(this, e2) || this === B && (e2 && e2._writableState instanceof x);
        } }), B.prototype.pipe = function() {
          O(this, new E());
        }, B.prototype.write = function(e2, t2, r2) {
          return true === L(this, e2, t2, r2);
        }, B.prototype.cork = function() {
          this._writableState.corked++;
        }, B.prototype.uncork = function() {
          const e2 = this._writableState;
          e2.corked && (e2.corked--, e2.writing || q(this, e2));
        }, B.prototype.setDefaultEncoding = function(e2) {
          if ("string" == typeof e2 && (e2 = c(e2)), !b.isEncoding(e2))
            throw new R(e2);
          return this._writableState.defaultEncoding = e2, this;
        }, B.prototype._write = function(e2, t2, r2) {
          if (!this._writev)
            throw new v("_write()");
          this._writev([{ chunk: e2, encoding: t2 }], r2);
        }, B.prototype._writev = null, B.prototype.end = function(e2, t2, r2) {
          const i2 = this._writableState;
          let o2;
          if ("function" == typeof e2 ? (r2 = e2, e2 = null, t2 = null) : "function" == typeof t2 && (r2 = t2, t2 = null), null != e2) {
            const r3 = L(this, e2, t2);
            r3 instanceof s && (o2 = r3);
          }
          return i2.corked && (i2.corked = 1, this.uncork()), o2 || (i2.errored || i2.ending ? i2.finished ? o2 = new k("end") : i2.destroyed && (o2 = new A("end")) : (i2.ending = true, V(this, i2, true), i2.ended = true)), "function" == typeof r2 && (o2 || i2.finished ? n.nextTick(r2, o2) : i2[P].push(r2)), this;
        }, l(B.prototype, { closed: { __proto__: null, get() {
          return !!this._writableState && this._writableState.closed;
        } }, destroyed: { __proto__: null, get() {
          return !!this._writableState && this._writableState.destroyed;
        }, set(e2) {
          this._writableState && (this._writableState.destroyed = e2);
        } }, writable: { __proto__: null, get() {
          const e2 = this._writableState;
          return !(!e2 || false === e2.writable || e2.destroyed || e2.errored || e2.ending || e2.ended);
        }, set(e2) {
          this._writableState && (this._writableState.writable = !!e2);
        } }, writableFinished: { __proto__: null, get() {
          return !!this._writableState && this._writableState.finished;
        } }, writableObjectMode: { __proto__: null, get() {
          return !!this._writableState && this._writableState.objectMode;
        } }, writableBuffer: { __proto__: null, get() {
          return this._writableState && this._writableState.getBuffer();
        } }, writableEnded: { __proto__: null, get() {
          return !!this._writableState && this._writableState.ending;
        } }, writableNeedDrain: { __proto__: null, get() {
          const e2 = this._writableState;
          return !!e2 && (!e2.destroyed && !e2.ending && e2.needDrain);
        } }, writableHighWaterMark: { __proto__: null, get() {
          return this._writableState && this._writableState.highWaterMark;
        } }, writableCorked: { __proto__: null, get() {
          return this._writableState ? this._writableState.corked : 0;
        } }, writableLength: { __proto__: null, get() {
          return this._writableState && this._writableState.length;
        } }, errored: { __proto__: null, enumerable: false, get() {
          return this._writableState ? this._writableState.errored : null;
        } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
          return !(false === this._writableState.writable || !this._writableState.destroyed && !this._writableState.errored || this._writableState.finished);
        } } });
        const K = g.destroy;
        let G;
        function Q() {
          return void 0 === G && (G = {}), G;
        }
        B.prototype.destroy = function(e2, t2) {
          const r2 = this._writableState;
          return !r2.destroyed && (r2.bufferedIndex < r2.buffered.length || r2[P].length) && n.nextTick(W, r2), K.call(this, e2, t2), this;
        }, B.prototype._undestroy = g.undestroy, B.prototype._destroy = function(e2, t2) {
          t2(e2);
        }, B.prototype[d.captureRejectionSymbol] = function(e2) {
          this.destroy(e2);
        }, B.fromWeb = function(e2, t2) {
          return Q().newStreamWritableFromWritableStream(e2, t2);
        }, B.toWeb = function(e2) {
          return Q().newWritableStreamFromStreamWritable(e2);
        };
      }, { "../../ours/errors": 126, "../../ours/primordials": 127, "./add-abort-signal": 107, "./destroy": 110, "./duplex": 111, "./legacy": 115, "./state": 120, buffer: 29, events: 49, "process/": 102 }], 124: [function(e, t, r) {
        "use strict";
        const { ArrayIsArray: n, ArrayPrototypeIncludes: i, ArrayPrototypeJoin: s, ArrayPrototypeMap: o, NumberIsInteger: a, NumberIsNaN: l, NumberMAX_SAFE_INTEGER: u, NumberMIN_SAFE_INTEGER: c, NumberParseInt: h, ObjectPrototypeHasOwnProperty: f, RegExpPrototypeExec: d, String: p, StringPrototypeToUpperCase: b, StringPrototypeTrim: g } = e("../ours/primordials"), { hideStackFrames: m, codes: { ERR_SOCKET_BAD_PORT: y, ERR_INVALID_ARG_TYPE: _, ERR_INVALID_ARG_VALUE: w, ERR_OUT_OF_RANGE: v, ERR_UNKNOWN_SIGNAL: S } } = e("../ours/errors"), { normalizeEncoding: E } = e("../ours/util"), { isAsyncFunction: A, isArrayBufferView: k } = e("../ours/util").types, T = {};
        const I = /^[0-7]+$/;
        const R = m((e2, t2, r2 = c, n2 = u) => {
          if ("number" != typeof e2)
            throw new _(t2, "number", e2);
          if (!a(e2))
            throw new v(t2, "an integer", e2);
          if (e2 < r2 || e2 > n2)
            throw new v(t2, `>= ${r2} && <= ${n2}`, e2);
        }), O = m((e2, t2, r2 = -2147483648, n2 = 2147483647) => {
          if ("number" != typeof e2)
            throw new _(t2, "number", e2);
          if (!a(e2))
            throw new v(t2, "an integer", e2);
          if (e2 < r2 || e2 > n2)
            throw new v(t2, `>= ${r2} && <= ${n2}`, e2);
        }), C = m((e2, t2, r2 = false) => {
          if ("number" != typeof e2)
            throw new _(t2, "number", e2);
          if (!a(e2))
            throw new v(t2, "an integer", e2);
          const n2 = r2 ? 1 : 0, i2 = 4294967295;
          if (e2 < n2 || e2 > i2)
            throw new v(t2, `>= ${n2} && <= ${i2}`, e2);
        });
        function P(e2, t2) {
          if ("string" != typeof e2)
            throw new _(t2, "string", e2);
        }
        const x = m((e2, t2, r2) => {
          if (!i(r2, e2)) {
            const n2 = s(o(r2, (e3) => "string" == typeof e3 ? `'${e3}'` : p(e3)), ", ");
            throw new w(t2, e2, "must be one of: " + n2);
          }
        });
        function M(e2, t2) {
          if ("boolean" != typeof e2)
            throw new _(t2, "boolean", e2);
        }
        function B(e2, t2, r2) {
          return null != e2 && f(e2, t2) ? e2[t2] : r2;
        }
        const L = m((e2, t2, r2 = null) => {
          const i2 = B(r2, "allowArray", false), s2 = B(r2, "allowFunction", false);
          if (!B(r2, "nullable", false) && null === e2 || !i2 && n(e2) || "object" != typeof e2 && (!s2 || "function" != typeof e2))
            throw new _(t2, "Object", e2);
        }), j = m((e2, t2) => {
          if (null != e2 && "object" != typeof e2 && "function" != typeof e2)
            throw new _(t2, "a dictionary", e2);
        }), N = m((e2, t2, r2 = 0) => {
          if (!n(e2))
            throw new _(t2, "Array", e2);
          if (e2.length < r2) {
            throw new w(t2, e2, `must be longer than ${r2}`);
          }
        });
        const U = m((e2, t2 = "buffer") => {
          if (!k(e2))
            throw new _(t2, ["Buffer", "TypedArray", "DataView"], e2);
        });
        const D = m((e2, t2) => {
          if (void 0 !== e2 && (null === e2 || "object" != typeof e2 || !("aborted" in e2)))
            throw new _(t2, "AbortSignal", e2);
        }), F = m((e2, t2) => {
          if ("function" != typeof e2)
            throw new _(t2, "Function", e2);
        }), W = m((e2, t2) => {
          if ("function" != typeof e2 || A(e2))
            throw new _(t2, "Function", e2);
        }), q = m((e2, t2) => {
          if (void 0 !== e2)
            throw new _(t2, "undefined", e2);
        });
        const H = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
        function z(e2, t2) {
          if (void 0 === e2 || !d(H, e2))
            throw new w(t2, e2, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        }
        t.exports = { isInt32: function(e2) {
          return e2 === (0 | e2);
        }, isUint32: function(e2) {
          return e2 === e2 >>> 0;
        }, parseFileMode: function(e2, t2, r2) {
          if (void 0 === e2 && (e2 = r2), "string" == typeof e2) {
            if (null === d(I, e2))
              throw new w(t2, e2, "must be a 32-bit unsigned integer or an octal string");
            e2 = h(e2, 8);
          }
          return C(e2, t2), e2;
        }, validateArray: N, validateStringArray: function(e2, t2) {
          N(e2, t2);
          for (let r2 = 0; r2 < e2.length; r2++)
            P(e2[r2], `${t2}[${r2}]`);
        }, validateBooleanArray: function(e2, t2) {
          N(e2, t2);
          for (let r2 = 0; r2 < e2.length; r2++)
            M(e2[r2], `${t2}[${r2}]`);
        }, validateBoolean: M, validateBuffer: U, validateDictionary: j, validateEncoding: function(e2, t2) {
          const r2 = E(t2), n2 = e2.length;
          if ("hex" === r2 && n2 % 2 != 0)
            throw new w("encoding", t2, `is invalid for data of length ${n2}`);
        }, validateFunction: F, validateInt32: O, validateInteger: R, validateNumber: function(e2, t2, r2 = void 0, n2) {
          if ("number" != typeof e2)
            throw new _(t2, "number", e2);
          if (null != r2 && e2 < r2 || null != n2 && e2 > n2 || (null != r2 || null != n2) && l(e2))
            throw new v(t2, `${null != r2 ? `>= ${r2}` : ""}${null != r2 && null != n2 ? " && " : ""}${null != n2 ? `<= ${n2}` : ""}`, e2);
        }, validateObject: L, validateOneOf: x, validatePlainFunction: W, validatePort: function(e2, t2 = "Port", r2 = true) {
          if ("number" != typeof e2 && "string" != typeof e2 || "string" == typeof e2 && 0 === g(e2).length || +e2 != +e2 >>> 0 || e2 > 65535 || 0 === e2 && !r2)
            throw new y(t2, e2, r2);
          return 0 | e2;
        }, validateSignalName: function(e2, t2 = "signal") {
          if (P(e2, t2), void 0 === T[e2]) {
            if (void 0 !== T[b(e2)])
              throw new S(e2 + " (signals must use all capital letters)");
            throw new S(e2);
          }
        }, validateString: P, validateUint32: C, validateUndefined: q, validateUnion: function(e2, t2, r2) {
          if (!i(r2, e2))
            throw new _(t2, `('${s(r2, "|")}')`, e2);
        }, validateAbortSignal: D, validateLinkHeaderValue: function(e2) {
          if ("string" == typeof e2)
            return z(e2, "hints"), e2;
          if (n(e2)) {
            const t2 = e2.length;
            let r2 = "";
            if (0 === t2)
              return r2;
            for (let n2 = 0; n2 < t2; n2++) {
              const i2 = e2[n2];
              z(i2, "hints"), r2 += i2, n2 !== t2 - 1 && (r2 += ", ");
            }
            return r2;
          }
          throw new w("hints", e2, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
        } };
      }, { "../ours/errors": 126, "../ours/primordials": 127, "../ours/util": 128 }], 125: [function(e, t, r) {
        "use strict";
        const n = e("../stream"), i = e("../stream/promises"), s = n.Readable.destroy;
        t.exports = n.Readable, t.exports._uint8ArrayToBuffer = n._uint8ArrayToBuffer, t.exports._isUint8Array = n._isUint8Array, t.exports.isDisturbed = n.isDisturbed, t.exports.isErrored = n.isErrored, t.exports.isReadable = n.isReadable, t.exports.Readable = n.Readable, t.exports.Writable = n.Writable, t.exports.Duplex = n.Duplex, t.exports.Transform = n.Transform, t.exports.PassThrough = n.PassThrough, t.exports.addAbortSignal = n.addAbortSignal, t.exports.finished = n.finished, t.exports.destroy = n.destroy, t.exports.destroy = s, t.exports.pipeline = n.pipeline, t.exports.compose = n.compose, Object.defineProperty(n, "promises", { configurable: true, enumerable: true, get: () => i }), t.exports.Stream = n.Stream, t.exports.default = t.exports;
      }, { "../stream": 129, "../stream/promises": 130 }], 126: [function(e, t, r) {
        "use strict";
        const { format: n, inspect: i, AggregateError: s } = e("./util"), o = globalThis.AggregateError || s, a = Symbol("kIsNodeError"), l = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], u = /^([A-Z][a-z0-9]*)+$/, c = {};
        function h(e2, t2) {
          if (!e2)
            throw new c.ERR_INTERNAL_ASSERTION(t2);
        }
        function f(e2) {
          let t2 = "", r2 = e2.length;
          const n2 = "-" === e2[0] ? 1 : 0;
          for (; r2 >= n2 + 4; r2 -= 3)
            t2 = `_${e2.slice(r2 - 3, r2)}${t2}`;
          return `${e2.slice(0, r2)}${t2}`;
        }
        function d(e2, t2, r2) {
          r2 || (r2 = Error);
          class i2 extends r2 {
            constructor(...r3) {
              super(function(e3, t3, r4) {
                if ("function" == typeof t3)
                  return h(t3.length <= r4.length, `Code: ${e3}; The provided arguments length (${r4.length}) does not match the required ones (${t3.length}).`), t3(...r4);
                const i3 = (t3.match(/%[dfijoOs]/g) || []).length;
                return h(i3 === r4.length, `Code: ${e3}; The provided arguments length (${r4.length}) does not match the required ones (${i3}).`), 0 === r4.length ? t3 : n(t3, ...r4);
              }(e2, t2, r3));
            }
            toString() {
              return `${this.name} [${e2}]: ${this.message}`;
            }
          }
          Object.defineProperties(i2.prototype, { name: { value: r2.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
            return `${this.name} [${e2}]: ${this.message}`;
          }, writable: true, enumerable: false, configurable: true } }), i2.prototype.code = e2, i2.prototype[a] = true, c[e2] = i2;
        }
        function p(e2) {
          const t2 = "__node_internal_" + e2.name;
          return Object.defineProperty(e2, "name", { value: t2 }), e2;
        }
        class b extends Error {
          constructor(e2 = "The operation was aborted", t2 = void 0) {
            if (void 0 !== t2 && "object" != typeof t2)
              throw new c.ERR_INVALID_ARG_TYPE("options", "Object", t2);
            super(e2, t2), this.code = "ABORT_ERR", this.name = "AbortError";
          }
        }
        d("ERR_ASSERTION", "%s", Error), d("ERR_INVALID_ARG_TYPE", (e2, t2, r2) => {
          h("string" == typeof e2, "'name' must be a string"), Array.isArray(t2) || (t2 = [t2]);
          let n2 = "The ";
          e2.endsWith(" argument") ? n2 += `${e2} ` : n2 += `"${e2}" ${e2.includes(".") ? "property" : "argument"} `, n2 += "must be ";
          const s2 = [], o2 = [], a2 = [];
          for (const e3 of t2)
            h("string" == typeof e3, "All expected entries have to be of type string"), l.includes(e3) ? s2.push(e3.toLowerCase()) : u.test(e3) ? o2.push(e3) : (h("object" !== e3, 'The value "object" should be written as "Object"'), a2.push(e3));
          if (o2.length > 0) {
            const e3 = s2.indexOf("object");
            -1 !== e3 && (s2.splice(s2, e3, 1), o2.push("Object"));
          }
          if (s2.length > 0) {
            switch (s2.length) {
              case 1:
                n2 += `of type ${s2[0]}`;
                break;
              case 2:
                n2 += `one of type ${s2[0]} or ${s2[1]}`;
                break;
              default: {
                const e3 = s2.pop();
                n2 += `one of type ${s2.join(", ")}, or ${e3}`;
              }
            }
            (o2.length > 0 || a2.length > 0) && (n2 += " or ");
          }
          if (o2.length > 0) {
            switch (o2.length) {
              case 1:
                n2 += `an instance of ${o2[0]}`;
                break;
              case 2:
                n2 += `an instance of ${o2[0]} or ${o2[1]}`;
                break;
              default: {
                const e3 = o2.pop();
                n2 += `an instance of ${o2.join(", ")}, or ${e3}`;
              }
            }
            a2.length > 0 && (n2 += " or ");
          }
          switch (a2.length) {
            case 0:
              break;
            case 1:
              a2[0].toLowerCase() !== a2[0] && (n2 += "an "), n2 += `${a2[0]}`;
              break;
            case 2:
              n2 += `one of ${a2[0]} or ${a2[1]}`;
              break;
            default: {
              const e3 = a2.pop();
              n2 += `one of ${a2.join(", ")}, or ${e3}`;
            }
          }
          if (null == r2)
            n2 += `. Received ${r2}`;
          else if ("function" == typeof r2 && r2.name)
            n2 += `. Received function ${r2.name}`;
          else if ("object" == typeof r2) {
            var c2;
            if (null !== (c2 = r2.constructor) && void 0 !== c2 && c2.name)
              n2 += `. Received an instance of ${r2.constructor.name}`;
            else {
              n2 += `. Received ${i(r2, { depth: -1 })}`;
            }
          } else {
            let e3 = i(r2, { colors: false });
            e3.length > 25 && (e3 = `${e3.slice(0, 25)}...`), n2 += `. Received type ${typeof r2} (${e3})`;
          }
          return n2;
        }, TypeError), d("ERR_INVALID_ARG_VALUE", (e2, t2, r2 = "is invalid") => {
          let n2 = i(t2);
          n2.length > 128 && (n2 = n2.slice(0, 128) + "...");
          return `The ${e2.includes(".") ? "property" : "argument"} '${e2}' ${r2}. Received ${n2}`;
        }, TypeError), d("ERR_INVALID_RETURN_VALUE", (e2, t2, r2) => {
          var n2;
          return `Expected ${e2} to be returned from the "${t2}" function but got ${null != r2 && null !== (n2 = r2.constructor) && void 0 !== n2 && n2.name ? `instance of ${r2.constructor.name}` : "type " + typeof r2}.`;
        }, TypeError), d("ERR_MISSING_ARGS", (...e2) => {
          let t2;
          h(e2.length > 0, "At least one arg needs to be specified");
          const r2 = e2.length;
          switch (e2 = (Array.isArray(e2) ? e2 : [e2]).map((e3) => `"${e3}"`).join(" or "), r2) {
            case 1:
              t2 += `The ${e2[0]} argument`;
              break;
            case 2:
              t2 += `The ${e2[0]} and ${e2[1]} arguments`;
              break;
            default: {
              const r3 = e2.pop();
              t2 += `The ${e2.join(", ")}, and ${r3} arguments`;
            }
          }
          return `${t2} must be specified`;
        }, TypeError), d("ERR_OUT_OF_RANGE", (e2, t2, r2) => {
          let n2;
          return h(t2, 'Missing "range" argument'), Number.isInteger(r2) && Math.abs(r2) > 2 ** 32 ? n2 = f(String(r2)) : "bigint" == typeof r2 ? (n2 = String(r2), (r2 > 2n ** 32n || r2 < -(2n ** 32n)) && (n2 = f(n2)), n2 += "n") : n2 = i(r2), `The value of "${e2}" is out of range. It must be ${t2}. Received ${n2}`;
        }, RangeError), d("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), d("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), d("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), d("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), d("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), d("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), d("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), d("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), d("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), d("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), d("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), t.exports = { AbortError: b, aggregateTwoErrors: p(function(e2, t2) {
          if (e2 && t2 && e2 !== t2) {
            if (Array.isArray(t2.errors))
              return t2.errors.push(e2), t2;
            const r2 = new o([t2, e2], t2.message);
            return r2.code = t2.code, r2;
          }
          return e2 || t2;
        }), hideStackFrames: p, codes: c };
      }, { "./util": 128 }], 127: [function(e, t, r) {
        "use strict";
        t.exports = { ArrayIsArray: (e2) => Array.isArray(e2), ArrayPrototypeIncludes: (e2, t2) => e2.includes(t2), ArrayPrototypeIndexOf: (e2, t2) => e2.indexOf(t2), ArrayPrototypeJoin: (e2, t2) => e2.join(t2), ArrayPrototypeMap: (e2, t2) => e2.map(t2), ArrayPrototypePop: (e2, t2) => e2.pop(t2), ArrayPrototypePush: (e2, t2) => e2.push(t2), ArrayPrototypeSlice: (e2, t2, r2) => e2.slice(t2, r2), Error, FunctionPrototypeCall: (e2, t2, ...r2) => e2.call(t2, ...r2), FunctionPrototypeSymbolHasInstance: (e2, t2) => Function.prototype[Symbol.hasInstance].call(e2, t2), MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties: (e2, t2) => Object.defineProperties(e2, t2), ObjectDefineProperty: (e2, t2, r2) => Object.defineProperty(e2, t2, r2), ObjectGetOwnPropertyDescriptor: (e2, t2) => Object.getOwnPropertyDescriptor(e2, t2), ObjectKeys: (e2) => Object.keys(e2), ObjectSetPrototypeOf: (e2, t2) => Object.setPrototypeOf(e2, t2), Promise, PromisePrototypeCatch: (e2, t2) => e2.catch(t2), PromisePrototypeThen: (e2, t2, r2) => e2.then(t2, r2), PromiseReject: (e2) => Promise.reject(e2), ReflectApply: Reflect.apply, RegExpPrototypeTest: (e2, t2) => e2.test(t2), SafeSet: Set, String, StringPrototypeSlice: (e2, t2, r2) => e2.slice(t2, r2), StringPrototypeToLowerCase: (e2) => e2.toLowerCase(), StringPrototypeToUpperCase: (e2) => e2.toUpperCase(), StringPrototypeTrim: (e2) => e2.trim(), Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet: (e2, t2, r2) => e2.set(t2, r2), Uint8Array };
      }, {}], 128: [function(e, t, r) {
        "use strict";
        const n = e("buffer"), i = Object.getPrototypeOf(async function() {
        }).constructor, s = globalThis.Blob || n.Blob, o = void 0 !== s ? function(e2) {
          return e2 instanceof s;
        } : function(e2) {
          return false;
        };
        class a extends Error {
          constructor(e2) {
            if (!Array.isArray(e2))
              throw new TypeError("Expected input to be an Array, got " + typeof e2);
            let t2 = "";
            for (let r2 = 0; r2 < e2.length; r2++)
              t2 += `    ${e2[r2].stack}
`;
            super(t2), this.name = "AggregateError", this.errors = e2;
          }
        }
        t.exports = { AggregateError: a, kEmptyObject: Object.freeze({}), once(e2) {
          let t2 = false;
          return function(...r2) {
            t2 || (t2 = true, e2.apply(this, r2));
          };
        }, createDeferredPromise: function() {
          let e2, t2;
          return { promise: new Promise((r2, n2) => {
            e2 = r2, t2 = n2;
          }), resolve: e2, reject: t2 };
        }, promisify: (e2) => new Promise((t2, r2) => {
          e2((e3, ...n2) => e3 ? r2(e3) : t2(...n2));
        }), debuglog: () => function() {
        }, format: (e2, ...t2) => e2.replace(/%([sdifj])/g, function(...[e3, r2]) {
          const n2 = t2.shift();
          if ("f" === r2)
            return n2.toFixed(6);
          if ("j" === r2)
            return JSON.stringify(n2);
          if ("s" === r2 && "object" == typeof n2) {
            return `${n2.constructor !== Object ? n2.constructor.name : ""} {}`.trim();
          }
          return n2.toString();
        }), inspect(e2) {
          switch (typeof e2) {
            case "string":
              if (e2.includes("'")) {
                if (!e2.includes('"'))
                  return `"${e2}"`;
                if (!e2.includes("`") && !e2.includes("${"))
                  return `\`${e2}\``;
              }
              return `'${e2}'`;
            case "number":
              return isNaN(e2) ? "NaN" : Object.is(e2, -0) ? String(e2) : e2;
            case "bigint":
              return `${String(e2)}n`;
            case "boolean":
            case "undefined":
              return String(e2);
            case "object":
              return "{}";
          }
        }, types: { isAsyncFunction: (e2) => e2 instanceof i, isArrayBufferView: (e2) => ArrayBuffer.isView(e2) }, isBlob: o }, t.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
      }, { buffer: 29 }], 129: [function(e, t, r) {
        const { Buffer: n } = e("buffer"), { ObjectDefineProperty: i, ObjectKeys: s, ReflectApply: o } = e("./ours/primordials"), { promisify: { custom: a } } = e("./ours/util"), { streamReturningOperators: l, promiseReturningOperators: u } = e("./internal/streams/operators"), { codes: { ERR_ILLEGAL_CONSTRUCTOR: c } } = e("./ours/errors"), h = e("./internal/streams/compose"), { pipeline: f } = e("./internal/streams/pipeline"), { destroyer: d } = e("./internal/streams/destroy"), p = e("./internal/streams/end-of-stream"), b = e("./stream/promises"), g = e("./internal/streams/utils"), m = t.exports = e("./internal/streams/legacy").Stream;
        m.isDisturbed = g.isDisturbed, m.isErrored = g.isErrored, m.isReadable = g.isReadable, m.Readable = e("./internal/streams/readable");
        for (const w of s(l)) {
          let y2 = function(...e2) {
            if (new.target)
              throw c();
            return m.Readable.from(o(v, this, e2));
          };
          var y = y2;
          const v = l[w];
          i(y2, "name", { __proto__: null, value: v.name }), i(y2, "length", { __proto__: null, value: v.length }), i(m.Readable.prototype, w, { __proto__: null, value: y2, enumerable: false, configurable: true, writable: true });
        }
        for (const S of s(u)) {
          let y2 = function(...e2) {
            if (new.target)
              throw c();
            return o(E, this, e2);
          };
          var y = y2;
          const E = u[S];
          i(y2, "name", { __proto__: null, value: E.name }), i(y2, "length", { __proto__: null, value: E.length }), i(m.Readable.prototype, S, { __proto__: null, value: y2, enumerable: false, configurable: true, writable: true });
        }
        m.Writable = e("./internal/streams/writable"), m.Duplex = e("./internal/streams/duplex"), m.Transform = e("./internal/streams/transform"), m.PassThrough = e("./internal/streams/passthrough"), m.pipeline = f;
        const { addAbortSignal: _ } = e("./internal/streams/add-abort-signal");
        m.addAbortSignal = _, m.finished = p, m.destroy = d, m.compose = h, i(m, "promises", { __proto__: null, configurable: true, enumerable: true, get: () => b }), i(f, a, { __proto__: null, enumerable: true, get: () => b.pipeline }), i(p, a, { __proto__: null, enumerable: true, get: () => b.finished }), m.Stream = m, m._isUint8Array = function(e2) {
          return e2 instanceof Uint8Array;
        }, m._uint8ArrayToBuffer = function(e2) {
          return n.from(e2.buffer, e2.byteOffset, e2.byteLength);
        };
      }, { "./internal/streams/add-abort-signal": 107, "./internal/streams/compose": 109, "./internal/streams/destroy": 110, "./internal/streams/duplex": 111, "./internal/streams/end-of-stream": 113, "./internal/streams/legacy": 115, "./internal/streams/operators": 116, "./internal/streams/passthrough": 117, "./internal/streams/pipeline": 118, "./internal/streams/readable": 119, "./internal/streams/transform": 121, "./internal/streams/utils": 122, "./internal/streams/writable": 123, "./ours/errors": 126, "./ours/primordials": 127, "./ours/util": 128, "./stream/promises": 130, buffer: 29 }], 130: [function(e, t, r) {
        "use strict";
        const { ArrayPrototypePop: n, Promise: i } = e("../ours/primordials"), { isIterable: s, isNodeStream: o, isWebStream: a } = e("../internal/streams/utils"), { pipelineImpl: l } = e("../internal/streams/pipeline"), { finished: u } = e("../internal/streams/end-of-stream");
        e("../../lib/stream.js"), t.exports = { finished: u, pipeline: function(...e2) {
          return new i((t2, r2) => {
            let i2, u2;
            const c = e2[e2.length - 1];
            if (c && "object" == typeof c && !o(c) && !s(c) && !a(c)) {
              const t3 = n(e2);
              i2 = t3.signal, u2 = t3.end;
            }
            l(e2, (e3, n2) => {
              e3 ? r2(e3) : t2(n2);
            }, { signal: i2, end: u2 });
          });
        } };
      }, { "../../lib/stream.js": 129, "../internal/streams/end-of-stream": 113, "../internal/streams/pipeline": 118, "../internal/streams/utils": 122, "../ours/primordials": 127 }], 131: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          var n2 = this;
          this._callback = e2, this._args = r2, this._interval = setInterval(e2, t2, this._args), this.reschedule = function(e3) {
            e3 || (e3 = n2._interval), n2._interval && clearInterval(n2._interval), n2._interval = setInterval(n2._callback, e3, n2._args);
          }, this.clear = function() {
            n2._interval && (clearInterval(n2._interval), n2._interval = void 0);
          }, this.destroy = function() {
            n2._interval && clearInterval(n2._interval), n2._callback = void 0, n2._interval = void 0, n2._args = void 0;
          };
        }
        t.exports = function() {
          if ("function" != typeof arguments[0])
            throw new Error("callback needed");
          if ("number" != typeof arguments[1])
            throw new Error("interval needed");
          var e2;
          if (arguments.length > 0) {
            e2 = new Array(arguments.length - 2);
            for (var t2 = 0; t2 < e2.length; t2++)
              e2[t2] = arguments[t2 + 2];
          }
          return new n(arguments[0], arguments[1], e2);
        };
      }, {}], 132: [function(e, t, r) {
        "use strict";
        t.exports = e("./index.js")();
      }, { "./index.js": 133 }], 133: [function(e, t, r) {
        (function(e2) {
          (function() {
            "use strict";
            function r2(t2) {
              return t2 instanceof e2 ? e2.from(t2) : new t2.constructor(t2.buffer.slice(), t2.byteOffset, t2.length);
            }
            t.exports = function(e3) {
              return (e3 = e3 || {}).circles ? function(e4) {
                var t3 = [], n = [];
                return e4.proto ? function e5(s) {
                  if ("object" != typeof s || null === s)
                    return s;
                  if (s instanceof Date)
                    return new Date(s);
                  if (Array.isArray(s))
                    return i(s, e5);
                  if (s instanceof Map)
                    return new Map(i(Array.from(s), e5));
                  if (s instanceof Set)
                    return new Set(i(Array.from(s), e5));
                  var o = {};
                  for (var a in t3.push(s), n.push(o), s) {
                    var l = s[a];
                    if ("object" != typeof l || null === l)
                      o[a] = l;
                    else if (l instanceof Date)
                      o[a] = new Date(l);
                    else if (l instanceof Map)
                      o[a] = new Map(i(Array.from(l), e5));
                    else if (l instanceof Set)
                      o[a] = new Set(i(Array.from(l), e5));
                    else if (ArrayBuffer.isView(l))
                      o[a] = r2(l);
                    else {
                      var u = t3.indexOf(l);
                      o[a] = -1 !== u ? n[u] : e5(l);
                    }
                  }
                  return t3.pop(), n.pop(), o;
                } : function e5(s) {
                  if ("object" != typeof s || null === s)
                    return s;
                  if (s instanceof Date)
                    return new Date(s);
                  if (Array.isArray(s))
                    return i(s, e5);
                  if (s instanceof Map)
                    return new Map(i(Array.from(s), e5));
                  if (s instanceof Set)
                    return new Set(i(Array.from(s), e5));
                  var o = {};
                  for (var a in t3.push(s), n.push(o), s)
                    if (false !== Object.hasOwnProperty.call(s, a)) {
                      var l = s[a];
                      if ("object" != typeof l || null === l)
                        o[a] = l;
                      else if (l instanceof Date)
                        o[a] = new Date(l);
                      else if (l instanceof Map)
                        o[a] = new Map(i(Array.from(l), e5));
                      else if (l instanceof Set)
                        o[a] = new Set(i(Array.from(l), e5));
                      else if (ArrayBuffer.isView(l))
                        o[a] = r2(l);
                      else {
                        var u = t3.indexOf(l);
                        o[a] = -1 !== u ? n[u] : e5(l);
                      }
                    }
                  return t3.pop(), n.pop(), o;
                };
                function i(e5, i2) {
                  for (var s = Object.keys(e5), o = new Array(s.length), a = 0; a < s.length; a++) {
                    var l = s[a], u = e5[l];
                    if ("object" != typeof u || null === u)
                      o[l] = u;
                    else if (u instanceof Date)
                      o[l] = new Date(u);
                    else if (ArrayBuffer.isView(u))
                      o[l] = r2(u);
                    else {
                      var c = t3.indexOf(u);
                      o[l] = -1 !== c ? n[c] : i2(u);
                    }
                  }
                  return o;
                }
              }(e3) : e3.proto ? function e4(n) {
                if ("object" != typeof n || null === n)
                  return n;
                if (n instanceof Date)
                  return new Date(n);
                if (Array.isArray(n))
                  return t2(n, e4);
                if (n instanceof Map)
                  return new Map(t2(Array.from(n), e4));
                if (n instanceof Set)
                  return new Set(t2(Array.from(n), e4));
                var i = {};
                for (var s in n) {
                  var o = n[s];
                  "object" != typeof o || null === o ? i[s] = o : o instanceof Date ? i[s] = new Date(o) : o instanceof Map ? i[s] = new Map(t2(Array.from(o), e4)) : o instanceof Set ? i[s] = new Set(t2(Array.from(o), e4)) : ArrayBuffer.isView(o) ? i[s] = r2(o) : i[s] = e4(o);
                }
                return i;
              } : function e4(n) {
                if ("object" != typeof n || null === n)
                  return n;
                if (n instanceof Date)
                  return new Date(n);
                if (Array.isArray(n))
                  return t2(n, e4);
                if (n instanceof Map)
                  return new Map(t2(Array.from(n), e4));
                if (n instanceof Set)
                  return new Set(t2(Array.from(n), e4));
                var i = {};
                for (var s in n)
                  if (false !== Object.hasOwnProperty.call(n, s)) {
                    var o = n[s];
                    "object" != typeof o || null === o ? i[s] = o : o instanceof Date ? i[s] = new Date(o) : o instanceof Map ? i[s] = new Map(t2(Array.from(o), e4)) : o instanceof Set ? i[s] = new Set(t2(Array.from(o), e4)) : ArrayBuffer.isView(o) ? i[s] = r2(o) : i[s] = e4(o);
                  }
                return i;
              };
              function t2(e4, t3) {
                for (var n = Object.keys(e4), i = new Array(n.length), s = 0; s < n.length; s++) {
                  var o = n[s], a = e4[o];
                  "object" != typeof a || null === a ? i[o] = a : a instanceof Date ? i[o] = new Date(a) : ArrayBuffer.isView(a) ? i[o] = r2(a) : i[o] = t3(a);
                }
                return i;
              }
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 29 }], 134: [function(e, t, r) {
        var n = e("buffer"), i = n.Buffer;
        function s(e2, t2) {
          for (var r2 in e2)
            t2[r2] = e2[r2];
        }
        function o(e2, t2, r2) {
          return i(e2, t2, r2);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (s(n, r), r.Buffer = o), o.prototype = Object.create(i.prototype), s(i, o), o.from = function(e2, t2, r2) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t2, r2);
        }, o.alloc = function(e2, t2, r2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var n2 = i(e2);
          return void 0 !== t2 ? "string" == typeof r2 ? n2.fill(t2, r2) : n2.fill(t2) : n2.fill(0), n2;
        }, o.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, o.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e2);
        };
      }, { buffer: 29 }], 135: [function(e, t, r) {
        t.exports = function(e2) {
          var t2 = e2._readableState;
          return t2 ? t2.objectMode || "number" == typeof e2._duplexState ? e2.read() : e2.read(function(e3) {
            if (e3.buffer.length)
              return e3.buffer.head ? e3.buffer.head.data.length : e3.buffer[0].length;
            return e3.length;
          }(t2)) : null;
        };
      }, {}], 136: [function(e, t, r) {
        arguments[4][28][0].apply(r, arguments);
      }, { dup: 28, "safe-buffer": 134 }], 137: [function(e, t, r) {
        "use strict";
        var n = e("punycode"), i = e("./util");
        function s() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        r.parse = _, r.resolve = function(e2, t2) {
          return _(e2, false, true).resolve(t2);
        }, r.resolveObject = function(e2, t2) {
          return e2 ? _(e2, false, true).resolveObject(t2) : t2;
        }, r.format = function(e2) {
          i.isString(e2) && (e2 = _(e2));
          return e2 instanceof s ? e2.format() : s.prototype.format.call(e2);
        }, r.Url = s;
        var o = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(u), h = ["%", "/", "?", ";", "#"].concat(c), f = ["/", "?", "#"], d = /^[+a-z0-9A-Z_-]{0,63}$/, p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, b = { javascript: true, "javascript:": true }, g = { javascript: true, "javascript:": true }, m = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, y = e("querystring");
        function _(e2, t2, r2) {
          if (e2 && i.isObject(e2) && e2 instanceof s)
            return e2;
          var n2 = new s();
          return n2.parse(e2, t2, r2), n2;
        }
        s.prototype.parse = function(e2, t2, r2) {
          if (!i.isString(e2))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof e2);
          var s2 = e2.indexOf("?"), a2 = -1 !== s2 && s2 < e2.indexOf("#") ? "?" : "#", u2 = e2.split(a2);
          u2[0] = u2[0].replace(/\\/g, "/");
          var _2 = e2 = u2.join(a2);
          if (_2 = _2.trim(), !r2 && 1 === e2.split("#").length) {
            var w = l.exec(_2);
            if (w)
              return this.path = _2, this.href = _2, this.pathname = w[1], w[2] ? (this.search = w[2], this.query = t2 ? y.parse(this.search.substr(1)) : this.search.substr(1)) : t2 && (this.search = "", this.query = {}), this;
          }
          var v = o.exec(_2);
          if (v) {
            var S = (v = v[0]).toLowerCase();
            this.protocol = S, _2 = _2.substr(v.length);
          }
          if (r2 || v || _2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var E = "//" === _2.substr(0, 2);
            !E || v && g[v] || (_2 = _2.substr(2), this.slashes = true);
          }
          if (!g[v] && (E || v && !m[v])) {
            for (var A, k, T = -1, I = 0; I < f.length; I++) {
              -1 !== (R = _2.indexOf(f[I])) && (-1 === T || R < T) && (T = R);
            }
            -1 !== (k = -1 === T ? _2.lastIndexOf("@") : _2.lastIndexOf("@", T)) && (A = _2.slice(0, k), _2 = _2.slice(k + 1), this.auth = decodeURIComponent(A)), T = -1;
            for (I = 0; I < h.length; I++) {
              var R;
              -1 !== (R = _2.indexOf(h[I])) && (-1 === T || R < T) && (T = R);
            }
            -1 === T && (T = _2.length), this.host = _2.slice(0, T), _2 = _2.slice(T), this.parseHost(), this.hostname = this.hostname || "";
            var O = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!O)
              for (var C = this.hostname.split(/\./), P = (I = 0, C.length); I < P; I++) {
                var x = C[I];
                if (x && !x.match(d)) {
                  for (var M = "", B = 0, L = x.length; B < L; B++)
                    x.charCodeAt(B) > 127 ? M += "x" : M += x[B];
                  if (!M.match(d)) {
                    var j = C.slice(0, I), N = C.slice(I + 1), U = x.match(p);
                    U && (j.push(U[1]), N.unshift(U[2])), N.length && (_2 = "/" + N.join(".") + _2), this.hostname = j.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), O || (this.hostname = n.toASCII(this.hostname));
            var D = this.port ? ":" + this.port : "", F = this.hostname || "";
            this.host = F + D, this.href += this.host, O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== _2[0] && (_2 = "/" + _2));
          }
          if (!b[S])
            for (I = 0, P = c.length; I < P; I++) {
              var W = c[I];
              if (-1 !== _2.indexOf(W)) {
                var q = encodeURIComponent(W);
                q === W && (q = escape(W)), _2 = _2.split(W).join(q);
              }
            }
          var H = _2.indexOf("#");
          -1 !== H && (this.hash = _2.substr(H), _2 = _2.slice(0, H));
          var z = _2.indexOf("?");
          if (-1 !== z ? (this.search = _2.substr(z), this.query = _2.substr(z + 1), t2 && (this.query = y.parse(this.query)), _2 = _2.slice(0, z)) : t2 && (this.search = "", this.query = {}), _2 && (this.pathname = _2), m[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            D = this.pathname || "";
            var V = this.search || "";
            this.path = D + V;
          }
          return this.href = this.format(), this;
        }, s.prototype.format = function() {
          var e2 = this.auth || "";
          e2 && (e2 = (e2 = encodeURIComponent(e2)).replace(/%3A/i, ":"), e2 += "@");
          var t2 = this.protocol || "", r2 = this.pathname || "", n2 = this.hash || "", s2 = false, o2 = "";
          this.host ? s2 = e2 + this.host : this.hostname && (s2 = e2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (s2 += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (o2 = y.stringify(this.query));
          var a2 = this.search || o2 && "?" + o2 || "";
          return t2 && ":" !== t2.substr(-1) && (t2 += ":"), this.slashes || (!t2 || m[t2]) && false !== s2 ? (s2 = "//" + (s2 || ""), r2 && "/" !== r2.charAt(0) && (r2 = "/" + r2)) : s2 || (s2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), a2 && "?" !== a2.charAt(0) && (a2 = "?" + a2), t2 + s2 + (r2 = r2.replace(/[?#]/g, function(e3) {
            return encodeURIComponent(e3);
          })) + (a2 = a2.replace("#", "%23")) + n2;
        }, s.prototype.resolve = function(e2) {
          return this.resolveObject(_(e2, false, true)).format();
        }, s.prototype.resolveObject = function(e2) {
          if (i.isString(e2)) {
            var t2 = new s();
            t2.parse(e2, false, true), e2 = t2;
          }
          for (var r2 = new s(), n2 = Object.keys(this), o2 = 0; o2 < n2.length; o2++) {
            var a2 = n2[o2];
            r2[a2] = this[a2];
          }
          if (r2.hash = e2.hash, "" === e2.href)
            return r2.href = r2.format(), r2;
          if (e2.slashes && !e2.protocol) {
            for (var l2 = Object.keys(e2), u2 = 0; u2 < l2.length; u2++) {
              var c2 = l2[u2];
              "protocol" !== c2 && (r2[c2] = e2[c2]);
            }
            return m[r2.protocol] && r2.hostname && !r2.pathname && (r2.path = r2.pathname = "/"), r2.href = r2.format(), r2;
          }
          if (e2.protocol && e2.protocol !== r2.protocol) {
            if (!m[e2.protocol]) {
              for (var h2 = Object.keys(e2), f2 = 0; f2 < h2.length; f2++) {
                var d2 = h2[f2];
                r2[d2] = e2[d2];
              }
              return r2.href = r2.format(), r2;
            }
            if (r2.protocol = e2.protocol, e2.host || g[e2.protocol])
              r2.pathname = e2.pathname;
            else {
              for (var p2 = (e2.pathname || "").split("/"); p2.length && !(e2.host = p2.shift()); )
                ;
              e2.host || (e2.host = ""), e2.hostname || (e2.hostname = ""), "" !== p2[0] && p2.unshift(""), p2.length < 2 && p2.unshift(""), r2.pathname = p2.join("/");
            }
            if (r2.search = e2.search, r2.query = e2.query, r2.host = e2.host || "", r2.auth = e2.auth, r2.hostname = e2.hostname || e2.host, r2.port = e2.port, r2.pathname || r2.search) {
              var b2 = r2.pathname || "", y2 = r2.search || "";
              r2.path = b2 + y2;
            }
            return r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
          }
          var _2 = r2.pathname && "/" === r2.pathname.charAt(0), w = e2.host || e2.pathname && "/" === e2.pathname.charAt(0), v = w || _2 || r2.host && e2.pathname, S = v, E = r2.pathname && r2.pathname.split("/") || [], A = (p2 = e2.pathname && e2.pathname.split("/") || [], r2.protocol && !m[r2.protocol]);
          if (A && (r2.hostname = "", r2.port = null, r2.host && ("" === E[0] ? E[0] = r2.host : E.unshift(r2.host)), r2.host = "", e2.protocol && (e2.hostname = null, e2.port = null, e2.host && ("" === p2[0] ? p2[0] = e2.host : p2.unshift(e2.host)), e2.host = null), v = v && ("" === p2[0] || "" === E[0])), w)
            r2.host = e2.host || "" === e2.host ? e2.host : r2.host, r2.hostname = e2.hostname || "" === e2.hostname ? e2.hostname : r2.hostname, r2.search = e2.search, r2.query = e2.query, E = p2;
          else if (p2.length)
            E || (E = []), E.pop(), E = E.concat(p2), r2.search = e2.search, r2.query = e2.query;
          else if (!i.isNullOrUndefined(e2.search)) {
            if (A)
              r2.hostname = r2.host = E.shift(), (O = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = O.shift(), r2.host = r2.hostname = O.shift());
            return r2.search = e2.search, r2.query = e2.query, i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.href = r2.format(), r2;
          }
          if (!E.length)
            return r2.pathname = null, r2.search ? r2.path = "/" + r2.search : r2.path = null, r2.href = r2.format(), r2;
          for (var k = E.slice(-1)[0], T = (r2.host || e2.host || E.length > 1) && ("." === k || ".." === k) || "" === k, I = 0, R = E.length; R >= 0; R--)
            "." === (k = E[R]) ? E.splice(R, 1) : ".." === k ? (E.splice(R, 1), I++) : I && (E.splice(R, 1), I--);
          if (!v && !S)
            for (; I--; I)
              E.unshift("..");
          !v || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), T && "/" !== E.join("/").substr(-1) && E.push("");
          var O, C = "" === E[0] || E[0] && "/" === E[0].charAt(0);
          A && (r2.hostname = r2.host = C ? "" : E.length ? E.shift() : "", (O = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = O.shift(), r2.host = r2.hostname = O.shift()));
          return (v = v || r2.host && E.length) && !C && E.unshift(""), E.length ? r2.pathname = E.join("/") : (r2.pathname = null, r2.path = null), i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.auth = e2.auth || r2.auth, r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
        }, s.prototype.parseHost = function() {
          var e2 = this.host, t2 = a.exec(e2);
          t2 && (":" !== (t2 = t2[0]) && (this.port = t2.substr(1)), e2 = e2.substr(0, e2.length - t2.length)), e2 && (this.hostname = e2);
        };
      }, { "./util": 138, punycode: 103, querystring: 106 }], 138: [function(e, t, r) {
        "use strict";
        t.exports = { isString: function(e2) {
          return "string" == typeof e2;
        }, isObject: function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, isNull: function(e2) {
          return null === e2;
        }, isNullOrUndefined: function(e2) {
          return null == e2;
        } };
      }, {}], 139: [function(e, t, r) {
        (function(e2) {
          (function() {
            function r2(t2) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var r3 = e2.localStorage[t2];
              return null != r3 && "true" === String(r3).toLowerCase();
            }
            t.exports = function(e3, t2) {
              if (r2("noDeprecation"))
                return e3;
              var n = false;
              return function() {
                if (!n) {
                  if (r2("throwDeprecation"))
                    throw new Error(t2);
                  r2("traceDeprecation") ? console.trace(t2) : console.warn(t2), n = true;
                }
                return e3.apply(this, arguments);
              };
            };
          }).call(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 140: [function(e, t, r) {
        t.exports = function e2(t2, r2) {
          if (t2 && r2)
            return e2(t2)(r2);
          if ("function" != typeof t2)
            throw new TypeError("need wrapper function");
          return Object.keys(t2).forEach(function(e3) {
            n[e3] = t2[e3];
          }), n;
          function n() {
            for (var e3 = new Array(arguments.length), r3 = 0; r3 < e3.length; r3++)
              e3[r3] = arguments[r3];
            var n2 = t2.apply(this, e3), i = e3[e3.length - 1];
            return "function" == typeof n2 && n2 !== i && Object.keys(i).forEach(function(e4) {
              n2[e4] = i[e4];
            }), n2;
          }
        };
      }, {}], 141: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
        };
      }, {}] }, {}, [23])(23);
    });
  }
});
export default require_mqtt_min();
/*! Bundled license information:

mqtt/dist/mqtt.min.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=mqtt_dist_mqtt__min.js.map
